=== FILE TREE ===
my-abiturient/
└── .github/
    └── workflows/
        └── ci.yml
└── .gitignore
└── README.md
└── apps/
    └── api/
        └── .env.example
        └── .gitignore
        └── migrations/
            └── 001_create_documents_tables.sql
        └── package.json
        └── scripts/
            └── list_users.ts
            └── reject_latest_doc.ts
            └── reset_admin_password.ts
        └── src/
            └── admin/
                └── admin.controller.ts
                └── admin.module.ts
                └── admin.service.ts
            └── app.module.ts
            └── auth/
                └── auth.controller.ts
                └── auth.module.ts
                └── auth.service.spec.ts
                └── auth.service.ts
                └── dto/
                    └── login.dto.ts
                    └── register.dto.ts
                └── jwt-auth.guard.ts
                └── jwt.strategy.ts
                └── roles.decorator.ts
                └── roles.guard.ts
            └── camunda/
                └── camunda.controller.ts
                └── camunda.module.ts
                └── camunda.service.ts
            └── countries/
                └── countries.controller.ts
                └── countries.module.ts
                └── countries.service.ts
            └── documents/
                └── documents.controller.ts
                └── documents.module.ts
                └── documents.service.ts
            └── entities/
                └── company.entity.ts
                └── country.entity.ts
                └── curator.entity.ts
                └── document-template.entity.ts
                └── enums.ts
                └── program.entity.ts
                └── student-document.entity.ts
                └── student.entity.ts
                └── task-template.entity.ts
                └── task.entity.ts
                └── university.entity.ts
                └── user.entity.ts
            └── files/
                └── files.controller.ts
                └── files.module.ts
                └── files.service.ts
            └── main.ts
            └── seed.ts
            └── students/
                └── students.controller.ts
                └── students.module.ts
                └── students.service.ts
            └── tasks/
                └── dto/
                    └── approve-task.dto.ts
                    └── submit-task.dto.ts
                └── tasks.controller.ts
                └── tasks.module.ts
                └── tasks.service.ts
            └── telegram/
                └── telegram.module.ts
                └── telegram.service.ts
        └── test/
            └── auth.e2e-spec.ts
            └── jest-e2e.json
        └── tsconfig.build.json
        └── tsconfig.json
    └── web/
        └── .gitignore
        └── app/
            └── admin/
                └── layout.tsx
                └── review/
                    └── page.tsx
            └── curator/
                └── admin/
                    └── countries/
                        └── CountryDetailPanel.tsx
                        └── ProgramDetailModal.tsx
                        └── ProgramDetailPanel.tsx
                        └── ProgramEditModal.tsx
                        └── QuestEditModal.tsx
                        └── QuestEditor.tsx
                        └── UniversityAccordion.tsx
                        └── page.tsx
                    └── moderators/
                        └── BindStudentModal.tsx
                        └── ModeratorModal.tsx
                        └── page.tsx
                └── calendar/
                    └── page.tsx
                └── dashboard/
                    └── page.tsx
                └── layout.tsx
                └── programs-search/
                    └── page.tsx
                └── review/
                    └── page.tsx
                └── student/
                    └── [studentId]/
                        └── EditProfileModal.tsx
                        └── page.tsx
                └── students/
                    └── StudentModal.tsx
                    └── page.tsx
            └── globals.css
            └── layout.tsx
            └── login/
                └── page.tsx
            └── page.tsx
            └── register/
                └── page.tsx
            └── shared/
                └── useUIStore.ts
            └── student/
                └── calendar/
                    └── page.tsx
                └── dashboard/
                    └── page.tsx
                └── folder/
                    └── page.tsx
                └── kanban/
                    └── page.tsx
                └── layout.tsx
                └── programs/
                    └── ProgramDetailModal.tsx
                    └── page.tsx
                └── quests/
                    └── QuestDetailModal.tsx
                    └── page.tsx
        └── eslint.config.mjs
        └── lib/
            └── utils.ts
        └── mock/
            └── countries.json
            └── document_templates.json
            └── programs.json
            └── public/
            └── quest_templates.json
            └── student_progress.json
            └── students.json
            └── universities.json
            └── university_profiles.json
        └── next-env.d.ts
        └── next.config.ts
        └── package.json
        └── playwright.config.ts
        └── postcss.config.mjs
        └── shared/
            └── AuthContext.tsx
            └── Avatar.tsx
            └── Calendar.tsx
            └── CountryContext.tsx
            └── CountrySwitcher.tsx
            └── DocumentUploadModal.tsx
            └── Navbar.tsx
            └── Notifications.tsx
            └── ProgressContext.tsx
            └── Sidebar.tsx
            └── UserMenu.tsx
            └── documentData.ts
        └── tests/
            └── e2e/
                └── auth.spec.ts
        └── tsconfig.json
└── docker/
└── docker-compose.override.yml
└── docker-compose.yml
    └── api.Dockerfile
    └── web.Dockerfile
└── docs/
    └── architecture/
        └── database-schema.md
    └── epics-stories.md
    └── external_database_setup.md
    └── prd.md
    └── project-brief.md
    └── requirements/
        └── document-workflow.md
        └── prd-document-upload.md
    └── sprint-artifacts/
    └── stories/
        └── US1.1-login.md
        └── US1.2-tenant-isolation.md
        └── US1.3-role-management.md
        └── US2.1-task-matrix.md
        └── US2.2-kanban-board.md
        └── US2.3-document-upload.md
        └── US2.4-submit-task.md
        └── US2.5-xp-avatar.md
        └── US2.6-download-zip.md
        └── US3.1-curator-student-list.md
        └── US3.2-review-inbox.md
        └── US3.3-approve-submission.md
        └── US3.4-reject-submission.md
        └── US4.1-manage-uni-country.md
        └── US4.2-task-templates.md
        └── US4.3-onboard-curators.md
        └── US5.1-camunda-sync.md
        └── US5.2-link-telegram.md
        └── US5.3-parent-notifications.md
        └── US5.4-minio-storage.md
        └── manager-review.md
└── next-env.d.ts
└── package.json
└── shared/
    └── AuthContext.tsx
    └── ProgressContext.tsx
└── tsconfig.tsbuildinfo
└── tz.md

=== CODE SNAPSHOT (libraries/build/lock files excluded) ===

--- BEGIN FILE: .github/workflows/ci.yml ---
name: CI

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master, develop ]

jobs:
  lint-and-typecheck:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        app: [api, web]

    steps:
    - uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: Install Dependencies
      run: npm ci
      # Assuming root package.json has workspaces or we install in specific dirs.
      # Since it seems to be a monorepo without workspaces (std folder structure), we might need to install in each.
      # Let's check root package.json first.
      
    - name: Install dependencies for ${{ matrix.app }}
      run: |
        cd apps/${{ matrix.app }}
        npm install

    - name: Lint ${{ matrix.app }}
      run: |
        cd apps/${{ matrix.app }}
        npm run lint --if-present

    - name: Build ${{ matrix.app }}
      run: |
        cd apps/${{ matrix.app }}
        npm run build --if-present
--- END FILE: .github/workflows/ci.yml ---

--- BEGIN FILE: .gitignore ---
node_modules

# BMAD System files
.bmad/agents/
.bmad/_cfg/
.agent/
# Твой скрипт
p.py
--- END FILE: .gitignore ---

--- BEGIN FILE: README.md ---
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
# Abet_gerus

## Database Setup (Development)

Before running the API, ensure the database is ready:

1. Start Docker containers:
   ```bash
   docker-compose up -d
   ```

2. The application uses TypeORM with `synchronize: true` for development, so tables will be created automatically when you start the API.

3. To seed initial data:
   ```bash
   cd apps/api
   npm run seed
   ```
--- END FILE: README.md ---

--- BEGIN FILE: apps/api/.gitignore ---
node_modules
# Keep environment variables out of version control
.env

/generated/prisma
--- END FILE: apps/api/.gitignore ---

--- BEGIN FILE: apps/api/package.json ---
{
  "name": "applicant-api",
  "version": "0.0.1",
  "private": true,
  "scripts": {
    "prebuild": "rimraf dist",
    "start": "node dist/main.js",
    "start:dev": "ts-node -r tsconfig-paths/register src/main.ts",
    "build": "tsc -p tsconfig.build.json",
    "seed": "ts-node src/seed.ts",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage"
  },
  "dependencies": {
    "@nestjs/axios": "^3.0.0",
    "@nestjs/common": "^10.0.0",
    "@nestjs/config": "^4.0.2",
    "@nestjs/core": "^10.0.0",
    "@nestjs/jwt": "^10.2.0",
    "@nestjs/passport": "^10.0.3",
    "@nestjs/platform-express": "^10.0.0",
    "@nestjs/typeorm": "^10.0.2",
    "@types/node-telegram-bot-api": "^0.64.13",
    "archiver": "^7.0.1",
    "axios": "^1.7.0",
    "minio": "^7.1.3",
    "node-telegram-bot-api": "^0.67.0",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1",
    "pg": "^8.11.3",
    "reflect-metadata": "^0.2.0",
    "rxjs": "^7.8.0",
    "typeorm": "^0.3.20"
  },
  "devDependencies": {
    "@nestjs/testing": "^10.4.20",
    "@types/archiver": "^7.0.0",
    "@types/jest": "^30.0.0",
    "@types/multer": "^1.4.11",
    "@types/node": "^20",
    "@types/passport-jwt": "^3.0.8",
    "@types/supertest": "^6.0.0",
    "dotenv": "^16.6.1",
    "jest": "^29.7.0",
    "rimraf": "^5.0.5",
    "supertest": "^6.3.3",
    "ts-jest": "^29.4.5",
    "ts-node": "^10.9.0",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.0.0"
  },
  "overrides": {
    "tough-cookie": "^4.1.3"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}
--- END FILE: apps/api/package.json ---

--- BEGIN FILE: apps/api/scripts/list_users.ts ---

import 'dotenv/config';
import { DataSource } from 'typeorm';
import { User } from '../src/entities/user.entity';
import * as path from 'path';

const AppDataSource = new DataSource({
    type: 'postgres',
    url: process.env.DATABASE_URL,
    entities: [
        path.join(__dirname, '../src/entities/*.entity.ts')
    ],
    synchronize: true,
});

async function run() {
    try {
        await AppDataSource.initialize();
        const userRepo = AppDataSource.getRepository(User);
        const users = await userRepo.find();
        console.log('Existing Users:');
        users.forEach(u => {
            console.log(`- Email: ${u.email}, Role: ${u.role}, ID: ${u.id}`);
        });
    } catch (err) {
        console.error(err);
    } finally {
        if (AppDataSource.isInitialized) await AppDataSource.destroy();
    }
}
run();
--- END FILE: apps/api/scripts/list_users.ts ---

--- BEGIN FILE: apps/api/scripts/reject_latest_doc.ts ---

import 'dotenv/config';
import { DataSource } from 'typeorm';
import { StudentDocument, DocumentStatus } from '../src/entities/student-document.entity';
import { Student } from '../src/entities/student.entity';
import { DocumentTemplate } from '../src/entities/document-template.entity';
import * as path from 'path';

const AppDataSource = new DataSource({
    type: 'postgres',
    url: process.env.DATABASE_URL,
    entities: [
        path.join(__dirname, '../src/entities/*.entity.ts')
    ],
    synchronize: true,
});

async function run() {
    try {
        await AppDataSource.initialize();
        console.log('Data Source has been initialized!');

        const repo = AppDataSource.getRepository(StudentDocument);

        const [latestDoc] = await repo.find({
            order: { created_at: 'DESC' },
            relations: ['student', 'template'],
            take: 1
        });

        if (!latestDoc) {
            console.log('No documents found. Creating a mock document for testing...');

            const studentRepo = AppDataSource.getRepository(Student);
            const [student] = await studentRepo.find({ take: 1 });

            const tmplRepo = AppDataSource.getRepository(DocumentTemplate);
            const [tmpl] = await tmplRepo.find({ take: 1 });

            if (student && tmpl) {
                console.log(`Found student ${student.id} and template ${tmpl.id}`);
                const newDoc = new StudentDocument();
                newDoc.student = student;
                newDoc.template = tmpl;
                newDoc.status = DocumentStatus.REJECTED;
                newDoc.manager_comment = "Тестовый отказ: Качество скана слишком низкое. Пожалуйста, загрузите цветной скан в высоком разрешении, как указано в инструкции.";
                newDoc.minio_file_path = "mock/path/file.jpg";

                const saved = await repo.save(newDoc);
                console.log(`Created and rejected document ID: ${saved.id}`);
            } else {
                console.log('Cannot create mock: No student or template found.');
            }
        } else {
            latestDoc.status = DocumentStatus.REJECTED;
            latestDoc.manager_comment = "Тестовый отказ: Качество скана слишком низкое. Пожалуйста, загрузите цветной скан в высоком разрешении, как указано в инструкции.";

            await repo.save(latestDoc);
            console.log(`Updated document ID: ${latestDoc.id}`);
        }

    } catch (err) {
        console.error('Error:', err);
    } finally {
        if (AppDataSource.isInitialized) {
            await AppDataSource.destroy();
        }
    }
}

run();
--- END FILE: apps/api/scripts/reject_latest_doc.ts ---

--- BEGIN FILE: apps/api/scripts/reset_admin_password.ts ---

import 'dotenv/config';
import { DataSource } from 'typeorm';
import { User } from '../src/entities/user.entity';
import * as path from 'path';

const AppDataSource = new DataSource({
    type: 'postgres',
    url: process.env.DATABASE_URL,
    entities: [
        path.join(__dirname, '../src/entities/*.entity.ts')
    ],
    synchronize: true,
});

const hashPassword = (pwd: string) => `hashed_${pwd}`;

async function run() {
    try {
        await AppDataSource.initialize();
        const userRepo = AppDataSource.getRepository(User);

        const adminEmail = 'admin@gmail.com';
        const newPass = 'admin123';

        let admin = await userRepo.findOne({ where: { email: adminEmail } });

        if (admin) {
            admin.passwordHash = hashPassword(newPass);
            await userRepo.save(admin);
            console.log(`Updated password for ${adminEmail} to ${newPass}`);
        } else {
            console.log(`User ${adminEmail} not found.`);
        }
    } catch (err) {
        console.error(err);
    } finally {
        if (AppDataSource.isInitialized) await AppDataSource.destroy();
    }
}
run();
--- END FILE: apps/api/scripts/reset_admin_password.ts ---

--- BEGIN FILE: apps/api/src/admin/admin.controller.ts ---
import { Body, Controller, Delete, Get, Param, Patch, Post, Query, UseGuards } from "@nestjs/common";
import { AdminService } from "./admin.service";
import { JwtAuthGuard } from "../auth/jwt-auth.guard";

@Controller("admin")
@UseGuards(JwtAuthGuard)
export class AdminController {
  constructor(private readonly adminService: AdminService) {}

  @Post("countries")
  createCountry(@Body() dto: any) {
    return this.adminService.createCountry(dto);
  }

  // --- НОВЫЙ ЭНДПОИНТ ---
  @Patch("countries/:id")
  updateCountry(@Param("id") id: string, @Body() dto: any) {
    return this.adminService.updateCountry(id, dto);
  }

  @Get("universities")
  getUniversities() {
    return this.adminService.getUniversities();
  }

  @Post("universities")
  createUniversity(@Body() dto: any) {
    return this.adminService.createUniversity(dto);
  }

  @Get("task-templates")
  getTaskTemplates() {
    return this.adminService.getTaskTemplates();
  }

  @Post("task-templates")
  createTaskTemplate(@Body() dto: any) {
    return this.adminService.createTaskTemplate(dto);
  }

  @Delete("task-templates/:id")
  deleteTaskTemplate(@Param("id") id: string) {
      return this.adminService.deleteTaskTemplate(Number(id));
  }

  // --- Programs Endpoints (ВАЖНО: этот блок должен быть здесь) ---
  @Get("programs/search")
  searchPrograms(
    @Query("countryId") countryId?: string,
    @Query("universityId") universityId?: string,
    @Query("category") category?: string,
    @Query("search") search?: string
  ) {
    return this.adminService.searchPrograms({ countryId, universityId, category, search });
  }

  @Post("programs")
  createProgram(@Body() dto: any) {
    return this.adminService.createProgram(dto);
  }

  @Patch("programs/:id")
  updateProgram(@Param("id") id: string, @Body() dto: any) {
    return this.adminService.updateProgram(Number(id), dto);
  }

  @Delete("programs/:id")
  deleteProgram(@Param("id") id: string) {
    return this.adminService.deleteProgram(Number(id));
  }
  // -----------------------------------------------------------

  @Get("moderators")
  getModerators() {
    return this.adminService.getModerators();
  }

  @Post("moderators")
  createModerator(@Body() dto: any) {
    return this.adminService.createModerator(dto);
  }

  @Patch("moderators/:id")
  updateModerator(@Param("id") id: string, @Body() dto: any) {
    return this.adminService.updateModerator(id, dto);
  }

  @Delete("moderators/:id")
  deleteModerator(@Param("id") id: string) {
    return this.adminService.deleteModerator(id);
  }

  @Get("students/unassigned")
  getUnassignedStudents() {
    return this.adminService.getUnassignedStudents();
  }

  @Post("moderators/:id/assign-students")
  assignStudents(@Param("id") id: string, @Body() body: { studentIds: string[] }) {
    return this.adminService.assignStudentsToCurator(id, body.studentIds);
  }

  @Get("students")
  getStudents() {
    return this.adminService.getStudents();
  }

  @Post("students")
  createStudent(@Body() dto: any) {
    return this.adminService.createStudent(dto);
  }

  @Patch("students/:id")
  updateStudent(@Param("id") id: string, @Body() body: any) {
    // В AdminService нужно убедиться, что метод называется updateStudentAdmin (как мы сделали выше)
    return this.adminService.updateStudentAdmin(id, body);
  }

  @Delete("students/:id")
  deleteStudent(@Param("id") id: string) {
    return this.adminService.deleteStudent(id);
  }
  
  @Patch("users/:id/reset-password")
  resetPassword(@Param("id") id: string, @Body("password") password?: string) {
      return this.adminService.resetPassword(id, password);
  }
}
--- END FILE: apps/api/src/admin/admin.controller.ts ---

--- BEGIN FILE: apps/api/src/admin/admin.module.ts ---
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";
import { AdminController } from "./admin.controller";
import { AdminService } from "./admin.service";
import { Country } from "../entities/country.entity";
import { University } from "../entities/university.entity";
import { Program } from "../entities/program.entity"; // Импорт
import { TaskTemplate } from "../entities/task-template.entity";
import { User } from "../entities/user.entity";
import { Student } from "../entities/student.entity";
import { Company } from "../entities/company.entity";
import { Curator } from "../entities/curator.entity";

@Module({
  imports: [
    TypeOrmModule.forFeature([
      Country, 
      University, 
      Program, // <--- Обязательно здесь
      TaskTemplate, 
      User, 
      Student, 
      Company, 
      Curator
    ])
  ],
  controllers: [AdminController],
  providers: [AdminService],
})
export class AdminModule {}
--- END FILE: apps/api/src/admin/admin.module.ts ---

--- BEGIN FILE: apps/api/src/admin/admin.service.ts ---
import { Injectable, BadRequestException, NotFoundException } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository, IsNull, In } from "typeorm";
import { Country } from "../entities/country.entity";
import { University } from "../entities/university.entity";
import { TaskTemplate } from "../entities/task-template.entity";
import { User } from "../entities/user.entity";
import { Student } from "../entities/student.entity";
import { Company } from "../entities/company.entity";
import { Curator } from "../entities/curator.entity";
import { Role } from "../entities/enums";
import { Program } from "../entities/program.entity";

export const hashPassword = (pwd: string) => `hashed_${pwd}`;
export const unhashPassword = (hash: string) => hash ? hash.replace('hashed_', '') : '';

// Стандартный набор задач для любой новой страны
const DEFAULT_COUNTRY_TASKS = [
  { title: "Загрузить скан загранпаспорта", stage: "Документы", xpReward: 20, description: "Загрузите PDF скан главной страницы паспорта." },
  { title: "Сделать фото для визы", stage: "Документы", xpReward: 15, description: "Фото 3.5х4.5 на белом фоне." },
  { title: "Перевести аттестат/диплом", stage: "Документы", xpReward: 50, description: "Нотариально заверенный перевод на английский или язык страны." },
  { title: "Выбрать программу обучения", stage: "Подготовка", xpReward: 10, description: "Изучите список программ в университетах этой страны." },
  { title: "Написать мотивационное письмо (Draft)", stage: "Творчество", xpReward: 60, description: "Напишите черновик письма, почему вы хотите учиться именно здесь." },
  { title: "Подать заявку на визу", stage: "Виза", xpReward: 100, description: "Запишитесь в консульство и подайте документы." }
];

@Injectable()
export class AdminService {
  constructor(
    @InjectRepository(Country) private countryRepo: Repository<Country>,
    @InjectRepository(University) private uniRepo: Repository<University>,
    @InjectRepository(TaskTemplate) private taskTplRepo: Repository<TaskTemplate>,
    @InjectRepository(User) private userRepo: Repository<User>,
    @InjectRepository(Student) private studentRepo: Repository<Student>,
    @InjectRepository(Company) private companyRepo: Repository<Company>,
    @InjectRepository(Curator) private curatorRepo: Repository<Curator>,
    @InjectRepository(Program) private programRepo: Repository<Program>,
  ) { }

  async getModerators() {
    const curators = await this.userRepo.find({
      where: { role: Role.CURATOR },
      relations: ['curator'],
      // Добавляем passwordHash в выборку, чтобы его "расшифровать"
      select: ['id', 'email', 'companyId', 'isActive', 'createdAt', 'passwordHash']
    });
    const students = await this.studentRepo.find({ select: ['id', 'fullName', 'countryId', 'xpTotal'] });

    // Возвращаем кураторов с "чистым" паролем
    return {
      curators: curators.map(c => ({ ...c, password: unhashPassword(c.passwordHash) })),
      students
    };
  }

  async getStudents() {
    const students = await this.studentRepo.find({
      relations: { user: true, curator: true }, // Explicit object syntax
      order: { fullName: 'ASC' }
    });

    return students.map(s => ({
      id: s.id,
      fullName: s.fullName,
      countryId: s.countryId,
      xpTotal: s.xpTotal,
      userId: s.userId,
      email: s.user?.email || 'No Email',
      isActive: s.user?.isActive ?? false,
      password: s.user ? unhashPassword(s.user.passwordHash) : '', // Safe access
      curatorId: s.curatorId,
      curatorName: s.curator?.fullName
    }));
  }

  async getUnassignedStudents() {
    return this.studentRepo.find({
      where: { curatorId: IsNull() },
      order: { fullName: 'ASC' }
    });
  }

  async assignStudentsToCurator(moderatorUserId: string, studentIds: string[]) {
    // 1. Находим профиль куратора по ID пользователя
    const curator = await this.curatorRepo.findOne({ where: { userId: moderatorUserId } });
    if (!curator) {
      throw new NotFoundException("Curator profile not found for this user");
    }

    // 2. Обновляем студентов
    if (studentIds.length > 0) {
      await this.studentRepo.update(
        { id: In(studentIds) },
        { curatorId: curator.id }
      );

      // Синхронизируем задачи (опционально, если логика требует пересчета задач при смене куратора, 
      // но пока задачи привязаны к студенту, так что просто меняем владельца)
    }
    return { success: true };
  }

  // --- ИСПРАВЛЕНО: Реальная логика создания куратора ---
  async createModerator(data: any) {
    const company = await this.companyRepo.findOne({ where: {} });
    if (!company) throw new Error("Company not found");

    // Проверяем, существует ли пользователь с таким email
    const existing = await this.userRepo.findOne({ where: { email: data.email } });
    if (existing) {
      throw new BadRequestException("User with this email already exists");
    }

    // Генерируем пароль, если не передан
    const password = data.password || Math.random().toString(36).slice(-8);

    // 1. Создаем User
    const user = this.userRepo.create({
      email: data.email,
      passwordHash: hashPassword(password),
      role: Role.CURATOR,
      companyId: company.id,
      isActive: true
    });
    const savedUser = await this.userRepo.save(user);

    // 2. Создаем профиль Curator
    const curator = this.curatorRepo.create({
      userId: savedUser.id,
      companyId: company.id,
      fullName: data.fullName,
      specialization: data.specialization,
      bio: data.bio,
      avatarUrl: data.avatarUrl
    });
    await this.curatorRepo.save(curator);

    // Возвращаем объект юзера и сгенерированный пароль (чтобы показать его админу)
    return { ...savedUser, generatedPassword: data.password ? null : password };
  }

  // --- ИСПРАВЛЕНО: Реальная логика обновления куратора ---
  async updateModerator(id: string, data: any) {
    const user = await this.userRepo.findOne({ where: { id }, relations: ['curator'] });
    if (!user) throw new NotFoundException("Moderator not found");

    if (data.email) user.email = data.email;
    if (data.isActive !== undefined) user.isActive = data.isActive;
    // Если пришел пароль - обновляем хеш
    if (data.password) user.passwordHash = hashPassword(data.password);

    await this.userRepo.save(user);

    if (user.curator) {
      if (data.fullName) user.curator.fullName = data.fullName;
      if (data.specialization) user.curator.specialization = data.specialization;
      if (data.bio) user.curator.bio = data.bio;
      if (data.avatarUrl) user.curator.avatarUrl = data.avatarUrl;
      await this.curatorRepo.save(user.curator);
    }
    return user;
  }

  async deleteModerator(id: string) {
    const user = await this.userRepo.findOne({ where: { id, role: Role.CURATOR } });
    if (!user) throw new NotFoundException("Moderator not found");
    await this.userRepo.remove(user); // Каскадно удалит и Curator профиль
    return { success: true };
  }

  async createStudent(data: any) {
    const company = await this.companyRepo.findOne({ where: {} });
    if (!company) throw new Error("Company not found");

    const existing = await this.userRepo.findOne({ where: { email: data.email } });
    if (existing) {
      throw new BadRequestException("User with this email already exists");
    }

    const password = data.password || Math.random().toString(36).slice(-8);

    const user = this.userRepo.create({
      email: data.email,
      passwordHash: hashPassword(password),
      role: Role.STUDENT,
      companyId: company.id,
      isActive: data.isActive !== undefined ? data.isActive : true
    });
    const savedUser = await this.userRepo.save(user);

    const student = this.studentRepo.create({
      userId: savedUser.id,
      companyId: company.id,
      fullName: data.fullName,
      countryId: data.countryId,
      curatorId: data.curatorId || null,
      bindingCode: `S-${Math.floor(1000 + Math.random() * 9000)}`,
      xpTotal: 0
    });
    await this.studentRepo.save(student);

    return { ...student, generatedPassword: data.password ? null : password };
  }

  async updateStudentAdmin(id: string, data: any) {
    const student = await this.studentRepo.findOne({ where: { id }, relations: ['user'] });
    if (!student) throw new NotFoundException("Student not found");

    if (data.fullName) student.fullName = data.fullName;
    if (data.countryId) student.countryId = data.countryId;
    if (data.curatorId !== undefined) student.curatorId = data.curatorId;

    await this.studentRepo.save(student);

    if (data.email || data.isActive !== undefined) {
      if (data.email) student.user.email = data.email;
      if (data.isActive !== undefined) student.user.isActive = data.isActive;
      await this.userRepo.save(student.user);
    }

    return student;
  }

  async deleteStudent(studentId: string) {
    // 1. Находим студента, чтобы получить ID его пользователя (User)
    const student = await this.studentRepo.findOne({ where: { id: studentId } });

    if (!student) {
      throw new NotFoundException("Student not found");
    }

    // 2. Удаляем User. 
    // Благодаря { onDelete: 'CASCADE' } в student.entity.ts, 
    // база данных сама удалит запись student, а затем и все tasks.
    await this.userRepo.delete(student.userId);

    return { success: true };
  }

  async resetPassword(userId: string, newPassword?: string) {
    const user = await this.userRepo.findOneBy({ id: userId });
    if (!user) throw new NotFoundException("User not found");

    const password = newPassword || Math.random().toString(36).slice(-8);
    user.passwordHash = hashPassword(password);
    await this.userRepo.save(user);
    return { generatedPassword: password };
  }

  // ... (методы createCountry, getUniversities и др. оставляем как есть) ...

  async createCountry(data: Partial<Country>) {
    const country = await this.countryRepo.save(data);
    const tasksToCreate = DEFAULT_COUNTRY_TASKS.map(t => this.taskTplRepo.create({
      ...t,
      countryId: country.id,
    }));
    await this.taskTplRepo.save(tasksToCreate);
    return country;
  }

  async findAllCountries() {
    return this.countryRepo.find({ order: { name: 'ASC' } });
  }

  async getUniversities() {
    return this.uniRepo.find({
      relations: ['country', 'programs'],
      order: { name: 'ASC' }
    });
  }

  async createUniversity(data: Partial<University>) {
    return this.uniRepo.save(data);
  }

  async getTaskTemplates() {
    return this.taskTplRepo.find({ order: { id: 'ASC' } });
  }

  async createTaskTemplate(data: Partial<TaskTemplate>) {
    return this.taskTplRepo.save(data);
  }

  async deleteTaskTemplate(id: number) {
    return this.taskTplRepo.delete(id);
  }

  async searchPrograms(query: { countryId?: string; universityId?: string; category?: string; search?: string }) {
    const qb = this.programRepo.createQueryBuilder('program')
      .leftJoinAndSelect('program.university', 'university')
      .leftJoinAndSelect('university.country', 'country');

    if (query.countryId) qb.andWhere('country.id = :cId', { cId: query.countryId });
    if (query.universityId) qb.andWhere('university.id = :uId', { uId: query.universityId });
    if (query.category) qb.andWhere('program.category = :cat', { cat: query.category });
    if (query.search) qb.andWhere('program.title ILIKE :search', { search: `%${query.search}%` });

    return qb.getMany();
  }

  async createProgram(data: Partial<Program>) {
    return this.programRepo.save(data);
  }

  async updateProgram(id: number, data: Partial<Program>) {
    await this.programRepo.update(id, data);
    return this.programRepo.findOneBy({ id });
  }

  async deleteProgram(id: number) {
    return this.programRepo.delete(id);
  }

  // --- НОВЫЙ МЕТОД ---
  async updateCountry(id: string, data: Partial<Country>) {
    await this.countryRepo.update(id, data);
    return this.countryRepo.findOneBy({ id });
  }
}
--- END FILE: apps/api/src/admin/admin.service.ts ---

--- BEGIN FILE: apps/api/src/app.module.ts ---
import { Module } from "@nestjs/common";
import { ConfigModule } from "@nestjs/config";
import { HttpModule } from "@nestjs/axios";
import { TypeOrmModule } from "@nestjs/typeorm";
import { CamundaModule } from "./camunda/camunda.module";
import { AuthModule } from "./auth/auth.module";
import { CountriesModule } from "./countries/countries.module";
import { TasksModule } from "./tasks/tasks.module";
import { AdminModule } from "./admin/admin.module";
import { FilesModule } from "./files/files.module";
import { StudentsModule } from "./students/students.module";
import { TelegramModule } from "./telegram/telegram.module";
import { DocumentsModule } from "./documents/documents.module";

// Entities
import { Company } from "./entities/company.entity";
import { User } from "./entities/user.entity";
import { Student } from "./entities/student.entity";
import { Country } from "./entities/country.entity";
import { Task } from "./entities/task.entity";
import { University } from "./entities/university.entity";
import { Program } from "./entities/program.entity";
import { TaskTemplate } from "./entities/task-template.entity";
import { Curator } from "./entities/curator.entity";
import { DocumentTemplate } from "./entities/document-template.entity";
import { StudentDocument } from "./entities/student-document.entity";

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
    }),
    HttpModule,
    TypeOrmModule.forRoot({
      type: 'postgres',
      url: process.env.DATABASE_URL,
      entities: [Company, User, Student, Country, Task, University, Program, TaskTemplate, Curator, DocumentTemplate, StudentDocument],
      synchronize: true, // Внимание: только для разработки. В проде используйте миграции.
      autoLoadEntities: true,
    }),
    CamundaModule,
    AuthModule,
    CountriesModule,
    TasksModule,
    AdminModule,
    FilesModule,
    StudentsModule,
    TelegramModule,
    DocumentsModule,
  ],
})
export class AppModule { }
--- END FILE: apps/api/src/app.module.ts ---

--- BEGIN FILE: apps/api/src/auth/auth.controller.ts ---
import { Body, Controller, Get, Post, Request, UseGuards } from "@nestjs/common";
import { AuthService } from "./auth.service";
import { RegisterDto } from "./dto/register.dto";
import { LoginDto } from "./dto/login.dto";
import { JwtAuthGuard } from "./jwt-auth.guard";

@Controller("auth")
export class AuthController {
  constructor(private readonly auth: AuthService) {}

  @Post("register")
  register(@Body() body: RegisterDto) {
    return this.auth.register(body);
  }

  @Post("login")
  login(@Body() body: LoginDto) {
    return this.auth.login(body);
  }

  @UseGuards(JwtAuthGuard)
  @Get("me")
  getProfile(@Request() req: any) {
    return this.auth.getProfile(req.user.userId);
  }
}
--- END FILE: apps/api/src/auth/auth.controller.ts ---

--- BEGIN FILE: apps/api/src/auth/auth.module.ts ---
import { Module } from "@nestjs/common";
import { JwtModule } from "@nestjs/jwt";
import { PassportModule } from "@nestjs/passport";
import { TypeOrmModule } from "@nestjs/typeorm";
import { AuthController } from "./auth.controller";
import { AuthService } from "./auth.service";
import { CamundaModule } from "../camunda/camunda.module";
import { JwtStrategy } from "./jwt.strategy";
import { TasksModule } from "../tasks/tasks.module";
import { User } from "../entities/user.entity";
import { Student } from "../entities/student.entity";
import { Company } from "../entities/company.entity";

@Module({
  imports: [
    CamundaModule,
    PassportModule,
    TasksModule,
    TypeOrmModule.forFeature([User, Student, Company]),
    JwtModule.register({
      secret: process.env.JWT_SECRET || "dev_secret_key",
      signOptions: { expiresIn: "7d" },
    }),
  ],
  controllers: [AuthController],
  providers: [AuthService, JwtStrategy],
})
export class AuthModule {}
--- END FILE: apps/api/src/auth/auth.module.ts ---

--- BEGIN FILE: apps/api/src/auth/auth.service.spec.ts ---
import { Test, TestingModule } from '@nestjs/testing';
import { AuthService } from './auth.service';
import { CamundaService } from '../camunda/camunda.service';
import { JwtService } from '@nestjs/jwt';
import { TasksService } from '../tasks/tasks.service';
import { getRepositoryToken } from '@nestjs/typeorm';
import { User } from '../entities/user.entity';
import { Student } from '../entities/student.entity';
import { Company } from '../entities/company.entity';
import { DataSource } from 'typeorm';
import { Role } from '../entities/enums';
import { UnauthorizedException, BadRequestException } from '@nestjs/common';

// Mocks
const mockRepo = {
  findOne: jest.fn(),
  create: jest.fn(),
  save: jest.fn(),
  update: jest.fn(),
};

const mockQueryRunner = {
  connect: jest.fn(),
  startTransaction: jest.fn(),
  commitTransaction: jest.fn(),
  rollbackTransaction: jest.fn(),
  release: jest.fn(),
  manager: {
    save: jest.fn(),
  },
};

const mockDataSource = {
  createQueryRunner: jest.fn().mockReturnValue(mockQueryRunner),
};

const mockCamunda = {
  startProcessByKey: jest.fn(),
};

const mockTasksService = {
  syncTasksForUser: jest.fn(),
};

const mockJwt = {
  sign: jest.fn(() => 'mock_token'),
};

describe('AuthService', () => {
  let service: AuthService;
  let userRepo: any;
  let studentRepo: any;
  let companyRepo: any;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AuthService,
        { provide: getRepositoryToken(User), useValue: { ...mockRepo } },
        { provide: getRepositoryToken(Student), useValue: { ...mockRepo } },
        { provide: getRepositoryToken(Company), useValue: { ...mockRepo } },
        { provide: DataSource, useValue: mockDataSource },
        { provide: CamundaService, useValue: mockCamunda },
        { provide: JwtService, useValue: mockJwt },
        { provide: TasksService, useValue: mockTasksService },
      ],
    }).compile();

    service = module.get<AuthService>(AuthService);
    userRepo = module.get(getRepositoryToken(User));
    studentRepo = module.get(getRepositoryToken(Student));
    companyRepo = module.get(getRepositoryToken(Company));
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('register', () => {
    it('should register a new student successfully', async () => {
      // Arrange
      const company = { id: 'comp-1' };
      companyRepo.findOne.mockResolvedValue(company);
      userRepo.findOne.mockResolvedValue(null); // User not exists

      // Mock Transaction
      const savedUser = { id: 'user-1', email: 'test@test.com', role: Role.STUDENT, companyId: 'comp-1' };
      mockQueryRunner.manager.save
        .mockResolvedValueOnce(savedUser) // Save User
        .mockResolvedValueOnce({ id: 'student-1' }); // Save Student

      mockCamunda.startProcessByKey.mockResolvedValue({ id: 'proc-1' });

      // Stub login
      jest.spyOn(service, 'login').mockResolvedValue({ accessToken: 'token', user: savedUser } as any);

      // Act
      const result = await service.register({
        email: 'test@test.com',
        password: '123',
        role: 'student',
      });

      // Assert
      expect(companyRepo.findOne).toHaveBeenCalled();
      expect(userRepo.findOne).toHaveBeenCalled();
      expect(mockDataSource.createQueryRunner).toHaveBeenCalled();
      expect(mockQueryRunner.startTransaction).toHaveBeenCalled();
      expect(mockQueryRunner.manager.save).toHaveBeenCalledTimes(2); // User + Student
      expect(mockCamunda.startProcessByKey).toHaveBeenCalled();
      expect(studentRepo.update).toHaveBeenCalledWith({ userId: 'user-1' }, { camundaProcessInstanceId: 'proc-1' });
      expect(mockTasksService.syncTasksForUser).toHaveBeenCalledWith('user-1');
      expect(service.login).toHaveBeenCalled();
    });

    it('should throw if user already exists', async () => {
      companyRepo.findOne.mockResolvedValue({ id: 'comp-1' });
      userRepo.findOne.mockResolvedValue({ id: 'existing' });

      await expect(
        service.register({ email: 'exist@test.com', password: '123' })
      ).rejects.toThrow(BadRequestException);
    });

    it('should rollback transaction on error', async () => {
      companyRepo.findOne.mockResolvedValue({ id: 'comp-1' });
      userRepo.findOne.mockResolvedValue(null);

      mockQueryRunner.manager.save.mockRejectedValue(new Error('DB Error'));

      await expect(
        service.register({ email: 'fail@test.com', password: '123' })
      ).rejects.toThrow('DB Error');

      expect(mockQueryRunner.rollbackTransaction).toHaveBeenCalled();
      expect(mockQueryRunner.release).toHaveBeenCalled();
    });
  });

  describe('login', () => {
    it('should return token for valid credentials', async () => {
      const user = {
        id: 'u-1',
        email: 'test@test.com',
        passwordHash: 'hashed_123', // Matches hashPassword('123') logic in service
        role: Role.STUDENT,
        companyId: 'c-1'
      };
      userRepo.findOne.mockResolvedValue(user);

      const result = await service.login({ email: 'test@test.com', password: '123' });
      expect(result.accessToken).toBe('mock_token');
    });

    it('should throw Unauthorized for invalid password', async () => {
      const user = {
        id: 'u-1',
        email: 'test@test.com',
        passwordHash: 'hashed_123',
        role: Role.STUDENT
      };
      userRepo.findOne.mockResolvedValue(user);

      await expect(
        service.login({ email: 'test@test.com', password: 'wrong' })
      ).rejects.toThrow(UnauthorizedException);
    });
  });
});
--- END FILE: apps/api/src/auth/auth.service.spec.ts ---

--- BEGIN FILE: apps/api/src/auth/auth.service.ts ---
import { Injectable, BadRequestException, UnauthorizedException } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository, DataSource } from "typeorm";
import { CamundaService } from "../camunda/camunda.service";
import { RegisterDto } from "./dto/register.dto";
import { LoginDto } from "./dto/login.dto";
import { JwtService } from "@nestjs/jwt";
import { TasksService } from "../tasks/tasks.service";
import { User } from "../entities/user.entity";
import { Student } from "../entities/student.entity";
import { Company } from "../entities/company.entity";
import { Role } from "../entities/enums";

const hashPassword = (pwd: string) => `hashed_${pwd}`;

@Injectable()
export class AuthService {
  constructor(
    @InjectRepository(User) private userRepo: Repository<User>,
    @InjectRepository(Student) private studentRepo: Repository<Student>,
    @InjectRepository(Company) private companyRepo: Repository<Company>,
    private readonly dataSource: DataSource,
    private readonly camunda: CamundaService,
    private readonly jwtService: JwtService,
    private readonly tasksService: TasksService
  ) {}

  async register(data: RegisterDto) {
    console.log("Registering user:", data.email, "Role requested:", data.role);

    const company = await this.companyRepo.findOne({ where: {} }); 
    if (!company) {
        throw new Error("System not initialized: No company found. Run seeds.");
    }

    const existing = await this.userRepo.findOne({
        where: { email: data.email, companyId: company.id }
    });

    if (existing) {
        throw new BadRequestException("User already exists");
    }

    const processKey = process.env.CAMUNDA_REG_PROCESS_KEY || "student_registration";
    let newUser: User;

    // Transaction for User + Student creation
    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
        const user = this.userRepo.create({
            companyId: company.id,
            email: data.email,
            passwordHash: hashPassword(data.password || "12345678"),
            role: (data.role?.toUpperCase() as Role) || Role.STUDENT,
        });
        newUser = await queryRunner.manager.save(user);

        if (newUser.role === Role.STUDENT) {
             const student = this.studentRepo.create({
                companyId: company.id,
                userId: newUser.id,
                fullName: data.fullName || "Student",
                bindingCode: `S-${Math.floor(1000 + Math.random() * 9000)}`,
                countryId: data.countryId
            });
            await queryRunner.manager.save(student);
        }

        await queryRunner.commitTransaction();
    } catch (err) {
        await queryRunner.rollbackTransaction();
        throw err;
    } finally {
        await queryRunner.release();
    }

    // Camunda
    const variables = {
      email: data.email,
      userId: newUser.id,
      companyId: company.id,
      role: data.role || "student",
      countryId: data.countryId || "",
    };

    let processId = null;
    try {
        const camundaProcess = await this.camunda.startProcessByKey(processKey, variables);
        processId = camundaProcess.id;
    } catch (e: any) {
        console.warn("⚠️ Camunda start failed, but user created:", e.message);
    }

    // Update process ID
    if (newUser.role === Role.STUDENT && processId) {
        await this.studentRepo.update({ userId: newUser.id }, { camundaProcessInstanceId: processId });
    }

    // --- ИСПРАВЛЕНИЕ ЗДЕСЬ ---
    if (newUser.role === Role.STUDENT) {
        // Используем новый метод syncTasksForUser вместо удаленного generateInitialTasks
        await this.tasksService.syncTasksForUser(newUser.id);
    }
    // -------------------------

    return this.login({ email: data.email, password: data.password || "12345678" });
  }

  async login(data: LoginDto) {
    const user = await this.userRepo.findOne({
        where: { email: data.email }
    });

    if (!user || user.passwordHash !== hashPassword(data.password)) {
        throw new UnauthorizedException("Invalid credentials");
    }

    const payload = { sub: user.id, email: user.email, role: user.role, companyId: user.companyId };
    return {
        accessToken: this.jwtService.sign(payload),
        user: {
            id: user.id,
            email: user.email,
            role: user.role
        }
    };
  }

  async getProfile(userId: string) {
      const user = await this.userRepo.findOne({
          where: { id: userId },
          relations: ['student', 'curator']
      });

      if (!user) throw new UnauthorizedException();

      return {
          id: user.id,
          email: user.email,
          name: user.student?.fullName || user.curator?.fullName || user.email,
          role: user.role.toLowerCase(),
          countryId: user.student?.countryId,
          curatorId: user.curator?.id 
      };
  }
}
--- END FILE: apps/api/src/auth/auth.service.ts ---

--- BEGIN FILE: apps/api/src/auth/dto/login.dto.ts ---
export class LoginDto {
  email!: string;
  password!: string;
}
--- END FILE: apps/api/src/auth/dto/login.dto.ts ---

--- BEGIN FILE: apps/api/src/auth/dto/register.dto.ts ---
export class RegisterDto {
  // обязательное поле, но инициализируем его уже на уровне Nest (body),
  // поэтому ставим "!" чтобы заткнуть strictPropertyInitialization
  email!: string;
  password?: string;
  fullName?: string;
  countryId?: string;
  role?: "student" | "curator" | "admin";
}
--- END FILE: apps/api/src/auth/dto/register.dto.ts ---

--- BEGIN FILE: apps/api/src/auth/jwt-auth.guard.ts ---
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}
--- END FILE: apps/api/src/auth/jwt-auth.guard.ts ---

--- BEGIN FILE: apps/api/src/auth/jwt.strategy.ts ---
import { ExtractJwt, Strategy } from 'passport-jwt';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable } from '@nestjs/common';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor() {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: process.env.JWT_SECRET || "dev_secret_key",
    });
  }

  async validate(payload: any) {
    // payload = { sub: userId, email: ..., role: ... }
    return { userId: payload.sub, email: payload.email, role: payload.role, companyId: payload.companyId };
  }
}
--- END FILE: apps/api/src/auth/jwt.strategy.ts ---

--- BEGIN FILE: apps/api/src/auth/roles.decorator.ts ---
import { SetMetadata } from '@nestjs/common';
import { Role } from '../entities/enums';

export const ROLES_KEY = 'roles';
export const Roles = (...roles: Role[]) => SetMetadata(ROLES_KEY, roles);
--- END FILE: apps/api/src/auth/roles.decorator.ts ---

--- BEGIN FILE: apps/api/src/auth/roles.guard.ts ---
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { ROLES_KEY } from './roles.decorator';
import { Role } from '../entities/enums';

@Injectable()
export class RolesGuard implements CanActivate {
    constructor(private reflector: Reflector) { }

    canActivate(context: ExecutionContext): boolean {
        const requiredRoles = this.reflector.getAllAndOverride<Role[]>(ROLES_KEY, [
            context.getHandler(),
            context.getClass(),
        ]);
        if (!requiredRoles) {
            return true;
        }
        const { user } = context.switchToHttp().getRequest();

        // Allow if user has one of the required roles
        // Note: Enum matching might need strict check depending on how user.role is stored (string vs enum)
        return requiredRoles.some((role) => user.role === role);
    }
}
--- END FILE: apps/api/src/auth/roles.guard.ts ---

--- BEGIN FILE: apps/api/src/camunda/camunda.controller.ts ---
import { Controller, Get, Post, Body, Query } from "@nestjs/common";
import { CamundaService } from "./camunda.service";

@Controller("camunda")
export class CamundaController {
  constructor(private readonly camunda: CamundaService) {}

  @Get("process-definitions")
  getDefs() {
    return this.camunda.getProcessDefinitions();
  }

  @Post("start")
  start(@Query("key") key: string, @Body() body: Record<string, any>) {
    if (!key) {
      throw new Error("Query param ?key=PROCESS_KEY is required");
    }
    return this.camunda.startProcessByKey(key, body || {});
  }
}
--- END FILE: apps/api/src/camunda/camunda.controller.ts ---

--- BEGIN FILE: apps/api/src/camunda/camunda.module.ts ---
 import { Module } from "@nestjs/common";
 import { HttpModule } from "@nestjs/axios";
 import { CamundaService } from "./camunda.service";
 import { CamundaController } from "./camunda.controller";

 @Module({
   imports: [HttpModule],
   providers: [CamundaService],
   controllers: [CamundaController],
   exports: [CamundaService],
 })
export class CamundaModule {}
--- END FILE: apps/api/src/camunda/camunda.module.ts ---

--- BEGIN FILE: apps/api/src/camunda/camunda.service.ts ---
import { Injectable, HttpException, HttpStatus } from "@nestjs/common";
import { HttpService } from "@nestjs/axios";
import { firstValueFrom } from "rxjs";

@Injectable()
export class CamundaService {
  private readonly baseUrl: string;

  constructor(private readonly http: HttpService) {
    // FIX: Если запускаем локально (без Docker), используем localhost
    // В docker-compose переменная CAMUNDA_URL перезапишет это на http://camunda:8080...
    this.baseUrl = process.env.CAMUNDA_URL || "http://localhost:8080/engine-rest";
  }

  async getProcessDefinitions() {
    const url = `${this.baseUrl}/process-definition`;
    const res = await firstValueFrom(this.http.get(url));
    return res.data;
  }

  async startProcessByKey(key: string, variables: Record<string, any> = {}) {
    const url = `${this.baseUrl}/process-definition/key/${key}/start`;
    const payload = {
      variables: Object.fromEntries(
        Object.entries(variables).map(([k, v]) => [
          k,
          { value: v, type: typeof v === "number" ? "Long" : "String" },
        ])
      ),
    };
    try {
      const res = await firstValueFrom(this.http.post(url, payload));
      return res.data;
    } catch (error: any) {
      // Логируем реальную причину ошибки в консоль сервера
      console.error("❌ ОШИБКА CAMUNDA:", error.message, error.code);

      if (error.response) {
        // Если Camunda ответила ошибкой (например, 404 Process definition not found)
        console.error("Детали ответа:", error.response.data);
        throw new HttpException(
          error.response.data.message || "Ошибка внутри Camunda",
          error.response.status
        );
      }

      // Если Camunda вообще недоступна (Connection refused)
      throw new HttpException(
        "Не удалось подключиться к Camunda. Убедитесь, что она запущена на порту 8080.",
        HttpStatus.BAD_GATEWAY
      );
    }
  }

  async sendMessage(messageName: string, businessKey?: string, variables: Record<string, any> = {}) {
    const url = `${this.baseUrl}/message`;
    const payload = {
      messageName,
      businessKey,
      processVariables: Object.fromEntries(
        Object.entries(variables).map(([k, v]) => [
          k,
          { value: v, type: typeof v === "number" ? "Long" : "String" },
        ])
      ),
    };

    try {
      const res = await firstValueFrom(this.http.post(url, payload));
      return res.data; // Usually strictly waits for result, returns void or array of results
    } catch (error: any) {
      console.error("❌ CAMUNDA MESSAGE ERROR:", error.message);
      // We don't necessarily want to throw and block the API if Camunda is optional or down,
      // but the user said "if connected".
      // Assuming "silent fail" or verify connection before sending is handled by caller or we just catch here.
      // For now, let's rethrow friendly error or null if we want to be soft.
      // Given the prompt "Отправь ... (если подключен)", strictly speaking we should probably just log and move on if it fails?
      // But typically we want to know if it failed. I'll return null on error to indicate failure without crashing.
      return null;
    }
  }
}
--- END FILE: apps/api/src/camunda/camunda.service.ts ---

--- BEGIN FILE: apps/api/src/countries/countries.controller.ts ---
import { Controller, Get } from "@nestjs/common";
import { CountriesService } from "./countries.service";

@Controller("countries")
export class CountriesController {
  constructor(private readonly service: CountriesService) {}

  @Get()
  getAll() {
    return this.service.findAll();
  }
}
--- END FILE: apps/api/src/countries/countries.controller.ts ---

--- BEGIN FILE: apps/api/src/countries/countries.module.ts ---
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";
import { CountriesService } from "./countries.service";
import { CountriesController } from "./countries.controller";
import { Country } from "../entities/country.entity";

@Module({
  imports: [TypeOrmModule.forFeature([Country])],
  providers: [CountriesService],
  controllers: [CountriesController],
})
export class CountriesModule {}
--- END FILE: apps/api/src/countries/countries.module.ts ---

--- BEGIN FILE: apps/api/src/countries/countries.service.ts ---
import { Injectable } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import { Country } from "../entities/country.entity";

@Injectable()
export class CountriesService {
  constructor(
    @InjectRepository(Country) private countryRepo: Repository<Country>
  ) {}

  async findAll() {
    return this.countryRepo.find({
        order: { name: 'ASC' }
    });
  }
}
--- END FILE: apps/api/src/countries/countries.service.ts ---

--- BEGIN FILE: apps/api/src/documents/documents.controller.ts ---

import { Controller, Get, Post, Patch, Body, Param, UploadedFile, UseInterceptors, UseGuards, Req, BadRequestException, ForbiddenException } from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { AuthGuard } from '@nestjs/passport';
import { DocumentsService } from './documents.service';
import { DocumentStatus } from '../entities/student-document.entity';

@Controller('documents')
@UseGuards(AuthGuard('jwt'))
export class DocumentsController {
    constructor(private readonly documentsService: DocumentsService) { }

    @Get('requirements')
    async getRequirements(@Req() req: any) {
        // req.user contains the user from JWT
        const userId = req.user.id;
        return await this.documentsService.getRequirements(userId);
    }

    @Post('upload')
    @UseInterceptors(FileInterceptor('file'))
    async uploadDocument(
        @Req() req: any,
        @UploadedFile() file: Express.Multer.File,
        @Body('template_id') templateIdStr: string,
    ) {
        if (!file) {
            throw new BadRequestException('File is required');
        }
        if (!templateIdStr) {
            throw new BadRequestException('Template ID is required');
        }

        const userId = req.user.id;
        const templateId = parseInt(templateIdStr, 10);

        // Call service
        return await this.documentsService.uploadDocument(userId, templateId, file);
    }

    @Get('pending')
    async getPendingDocuments(@Req() req: any) {
        const user = req.user;
        // Check for curator or admin (handling potential case sensitivity or strict enum usage)
        const role = user.role?.toUpperCase();
        if (role !== 'CURATOR' && role !== 'ADMIN' && user.role !== 'curator' && user.role !== 'admin') {
            throw new ForbiddenException('Access denied');
        }
        return await this.documentsService.getPendingDocuments();
    }


    @Patch(':documentId/review')
    async reviewDocument(
        @Param('documentId') documentId: string,
        @Body() body: { status: DocumentStatus; comment?: string },
    ) {
        if (!body.status) {
            throw new BadRequestException('Status is required');
        }
        return await this.documentsService.reviewDocument(documentId, body.status, body.comment);
    }
}
--- END FILE: apps/api/src/documents/documents.controller.ts ---

--- BEGIN FILE: apps/api/src/documents/documents.module.ts ---

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { DocumentsService } from './documents.service';
import { DocumentsController } from './documents.controller';
import { DocumentTemplate } from '../entities/document-template.entity';
import { StudentDocument } from '../entities/student-document.entity';
import { Student } from '../entities/student.entity';
import { FilesModule } from '../files/files.module';

import { CamundaModule } from '../camunda/camunda.module';

@Module({
    imports: [
        TypeOrmModule.forFeature([DocumentTemplate, StudentDocument, Student]),
        FilesModule,
        CamundaModule,
    ],
    controllers: [DocumentsController],
    providers: [DocumentsService],
})
export class DocumentsModule { }
--- END FILE: apps/api/src/documents/documents.module.ts ---

--- BEGIN FILE: apps/api/src/documents/documents.service.ts ---

import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { DocumentTemplate } from '../entities/document-template.entity';
import { StudentDocument, DocumentStatus } from '../entities/student-document.entity';
import { FilesService } from '../files/files.service';
import { Student } from '../entities/student.entity';
import { CamundaService } from '../camunda/camunda.service';
import { BadRequestException } from '@nestjs/common';

@Injectable()
export class DocumentsService {
    constructor(
        @InjectRepository(DocumentTemplate)
        private templateRepo: Repository<DocumentTemplate>,
        @InjectRepository(StudentDocument)
        private docRepo: Repository<StudentDocument>,
        @InjectRepository(Student)
        private studentRepo: Repository<Student>,
        private filesService: FilesService,
        private camundaService: CamundaService,
    ) { }

    async getRequirements(userId: string) {
        // 1. Get student by userId
        const student = await this.studentRepo.findOne({ where: { userId } });
        if (!student) {
            throw new NotFoundException('Student profile not found');
        }

        // 2. Get all templates
        const templates = await this.templateRepo.find({
            order: { step_order: 'ASC', id: 'ASC' },
        });

        // 3. Get existing documents for this student
        const existingDocs = await this.docRepo.find({
            where: { studentId: student.id },
        });

        // 4. Merge info
        const requirements = templates.map((tmpl) => {
            const doc = existingDocs.find((d) => d.templateId === tmpl.id);
            return {
                ...tmpl,
                studentDocument: doc || null,
                status: doc ? doc.status : DocumentStatus.MISSING,
            };
        });

        return requirements;
    }

    async uploadDocument(userId: string, templateId: number, file: Express.Multer.File) {
        // 1. Get student
        const student = await this.studentRepo.findOne({ where: { userId } });
        if (!student) {
            throw new NotFoundException('Student profile not found');
        }

        // 2. Validate template
        const template = await this.templateRepo.findOne({ where: { id: templateId } });
        if (!template) {
            throw new NotFoundException('Template not found');
        }

        // 3. Upload file
        const fileUrl = await this.filesService.uploadFile(file);

        // 4. Update or Create StudentDocument
        let doc = await this.docRepo.findOne({
            where: { studentId: student.id, templateId: templateId },
        });

        if (doc) {
            doc.minio_file_path = fileUrl;
            doc.status = DocumentStatus.PENDING;
            doc.manager_comment = undefined; // Clear previous rejections if any
        } else {
            doc = this.docRepo.create({
                studentId: student.id,
                templateId: templateId,
                minio_file_path: fileUrl,
                status: DocumentStatus.PENDING,
            });
        }

        return await this.docRepo.save(doc);
    }
    async reviewDocument(documentId: string, status: DocumentStatus, comment?: string) {
        // 1. Find document
        const doc = await this.docRepo.findOne({
            where: { id: documentId },
            relations: ['student', 'template'],
        });

        if (!doc) {
            throw new NotFoundException('Document not found');
        }

        // 2. Validate and Update
        if (status === DocumentStatus.REJECTED && !comment) {
            throw new BadRequestException('Comment is required when rejecting a document');
        }

        doc.status = status;
        if (comment) {
            doc.manager_comment = comment;
        }

        const savedDoc = await this.docRepo.save(doc);

        // 3. Send message to Camunda
        // Message name convention: "DocumentReviewed"
        // Correlate by studentId (Business Key)
        if (this.camundaService) {
            await this.camundaService.sendMessage(
                'DocumentReviewed',
                doc.studentId, // Business Key
                {
                    documentId: doc.id,
                    templateId: doc.templateId,
                    status: status,
                    comment: comment || '',
                }
            );
        }

        return savedDoc;
    }

    async getPendingDocuments() {
        return await this.docRepo.find({
            where: { status: DocumentStatus.PENDING },
            relations: ['student', 'student.user', 'template'],
            order: { created_at: 'ASC' },
        });
    }
}
--- END FILE: apps/api/src/documents/documents.service.ts ---

--- BEGIN FILE: apps/api/src/entities/company.entity.ts ---
import { Entity, PrimaryGeneratedColumn, Column, OneToMany } from 'typeorm';
import { User } from './user.entity';

@Entity('companies')
export class Company {
  @PrimaryGeneratedColumn('uuid')
  id!: string;

  @Column()
  name!: string;

  @Column('jsonb', { default: {} })
  config!: Record<string, any>;

  @Column({ default: false })
  isArchived!: boolean;

  @OneToMany(() => User, (user) => user.company)
  users!: User[];
}
--- END FILE: apps/api/src/entities/company.entity.ts ---

--- BEGIN FILE: apps/api/src/entities/country.entity.ts ---
import { Entity, PrimaryColumn, Column, OneToMany } from 'typeorm';
import { University } from './university.entity';

@Entity('countries')
export class Country {
  @PrimaryColumn()
  id!: string; // 'at', 'it'

  @Column()
  name!: string;

  @Column()
  flagIcon!: string;

  // --- НОВОЕ ПОЛЕ ---
  @Column('jsonb', { default: [] })
  requiredDocumentIds!: number[];

  @OneToMany(() => University, (uni) => uni.country)
  universities!: University[];
}
--- END FILE: apps/api/src/entities/country.entity.ts ---

--- BEGIN FILE: apps/api/src/entities/curator.entity.ts ---
import { Entity, PrimaryGeneratedColumn, Column, OneToOne, JoinColumn } from 'typeorm';
import { User } from './user.entity';

@Entity('curators')
export class Curator {
  @PrimaryGeneratedColumn('uuid')
  id!: string;

  @Column()
  companyId!: string;

  @Column()
  userId!: string;

  @OneToOne(() => User, (user) => user.curator, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'userId' })
  user!: User;

  @Column({ nullable: true })
  fullName?: string;

  @Column({ nullable: true })
  specialization?: string;

  @Column('text', { nullable: true })
  bio?: string;

  @Column({ nullable: true })
  avatarUrl?: string;
}
--- END FILE: apps/api/src/entities/curator.entity.ts ---

--- BEGIN FILE: apps/api/src/entities/document-template.entity.ts ---

import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn } from 'typeorm';

export enum DocumentType {
    PASSPORT = 'passport',
    EDUCATION = 'education',
    TRANSLATION = 'translation',
    OTHER = 'other',
}

@Entity('document_templates')
export class DocumentTemplate {
    @PrimaryGeneratedColumn('increment')
    id!: number;

    @Column()
    title!: string;

    @Column('int')
    step_order!: number;

    @Column({
        type: 'enum',
        enum: DocumentType,
        default: DocumentType.OTHER,
    })
    document_type!: DocumentType;

    @Column('text', { nullable: true })
    advice_text?: string;

    @Column('jsonb', { nullable: true, default: [] })
    rejection_reasons?: string[];

    @Column('jsonb', { nullable: true, default: [] })
    validation_rules?: string[]; // e.g., ["Must have apostille", "Date visible"]

    @CreateDateColumn()
    created_at!: Date;

    @UpdateDateColumn()
    updated_at!: Date;
}
--- END FILE: apps/api/src/entities/document-template.entity.ts ---

--- BEGIN FILE: apps/api/src/entities/enums.ts ---
export enum Role {
  STUDENT = 'STUDENT',
  CURATOR = 'CURATOR',
  ADMIN = 'ADMIN',
}

export enum TaskStatus {
  TODO = 'TODO',
  REVIEW = 'REVIEW',
  CHANGES_REQUESTED = 'CHANGES_REQUESTED',
  DONE = 'DONE',
}
--- END FILE: apps/api/src/entities/enums.ts ---

--- BEGIN FILE: apps/api/src/entities/program.entity.ts ---
import { Entity, PrimaryGeneratedColumn, Column, ManyToOne, JoinColumn } from 'typeorm';
import { University } from './university.entity';

@Entity('programs')
export class Program {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column()
  universityId!: string;

  @ManyToOne(() => University, (uni) => uni.programs)
  @JoinColumn({ name: 'universityId' })
  university!: University;

  @Column({ nullable: true })
  category?: string; 

  @Column()
  title!: string;

  @Column({ type: 'date', nullable: true })
  deadline?: string;

  @Column({ nullable: true })
  link?: string;

  @Column({ nullable: true })
  imageUrl?: string;

  // --- НОВОЕ: Список ID требуемых документов (JSONB) ---
  @Column('jsonb', { default: [] })
  requiredDocumentIds!: number[];
}
--- END FILE: apps/api/src/entities/program.entity.ts ---

--- BEGIN FILE: apps/api/src/entities/student-document.entity.ts ---

import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn, ManyToOne, JoinColumn } from 'typeorm';
import { Student } from './student.entity';
import { DocumentTemplate } from './document-template.entity';

export enum DocumentStatus {
    MISSING = 'MISSING',
    PENDING = 'PENDING',
    APPROVED = 'APPROVED',
    REJECTED = 'REJECTED',
}

@Entity('student_documents')
export class StudentDocument {
    @PrimaryGeneratedColumn('uuid')
    id!: string;

    @Column()
    studentId!: string;

    @ManyToOne(() => Student, { onDelete: 'CASCADE' })
    @JoinColumn({ name: 'studentId' })
    student!: Student;

    @Column()
    templateId!: number;

    @ManyToOne(() => DocumentTemplate, { onDelete: 'CASCADE' })
    @JoinColumn({ name: 'templateId' })
    template!: DocumentTemplate;

    @Column('text', { nullable: true })
    minio_file_path?: string;

    @Column({
        type: 'enum',
        enum: DocumentStatus,
        default: DocumentStatus.MISSING,
    })
    status!: DocumentStatus;

    @Column('text', { nullable: true })
    manager_comment?: string;

    @CreateDateColumn()
    created_at!: Date;

    @UpdateDateColumn()
    updated_at!: Date;
}
--- END FILE: apps/api/src/entities/student-document.entity.ts ---

--- BEGIN FILE: apps/api/src/entities/student.entity.ts ---
import { Entity, PrimaryGeneratedColumn, Column, OneToOne, JoinColumn, OneToMany, ManyToOne } from 'typeorm';
import { User } from './user.entity';
import { Task } from './task.entity';
import { Curator } from './curator.entity';

@Entity('students')
export class Student {
  @PrimaryGeneratedColumn('uuid')
  id!: string;

  @Column()
  companyId!: string;

  @Column()
  userId!: string;

  @OneToOne(() => User, (user) => user.student, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'userId' })
  user!: User;

  @Column({ nullable: true })
  curatorId?: string;

  @ManyToOne(() => Curator)
  @JoinColumn({ name: 'curatorId' })
  curator?: Curator;

  @Column()
  fullName!: string;

  @Column({ nullable: true })
  countryId?: string;

  // --- НОВОЕ: Выбранные программы ---
  @Column('jsonb', { default: [] })
  selectedProgramIds!: number[];

  @Column({ nullable: true })
  bindingCode?: string;

  @Column({ type: 'bigint', nullable: true }) // Telegram Chat ID может быть большим
  telegramGroupId?: string;

  @Column({ default: 0 })
  xpTotal!: number;

  @Column({ nullable: true })
  camundaProcessInstanceId?: string;

  @OneToMany(() => Task, (task) => task.student)
  tasks!: Task[];
}
--- END FILE: apps/api/src/entities/student.entity.ts ---

--- BEGIN FILE: apps/api/src/entities/task-template.entity.ts ---
import { Entity, PrimaryGeneratedColumn, Column } from 'typeorm';

@Entity('task_templates')
export class TaskTemplate {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column({ nullable: true })
  countryId?: string;

  @Column({ nullable: true })
  universityId?: string;

  // --- НОВОЕ: Привязка к конкретной программе ---
  @Column({ nullable: true })
  programId?: number; 

  @Column()
  stage!: string;

  @Column()
  title!: string;

  @Column('text')
  description!: string;

  @Column()
  xpReward!: number;

  @Column({ default: 'text' })
  submissionType!: string;
}
--- END FILE: apps/api/src/entities/task-template.entity.ts ---

--- BEGIN FILE: apps/api/src/entities/task.entity.ts ---
import { Entity, PrimaryGeneratedColumn, Column, ManyToOne, JoinColumn } from 'typeorm';
import { Student } from './student.entity';
import { TaskStatus } from './enums';

@Entity('tasks')
export class Task {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column()
  companyId!: string;

  @Column()
  studentId!: string;

  @ManyToOne(() => Student, (student) => student.tasks, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'studentId' })
  student!: Student;

  @Column()
  stage!: string;

  @Column()
  title!: string;

  @Column('text')
  description!: string;

  @Column()
  xpReward!: number;

  @Column({ type: 'enum', enum: TaskStatus, default: TaskStatus.TODO })
  status!: TaskStatus;

  @Column('jsonb', { nullable: true })
  submission?: any;
}
--- END FILE: apps/api/src/entities/task.entity.ts ---

--- BEGIN FILE: apps/api/src/entities/university.entity.ts ---
import { Entity, PrimaryGeneratedColumn, Column, ManyToOne, OneToMany, JoinColumn } from 'typeorm';
import { Country } from './country.entity';
import { Program } from './program.entity';

@Entity('universities')
export class University {
  @PrimaryGeneratedColumn('uuid')
  id!: string;

  @Column()
  countryId!: string;

  @ManyToOne(() => Country, (country) => country.universities)
  @JoinColumn({ name: 'countryId' })
  country!: Country;

  @Column()
  name!: string;

  @Column({ nullable: true })
  logoUrl?: string;

  @OneToMany(() => Program, (program) => program.university)
  programs!: Program[];
}
--- END FILE: apps/api/src/entities/university.entity.ts ---

--- BEGIN FILE: apps/api/src/entities/user.entity.ts ---
import { Entity, PrimaryGeneratedColumn, Column, ManyToOne, OneToOne, JoinColumn } from 'typeorm';
import { Company } from './company.entity';
import { Student } from './student.entity';
import { Curator } from './curator.entity';
import { Role } from './enums';

@Entity('users')
export class User {
  @PrimaryGeneratedColumn('uuid')
  id!: string;

  @Column()
  companyId!: string;

  @ManyToOne(() => Company, (company) => company.users)
  @JoinColumn({ name: 'companyId' })
  company!: Company;

  @Column({ unique: true })
  email!: string;

  @Column()
  passwordHash!: string;

  @Column({ type: 'enum', enum: Role, default: Role.STUDENT })
  role!: Role;

  @Column({ default: true })
  isActive!: boolean;

  @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })
  createdAt!: Date;

  @OneToOne(() => Student, (student) => student.user)
  student?: Student;

  @OneToOne(() => Curator, (curator) => curator.user)
  curator?: Curator;
}
--- END FILE: apps/api/src/entities/user.entity.ts ---

--- BEGIN FILE: apps/api/src/files/files.controller.ts ---
import { Controller, Post, UploadedFile, UseInterceptors, UseGuards } from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { FilesService } from './files.service';
import { JwtAuthGuard } from '../auth/jwt-auth.guard';

@Controller('files')
export class FilesController {
  constructor(private readonly filesService: FilesService) {}

  @Post('upload')
  @UseGuards(JwtAuthGuard)
  @UseInterceptors(FileInterceptor('file'))
  async uploadFile(@UploadedFile() file: any) {
    const url = await this.filesService.uploadFile(file);
    return { url };
  }
}
--- END FILE: apps/api/src/files/files.controller.ts ---

--- BEGIN FILE: apps/api/src/files/files.module.ts ---
import { Module } from '@nestjs/common';
import { FilesController } from './files.controller';
import { FilesService } from './files.service';

@Module({
  controllers: [FilesController],
  providers: [FilesService],
  exports: [FilesService], // Export FilesService
})
export class FilesModule { }
--- END FILE: apps/api/src/files/files.module.ts ---

--- BEGIN FILE: apps/api/src/files/files.service.ts ---
import { Injectable, OnModuleInit } from '@nestjs/common';
import * as Minio from 'minio';

@Injectable()
export class FilesService implements OnModuleInit {
  private minioClient: Minio.Client;
  private bucketName = process.env.MINIO_BUCKET || 'abbit-files';

  constructor() {
    this.minioClient = new Minio.Client({
      endPoint: process.env.MINIO_ENDPOINT || 'localhost',
      port: parseInt(process.env.MINIO_PORT || '9000'),
      useSSL: false,
      accessKey: process.env.MINIO_ACCESS_KEY || 'minioadmin',
      secretKey: process.env.MINIO_SECRET_KEY || 'minioadmin',
    });
  }

  async onModuleInit() {
    const exists = await this.minioClient.bucketExists(this.bucketName);
    if (!exists) {
      await this.minioClient.makeBucket(this.bucketName, 'us-east-1');
      // Делаем бакет публичным для чтения (упрощение для MVP)
      const policy = {
        Version: '2012-10-17',
        Statement: [
          {
            Effect: 'Allow',
            Principal: { AWS: ['*'] },
            Action: ['s3:GetObject'],
            Resource: [`arn:aws:s3:::${this.bucketName}/*`],
          },
        ],
      };
      await this.minioClient.setBucketPolicy(this.bucketName, JSON.stringify(policy));
    }
  }

  async uploadFile(file: any) {
    const fileName = `${Date.now()}-${file.originalname}`;
    await this.minioClient.putObject(
      this.bucketName,
      fileName,
      file.buffer,
      file.size,
      { 'Content-Type': file.mimetype }
    );

    // Возвращаем URL. В проде здесь должен быть публичный домен, сейчас для локальной разработки:
    const host = process.env.MINIO_EXTERNAL_HOST || 'localhost';
    return `http://${host}:9000/${this.bucketName}/${fileName}`;
  }

  async getFileStream(objectName: string) {
    return await this.minioClient.getObject(this.bucketName, objectName);
  }
}
--- END FILE: apps/api/src/files/files.service.ts ---

--- BEGIN FILE: apps/api/src/main.ts ---
import "reflect-metadata";
import { NestFactory } from "@nestjs/core";
import { AppModule } from "./app.module";

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // Enable aggressive CORS for development
  app.enableCors({
    origin: '*',
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    allowedHeaders: 'Content-Type, Accept, Authorization',
  });
  
  app.setGlobalPrefix("api");

  await app.listen(4000);
  console.log("API listening on http://localhost:4000/api");
}
bootstrap();
--- END FILE: apps/api/src/main.ts ---

--- BEGIN FILE: apps/api/src/seed.ts ---
import { DataSource } from 'typeorm';
import { Company } from './entities/company.entity';
import { Country } from './entities/country.entity';
import { User } from './entities/user.entity';
import { Student } from './entities/student.entity';
import { Task } from './entities/task.entity';
import { University } from './entities/university.entity';
import { Program } from './entities/program.entity';
import { TaskTemplate } from './entities/task-template.entity';
import { Curator } from './entities/curator.entity';
import { DocumentTemplate, DocumentType } from './entities/document-template.entity';
import { Role } from './entities/enums'; // Импортируем Role
import "dotenv/config";

const AppDataSource = new DataSource({
    type: 'postgres',
    url: process.env.DATABASE_URL,
    entities: [Company, Country, User, Student, Task, University, Program, TaskTemplate, Curator, DocumentTemplate],
    synchronize: true,
});

// Простая функция хеширования для сида (должна совпадать с auth.service logic)
const hashPassword = (pwd: string) => `hashed_${pwd}`;

async function seed() {
    await AppDataSource.initialize();
    console.log("Database connected for seeding...");

    // 1. Company
    const companyRepo = AppDataSource.getRepository(Company);
    let company = await companyRepo.findOne({ where: { name: "Abbit Agency" } });
    if (!company) {
        company = companyRepo.create({ name: "Abbit Agency", config: { theme: "default" } });
        await companyRepo.save(company);
        console.log("✅ Company created");
    }

    // 2. Countries
    const countryRepo = AppDataSource.getRepository(Country);
    const countriesData = [
        {
            id: 'at',
            name: 'Австрия',
            flagIcon: '🇦🇹',
            // Добавляем дефолтные ID документов (пример)
            requiredDocumentIds: [101, 102, 201, 202, 203]
        },
        { id: 'it', name: 'Италия', flagIcon: '🇮🇹', requiredDocumentIds: [] },
        { id: 'de', name: 'Германия', flagIcon: '🇩🇪', requiredDocumentIds: [] },
        { id: 'us', name: 'США', flagIcon: '🇺🇸', requiredDocumentIds: [] },
        { id: 'uk', name: 'Великобритания', flagIcon: '🇬🇧', requiredDocumentIds: [] },
        { id: 'fr', name: 'Франция', flagIcon: '🇫🇷', requiredDocumentIds: [] },
        { id: 'nl', name: 'Нидерланды', flagIcon: '🇳🇱', requiredDocumentIds: [] },
    ];

    for (const c of countriesData) {
        const existing = await countryRepo.findOneBy({ id: c.id });
        if (!existing) await countryRepo.save(c);
    }
    console.log("✅ Countries seeded");

    // 3. Universities & Programs
    const uniRepo = AppDataSource.getRepository(University);
    const progRepo = AppDataSource.getRepository(Program);

    // ... (код создания университетов оставляем как был) ...
    const universitiesData = [
        {
            countryId: 'at',
            name: 'University of Vienna',
            logoUrl: '🏛️',
            programs: [
                { category: 'Business', title: 'Business Administration (BSc)', deadline: '2026-05-01', link: 'https://studieren.univie.ac.at/en', imageUrl: 'https://images.unsplash.com/photo-1554224155-8d04cb21cd6c?w=800' },
                { category: 'IT', title: 'Computer Science (MSc)', deadline: '2026-04-15', link: 'https://informatik.univie.ac.at/en/', imageUrl: 'https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=800' }
            ]
        },
        // ... остальные университеты (для краткости пропущены, используйте свой массив)
        {
            countryId: 'it',
            name: 'University of Bologna',
            logoUrl: '🎓',
            programs: [
                { category: 'Science', title: 'Genomics (BSc)', deadline: '2026-04-10', link: 'https://www.unibo.it/en', imageUrl: 'https://images.unsplash.com/photo-1532094349884-543bc11b234d?w=800' },
            ]
        },
    ];

    // Сохраняем программы в массив, чтобы потом получить их ID
    const createdPrograms: Program[] = [];

    for (const uData of universitiesData) {
        let uni = await uniRepo.findOne({ where: { name: uData.name } });
        if (!uni) {
            uni = uniRepo.create({
                name: uData.name,
                countryId: uData.countryId,
                logoUrl: uData.logoUrl
            });
            await uniRepo.save(uni);
        }

        for (const pData of uData.programs) {
            let prog = await progRepo.findOne({ where: { title: pData.title, universityId: uni.id } });
            if (!prog) {
                prog = progRepo.create({
                    universityId: uni.id,
                    title: pData.title,
                    category: pData.category,
                    deadline: pData.deadline,
                    link: pData.link,
                    imageUrl: pData.imageUrl
                });
                await progRepo.save(prog);
            } else {
                prog.category = pData.category;
                await progRepo.save(prog);
            }
            createdPrograms.push(prog);
        }
    }
    console.log("✅ Universities & Programs seeded");


    // =========================================================
    // 4. Users & Students (ДОБАВЛЕНО)
    // =========================================================

    const userRepo = AppDataSource.getRepository(User);
    const studentRepo = AppDataSource.getRepository(Student);
    const curatorRepo = AppDataSource.getRepository(Curator);

    // 4.1 Создаем Куратора
    const curatorEmail = "curator@abbit.com";
    let curatorUser = await userRepo.findOne({ where: { email: curatorEmail } });

    if (!curatorUser) {
        curatorUser = userRepo.create({
            companyId: company.id,
            email: curatorEmail,
            passwordHash: hashPassword("admin123"),
            role: Role.CURATOR,
            isActive: true
        });
        await userRepo.save(curatorUser);

        const curator = curatorRepo.create({
            companyId: company.id,
            userId: curatorUser.id,
            fullName: "Анна Куратор",
            specialization: "Австрия и Германия",
            avatarUrl: ""
        });
        await curatorRepo.save(curator);
        console.log("✅ Curator created");
    }

    // Получаем сущность куратора для привязки
    const curator = await curatorRepo.findOne({ where: { userId: curatorUser.id } });

    // =========================================================
    // 5. Document Templates (ДОБАВЛЕНО)
    // =========================================================
    const docTemplateRepo = AppDataSource.getRepository(DocumentTemplate);
    const docTemplatesData = [
        {
            title: 'Скан Паспорта',
            step_order: 1,
            document_type: DocumentType.PASSPORT,
            advice_text: 'Главный документ для зачисления и визы. Загрузите цветной скан или фото главного разворота загранпаспорта. Убедитесь, что нет бликов и видны все углы.',
            validation_rules: ['Читаемость всех зон (MRZ, ФИО, номер)', 'Отсутствие бликов', 'Видимость всех 4-х углов', 'Срок действия > 18 месяцев'],
            rejection_reasons: ['Скан обрезан', 'Текст не читаем', 'Истек срок действия']
        },
        {
            title: 'Справка с места учебы',
            step_order: 2,
            document_type: DocumentType.EDUCATION,
            advice_text: 'Подтверждение того, что вы сейчас обучаетесь. Если справка не на английском, потребуется перевод.',
            validation_rules: ['Наличие "живой" печати', 'Наличие подписи', 'Свежая дата выдачи (< 3 мес)'],
            rejection_reasons: ['Справка устарела', 'Нет печати', 'Неверный формат']
        },
        {
            title: 'Апостиль диплома/аттестата',
            step_order: 2,
            document_type: DocumentType.EDUCATION,
            advice_text: 'Оригинал диплома должен иметь штамп Апостиль (выдается Министерством образования). Срок: до 15 рабочих дней.',
            validation_rules: ['Наличие штампа "Apostille"', 'Читаемость печати', 'Целостность скрепления'],
            rejection_reasons: ['Нет штампа на обороте', 'Штамп не читаем']
        },
        {
            title: 'Нотариальный перевод',
            step_order: 3,
            document_type: DocumentType.TRANSLATION,
            advice_text: 'Перевод документов на язык обучения (обычно английский). Загрузите скан перевода, сшитого с копией документа, заверенный нотариусом.',
            validation_rules: ['Подпись переводчика', 'Печать и подпись нотариуса', 'Сшито с копией'],
            rejection_reasons: ['Нет заверения нотариуса', 'Неполный документ']
        }
    ];

    for (const dt of docTemplatesData) {
        let t = await docTemplateRepo.findOne({ where: { title: dt.title } });
        if (!t) {
            t = docTemplateRepo.create(dt);
            await docTemplateRepo.save(t);
        }
    }
    console.log("✅ Document Templates seeded");

    // 4.2 Создаем Студента (продолжаем логику)
    const studentEmail = "student@example.com";
    let studentUser = await userRepo.findOne({ where: { email: studentEmail } });

    if (!studentUser) {
        studentUser = userRepo.create({
            companyId: company.id,
            email: studentEmail,
            passwordHash: hashPassword("12345678"),
            role: Role.STUDENT,
            isActive: true
        });
        await userRepo.save(studentUser);

        // Находим пару программ для присвоения студенту (например, первые две)
        const programsToAssign = createdPrograms.slice(0, 2).map(p => p.id);

        const student = studentRepo.create({
            companyId: company.id,
            userId: studentUser.id,
            fullName: "Иван Иванов",
            countryId: 'at', // Австрия
            bindingCode: "S-1000",
            curatorId: curator?.id, // Привязываем к куратору
            selectedProgramIds: programsToAssign,
            xpTotal: 150
        });
        await studentRepo.save(student);
        console.log(`✅ Student created with ${programsToAssign.length} programs`);
    }

    console.log("✅ Seeding complete!");
    process.exit(0);
}

seed().catch((err) => {
    console.error("❌ Seeding error", err);
    process.exit(1);
});
--- END FILE: apps/api/src/seed.ts ---

--- BEGIN FILE: apps/api/src/students/students.controller.ts ---
import { Body, Controller, Get, Param, Patch, UseGuards } from '@nestjs/common';
import { StudentsService } from './students.service';
import { JwtAuthGuard } from '../auth/jwt-auth.guard';

@Controller('students')
@UseGuards(JwtAuthGuard)
export class StudentsController {
  constructor(private readonly studentsService: StudentsService) {}

  @Get(':id')
  getOne(@Param('id') id: string) {
    return this.studentsService.getStudent(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() body: any) {
    return this.studentsService.updateProfile(id, body);
  }
}
--- END FILE: apps/api/src/students/students.controller.ts ---

--- BEGIN FILE: apps/api/src/students/students.module.ts ---
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { StudentsController } from './students.controller';
import { StudentsService } from './students.service';
import { Student } from '../entities/student.entity';
import { TasksModule } from '../tasks/tasks.module';

@Module({
  imports: [TypeOrmModule.forFeature([Student]), TasksModule],
  controllers: [StudentsController],
  providers: [StudentsService],
})
export class StudentsModule {}
--- END FILE: apps/api/src/students/students.module.ts ---

--- BEGIN FILE: apps/api/src/students/students.service.ts ---
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Student } from '../entities/student.entity';
import { TasksService } from '../tasks/tasks.service'; // Импортируем TasksService

@Injectable()
export class StudentsService {
  constructor(
    @InjectRepository(Student) private studentRepo: Repository<Student>,
    private tasksService: TasksService // Инжектим
  ) {}

  async getStudent(id: string) {
      return this.studentRepo.findOne({ where: { id }, relations: ['user']});
  }

  async updateProfile(id: string, data: Partial<Student>) {
    const student = await this.studentRepo.findOneBy({ id });
    if (!student) throw new NotFoundException('Student not found');

    let needsSync = false;

    if (data.fullName) student.fullName = data.fullName;
    
    // Если меняется страна или программы -> нужно обновить задачи
    if (data.countryId && data.countryId !== student.countryId) {
        student.countryId = data.countryId;
        needsSync = true;
    }
    
    if (data.selectedProgramIds) {
        student.selectedProgramIds = data.selectedProgramIds;
        needsSync = true;
    }
    
    const savedStudent = await this.studentRepo.save(student);

    if (needsSync) {
        // Запускаем синхронизацию задач
        await this.tasksService.syncStudentTasks(savedStudent.id);
    }

    return savedStudent;
  }
}
--- END FILE: apps/api/src/students/students.service.ts ---

--- BEGIN FILE: apps/api/src/tasks/dto/approve-task.dto.ts ---
export class RejectTaskDto {
  comment!: string;
}
--- END FILE: apps/api/src/tasks/dto/approve-task.dto.ts ---

--- BEGIN FILE: apps/api/src/tasks/dto/submit-task.dto.ts ---
export class SubmitTaskDto {
  submission: any;
}
--- END FILE: apps/api/src/tasks/dto/submit-task.dto.ts ---

--- BEGIN FILE: apps/api/src/tasks/tasks.controller.ts ---
import { Body, Controller, Get, Param, Post, Request, Res, UseGuards } from "@nestjs/common";
import { Response } from 'express';
import { TasksService } from "./tasks.service";
import { JwtAuthGuard } from "../auth/jwt-auth.guard";
import { SubmitTaskDto } from "./dto/submit-task.dto";
import { RejectTaskDto } from "./dto/approve-task.dto";

@Controller()
@UseGuards(JwtAuthGuard)
export class TasksController {
  constructor(private readonly tasksService: TasksService) { }

  @Get("student/tasks")
  getMyTasks(@Request() req: any) {
    return this.tasksService.findAllForUser(req.user.userId);
  }

  @Post("student/tasks/:id/submit")
  submitTask(@Param("id") id: string, @Body() body: SubmitTaskDto) {
    return this.tasksService.submitTask(id, body.submission);
  }

  @Get("curator/review")
  getReviewQueue(@Request() req: any) {
    return this.tasksService.getReviewQueue();
  }

  @Post("curator/tasks/:id/approve")
  approveTask(@Param("id") id: string) {
    return this.tasksService.approveTask(id);
  }

  @Post("curator/tasks/:id/request-changes")
  requestChanges(@Param("id") id: string, @Body() body: RejectTaskDto) {
    return this.tasksService.requestChanges(id, body.comment);
  }

  @Get("curator/students/:studentId/tasks")
  getStudentTasks(@Param("studentId") studentId: string) {
    return this.tasksService.findAllForStudentEntity(studentId);
  }

  // --- ИСПРАВЛЕНИЕ ЗДЕСЬ ---
  @Post("debug/generate")
  generate(@Request() req: any) {
    // Используем новый метод syncTasksForUser вместо удаленного generateInitialTasks
    return this.tasksService.syncTasksForUser(req.user.userId);
  }

  @Get("download-zip")
  async downloadZip(@Request() req: any, @Res() res: Response) {
    const archive = await this.tasksService.downloadZip(req.user.userId);
    res.setHeader('Content-Type', 'application/zip');
    res.setHeader('Content-Disposition', 'attachment; filename="documents.zip"');
    archive.pipe(res);
  }
  // -------------------------
}
--- END FILE: apps/api/src/tasks/tasks.controller.ts ---

--- BEGIN FILE: apps/api/src/tasks/tasks.module.ts ---
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";
import { TasksService } from "./tasks.service";
import { TasksController } from "./tasks.controller";
import { Task } from "../entities/task.entity";
import { Student } from "../entities/student.entity";
import { TaskTemplate } from "../entities/task-template.entity"; // <-- Добавили
import { FilesModule } from "../files/files.module";

@Module({
  imports: [
    TypeOrmModule.forFeature([Task, Student, TaskTemplate]),
    FilesModule // Import FilesModule
  ],
  providers: [TasksService],
  controllers: [TasksController],
  exports: [TasksService],
})
export class TasksModule { }
--- END FILE: apps/api/src/tasks/tasks.module.ts ---

--- BEGIN FILE: apps/api/src/tasks/tasks.service.ts ---
import { Injectable, NotFoundException } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import { Task } from "../entities/task.entity";
import { Student } from "../entities/student.entity";
import { TaskTemplate } from "../entities/task-template.entity";
import { TaskStatus } from "../entities/enums";
import archiver from 'archiver';
import { FilesService } from "../files/files.service";

@Injectable()
export class TasksService {
  constructor(
    @InjectRepository(Task) private taskRepo: Repository<Task>,
    @InjectRepository(Student) private studentRepo: Repository<Student>,
    @InjectRepository(TaskTemplate) private templateRepo: Repository<TaskTemplate>,
    private filesService: FilesService
  ) { }

  async findAllForUser(userId: string) {
    const student = await this.studentRepo.findOne({ where: { userId } });
    if (!student) throw new NotFoundException("Student profile not found");

    return this.taskRepo.find({
      where: { studentId: student.id },
      order: { id: 'ASC' }
    });
  }

  async submitTask(taskId: string, submission: any) {
    await this.taskRepo.update(taskId, {
      status: TaskStatus.REVIEW,
      submission: submission
    });
    return this.taskRepo.findOneBy({ id: Number(taskId) });
  }

  async getReviewQueue() {
    return this.taskRepo.find({
      where: { status: TaskStatus.REVIEW },
      relations: ['student']
    });
  }

  async approveTask(taskId: string) {
    const task = await this.taskRepo.findOneBy({ id: Number(taskId) });
    if (!task) throw new NotFoundException();

    task.status = TaskStatus.DONE;
    await this.taskRepo.save(task);

    const student = await this.studentRepo.findOneBy({ id: task.studentId });
    if (student) {
      student.xpTotal += task.xpReward;
      await this.studentRepo.save(student);
    }

    return task;
  }

  async requestChanges(taskId: string, comment: string) {
    const task = await this.taskRepo.findOneBy({ id: Number(taskId) });
    if (!task) throw new NotFoundException();

    task.status = TaskStatus.CHANGES_REQUESTED;
    await this.taskRepo.save(task);
    return task;
  }

  /**
   * Основной метод: Синхронизирует задачи студента (по ID студента)
   */
  async syncStudentTasks(studentId: string) {
    const student = await this.studentRepo.findOne({ where: { id: studentId } });
    if (!student) return;

    const programIds = student.selectedProgramIds || [];
    const countryId = student.countryId;

    // 1. Находим шаблоны для страны И для выбранных программ
    const applicableTemplates = await this.templateRepo.find({
      where: [
        // Задачи страны (общие)
        { countryId: countryId, programId: undefined }, // null
        // Задачи программ
        ...(programIds.length > 0 ? programIds.map(pid => ({ programId: pid, countryId: countryId })) : [])
      ]
    });

    if (applicableTemplates.length === 0) return;

    // 2. Проверяем, какие уже есть
    const existingTasks = await this.taskRepo.find({
      where: { studentId: student.id },
      select: ['title', 'stage']
    });

    const existingKeys = new Set(existingTasks.map(t => `${t.stage}-${t.title}`));

    // 3. Создаем новые
    const templatesToCreate = applicableTemplates.filter(tpl =>
      !existingKeys.has(`${tpl.stage}-${tpl.title}`)
    );

    if (templatesToCreate.length > 0) {
      const newTasks = templatesToCreate.map(t => this.taskRepo.create({
        companyId: student.companyId,
        studentId: student.id,
        stage: t.stage,
        title: t.title,
        description: t.description,
        xpReward: t.xpReward,
        status: TaskStatus.TODO
      }));

      await this.taskRepo.save(newTasks);
      console.log(`[SyncTasks] Created ${newTasks.length} new tasks for student ${student.fullName}`);
    }
  }

  /**
   * Хелпер: Синхронизация по User ID (для вызова из Auth и Контроллера)
   */
  async syncTasksForUser(userId: string) {
    const student = await this.studentRepo.findOne({ where: { userId } });
    if (student) {
      await this.syncStudentTasks(student.id);
    }
  }

  async findAllForStudentEntity(studentId: string) {
    return this.taskRepo.find({
      where: { studentId },
      order: { id: 'ASC' }
    });
  }

  async downloadZip(userId: string) {
    const student = await this.studentRepo.findOne({ where: { userId } });
    if (!student) throw new NotFoundException("Student not found");

    const tasks = await this.taskRepo.find({
      where: { studentId: student.id, status: TaskStatus.DONE }
    });

    const archive = archiver('zip', {
      zlib: { level: 9 }
    });

    // Обрабатываем файлы параллельно или последовательно. 
    // Для надежности архивации лучше последовательно добавлять в stream.
    for (const task of tasks) {
      if (!task.submission) continue;

      let fileUrl: string | null = null;
      if (typeof task.submission === 'string') {
        fileUrl = task.submission;
      } else if (typeof task.submission === 'object' && task.submission.url) {
        fileUrl = task.submission.url;
      }

      if (!fileUrl) continue;

      try {
        // fileUrl example: http://host:9000/bucket/filename
        const urlObj = new URL(fileUrl);
        const pathParts = urlObj.pathname.split('/');
        const objectName = pathParts[pathParts.length - 1];

        // Красивое имя файла
        let friendlyName = objectName;
        const match = objectName.match(/^\d+-(.+)$/);
        if (match) {
          friendlyName = match[1];
        }

        const safeTitle = task.title.replace(/[^a-zA-Z0-9а-яА-Я ]/g, '_');
        const entryName = `${safeTitle}_${friendlyName}`;

        const stream = await this.filesService.getFileStream(objectName);
        archive.append(stream, { name: entryName });
      } catch (e) {
        console.error(`Failed to archive task ${task.id} file`, e);
      }
    }

    archive.finalize();
    return archive;
  }
}
--- END FILE: apps/api/src/tasks/tasks.service.ts ---

--- BEGIN FILE: apps/api/src/telegram/telegram.module.ts ---
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { TelegramService } from './telegram.service';
import { Student } from '../entities/student.entity';

@Module({
    imports: [TypeOrmModule.forFeature([Student])],
    providers: [TelegramService],
    exports: [TelegramService],
})
export class TelegramModule { }
--- END FILE: apps/api/src/telegram/telegram.module.ts ---

--- BEGIN FILE: apps/api/src/telegram/telegram.service.ts ---
import { Injectable, OnModuleInit, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import TelegramBot from 'node-telegram-bot-api';
import { Student } from '../entities/student.entity';

@Injectable()
export class TelegramService implements OnModuleInit {
    private bot: TelegramBot | null = null;
    private readonly logger = new Logger(TelegramService.name);

    constructor(
        @InjectRepository(Student)
        private readonly studentRepository: Repository<Student>,
    ) { }

    onModuleInit() {
        const token = process.env.TELEGRAM_BOT_TOKEN;
        if (!token) {
            this.logger.warn('TELEGRAM_BOT_TOKEN not set. Telegram integration disabled.');
            return;
        }

        this.bot = new TelegramBot(token, { polling: true });
        this.logger.log('Telegram Bot initialized');

        this.initializeHandlers();
    }

    private initializeHandlers() {
        if (!this.bot) return;

        // Handle /link command
        this.bot.onText(/\/link (.+)/, async (msg, match) => {
            const chatId = msg.chat.id;
            const bindingCode = match ? match[1] : null;

            if (!bindingCode) {
                this.bot?.sendMessage(chatId, 'Пожалуйста, укажите код привязки: /link S-XXXX');
                return;
            }

            try {
                await this.linkGroup(chatId, bindingCode);
            } catch (error) {
                this.logger.error(`Error linking group: ${error}`);
                this.bot?.sendMessage(chatId, 'Произошла ошибка при привязке.');
            }
        });

        // Logging errors
        this.bot.on('polling_error', (error) => {
            this.logger.error(`Telegram Polling Error: ${error.message}`);
        });
    }

    private async linkGroup(chatId: number, bindingCode: string) {
        if (!this.bot) return;

        this.logger.log(`Attempting to link chat ${chatId} with code ${bindingCode}`);

        const student = await this.studentRepository.findOne({ where: { bindingCode } });

        if (!student) {
            this.bot.sendMessage(chatId, '❌ Студент с таким кодом не найден. Проверьте правильность ввода.');
            return;
        }

        if (student.telegramGroupId) {
            this.bot.sendMessage(chatId, '⚠️ Этот студент уже привязан к Telegram-группе.');
            return;
        }

        // Update student
        student.telegramGroupId = chatId.toString();
        await this.studentRepository.save(student);

        this.bot.sendMessage(chatId, `✅ Группа успешно подключена к профилю студента: ${student.fullName}. Ожидайте уведомлений.`);
        this.logger.log(`Linked student ${student.id} (S-${student.bindingCode}) to chat ${chatId}`);
    }

    // Method to send notification manually (for future use)
    public async sendNotification(studentId: string, message: string) {
        if (!this.bot) return;

        const student = await this.studentRepository.findOne({ where: { id: studentId } });
        if (!student || !student.telegramGroupId) {
            this.logger.warn(`Cannot send notification: Student ${studentId} has no telegram link.`);
            return;
        }

        try {
            await this.bot.sendMessage(student.telegramGroupId, message);
        } catch (e) {
            this.logger.error(`Failed to send telegram message: ${e}`);
        }
    }
}
--- END FILE: apps/api/src/telegram/telegram.service.ts ---

--- BEGIN FILE: apps/api/test/auth.e2e-spec.ts ---
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

describe('AuthController (e2e)', () => {
    let app: INestApplication;

    beforeEach(async () => {
        const moduleFixture: TestingModule = await Test.createTestingModule({
            imports: [AppModule],
        }).compile();

        app = moduleFixture.createNestApplication();
        await app.init();
    });

    it('/auth/login (POST) - failure', () => {
        return request(app.getHttpServer())
            .post('/auth/login')
            .send({ email: 'wrong@example.com', password: 'wrong' })
            .expect(401);
    });

    afterAll(async () => {
        await app.close();
    });
});
--- END FILE: apps/api/test/auth.e2e-spec.ts ---

--- BEGIN FILE: apps/api/test/jest-e2e.json ---
{
    "moduleFileExtensions": [
        "js",
        "json",
        "ts"
    ],
    "rootDir": ".",
    "testEnvironment": "node",
    "testRegex": ".e2e-spec.ts$",
    "transform": {
        "^.+\\.(t|j)s$": "ts-jest"
    }
}
--- END FILE: apps/api/test/jest-e2e.json ---

--- BEGIN FILE: apps/api/tsconfig.build.json ---
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "sourceMap": false,
    "declaration": true,
    "outDir": "./dist"
  },
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}
--- END FILE: apps/api/tsconfig.build.json ---

--- BEGIN FILE: apps/api/tsconfig.json ---
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "strict": true,
    "skipLibCheck": true,
    "esModuleInterop": true
  },
  "include": [
    "src/**/*"
  ]
}
--- END FILE: apps/api/tsconfig.json ---

--- BEGIN FILE: apps/web/.gitignore ---
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
--- END FILE: apps/web/.gitignore ---

--- BEGIN FILE: apps/web/app/admin/layout.tsx ---
"use client";
import { useAuth } from "@/shared/AuthContext";
import { useRouter } from "next/navigation";
import { useEffect } from "react";

export default function AdminLayout({ children }: { children: React.ReactNode }) {
    const { user, loading } = useAuth();
    const router = useRouter();

    useEffect(() => {
        if (!loading) {
            if (!user) {
                router.replace("/login");
            } else if (user.role !== "curator" && user.role !== "admin") {
                router.replace("/student/dashboard"); // or some other accessible page
            }
        }
    }, [user, loading, router]);

    if (loading) return <div className="p-10 flex justify-center">Loading...</div>;

    if (!user || (user.role !== "curator" && user.role !== "admin")) return null;

    return <div>{children}</div>;
}
--- END FILE: apps/web/app/admin/layout.tsx ---

--- BEGIN FILE: apps/web/app/admin/review/page.tsx ---
"use client";
import { useEffect, useState } from "react";
import { useAuth } from "@/shared/AuthContext";

const API_URL = process.env.NEXT_PUBLIC_API_URL ?? "http://localhost:4000/api";

type StudentDocument = {
    id: string;
    status: string;
    minio_file_path: string;
    created_at: string;
    template: { name: string };
    student: { fullName: string; email: string };
};

export default function DocumentReviewPage() {
    const { user } = useAuth();
    const [documents, setDocuments] = useState<StudentDocument[]>([]);
    const [loading, setLoading] = useState(true);
    const [selectedDoc, setSelectedDoc] = useState<StudentDocument | null>(null);
    const [rejectionComment, setRejectionComment] = useState("");
    const [processing, setProcessing] = useState(false);

    const fetchDocuments = async () => {
        setLoading(true);
        try {
            const token = localStorage.getItem("accessToken");
            const res = await fetch(`${API_URL}/documents/pending`, {
                headers: { Authorization: `Bearer ${token}` }
            });
            if (res.ok) {
                const data = await res.json();
                setDocuments(data);
            }
        } catch (e) {
            console.error(e);
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        fetchDocuments();
    }, []);

    const handleReview = async (status: "APPROVED" | "REJECTED") => {
        if (!selectedDoc) return;
        if (status === "REJECTED" && !rejectionComment.trim()) {
            alert("Please provide a comment for rejection");
            return;
        }

        setProcessing(true);
        try {
            const token = localStorage.getItem("accessToken");
            const res = await fetch(`${API_URL}/documents/${selectedDoc.id}/review`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${token}`
                },
                body: JSON.stringify({ status, comment: rejectionComment })
            });

            if (res.ok) {
                setSelectedDoc(null);
                setRejectionComment("");
                fetchDocuments();
            } else {
                alert("Error updating document status");
            }
        } catch (e) {
            console.error(e);
            alert("Error updating document status");
        } finally {
            setProcessing(false);
        }
    };

    const isImage = (path: string) => /\.(jpg|jpeg|png)$/i.test(path);

    return (
        <div className="p-6">
            <h1 className="text-2xl font-bold mb-6">Document Review</h1>

            {loading ? (
                <div>Loading...</div>
            ) : documents.length === 0 ? (
                <div className="text-gray-500">No pending documents found.</div>
            ) : (
                <div className="overflow-x-auto">
                    <table className="min-w-full bg-white dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-800 rounded-lg">
                        <thead>
                            <tr className="bg-zinc-100 dark:bg-zinc-800 text-left">
                                <th className="p-4 border-b dark:border-zinc-700">Student</th>
                                <th className="p-4 border-b dark:border-zinc-700">Document Type</th>
                                <th className="p-4 border-b dark:border-zinc-700">Date</th>
                                <th className="p-4 border-b dark:border-zinc-700">Action</th>
                            </tr>
                        </thead>
                        <tbody>
                            {documents.map((doc) => (
                                <tr key={doc.id} className="hover:bg-zinc-50 dark:hover:bg-zinc-800/50">
                                    <td className="p-4 border-b dark:border-zinc-700">
                                        <div>{doc.student?.fullName || 'Unknown'}</div>
                                        <div className="text-sm text-gray-500">{doc.student?.email}</div>
                                    </td>
                                    <td className="p-4 border-b dark:border-zinc-700">{doc.template?.name || 'Document'}</td>
                                    <td className="p-4 border-b dark:border-zinc-700">{new Date(doc.created_at).toLocaleDateString()}</td>
                                    <td className="p-4 border-b dark:border-zinc-700">
                                        <button
                                            onClick={() => setSelectedDoc(doc)}
                                            className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 text-sm"
                                        >
                                            Review
                                        </button>
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            )}

            {selectedDoc && (
                <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4">
                    <div className="bg-white dark:bg-zinc-900 rounded-lg shadow-xl w-full max-w-6xl h-[90vh] flex overflow-hidden">
                        {/* Left: Document Viewer */}
                        <div className="w-2/3 bg-zinc-100 dark:bg-zinc-800 p-4 flex items-center justify-center border-r dark:border-zinc-700">
                            {isImage(selectedDoc.minio_file_path) ? (
                                <img
                                    src={selectedDoc.minio_file_path}
                                    alt="Document"
                                    className="max-w-full max-h-full object-contain"
                                />
                            ) : (
                                <iframe
                                    src={selectedDoc.minio_file_path}
                                    className="w-full h-full border-none"
                                    title="Document Preview"
                                />
                            )}
                        </div>

                        {/* Right: Controls */}
                        <div className="w-1/3 p-6 flex flex-col">
                            <div className="flex justify-between items-start mb-6">
                                <div>
                                    <h2 className="text-xl font-bold">{selectedDoc.template?.name}</h2>
                                    <p className="text-gray-500">{selectedDoc.student?.fullName}</p>
                                </div>
                                <button
                                    onClick={() => { setSelectedDoc(null); setRejectionComment(""); }}
                                    className="text-gray-500 hover:text-gray-700"
                                >
                                    ✕
                                </button>
                            </div>

                            <div className="flex-1">
                                <h3 className="font-semibold mb-2">Rejection Reason</h3>
                                <textarea
                                    className="w-full h-32 p-3 border rounded dark:bg-zinc-800 dark:border-zinc-700"
                                    placeholder="Enter reason for rejection..."
                                    value={rejectionComment}
                                    onChange={(e) => setRejectionComment(e.target.value)}
                                />
                            </div>

                            <div className="mt-6 flex gap-3">
                                <button
                                    onClick={() => handleReview("APPROVED")}
                                    disabled={processing}
                                    className="flex-1 bg-green-600 text-white py-3 rounded hover:bg-green-700 disabled:opacity-50"
                                >
                                    Approve
                                </button>
                                <button
                                    onClick={() => handleReview("REJECTED")}
                                    disabled={processing}
                                    className="flex-1 bg-red-600 text-white py-3 rounded hover:bg-red-700 disabled:opacity-50"
                                >
                                    Reject
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            )}
        </div>
    );
}
--- END FILE: apps/web/app/admin/review/page.tsx ---

--- BEGIN FILE: apps/web/app/curator/admin/countries/CountryDetailPanel.tsx ---
"use client";
import { useState, useMemo } from "react";
import { useCountry } from "@/shared/CountryContext";
import QuestEditModal from "./QuestEditModal";

const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';

type Props = {
  countryId: string;
  onSaveTask: (task: any) => Promise<void>;
  onDeleteTask: (id: number) => Promise<void>;
  refreshData?: () => Promise<void>; // Добавляем проп для обновления данных
};

export default function CountryDetailPanel({ countryId, onSaveTask, onDeleteTask, refreshData }: Props) {
  const { countries, documents, quests } = useCountry();
  const [editingQuest, setEditingQuest] = useState<any | null>(null);
  const [isEditingDocs, setIsEditingDocs] = useState(false);
  const [tempRequiredDocs, setTempRequiredDocs] = useState<number[]>([]);

  const country = useMemo(() => countries.find(c => c.id === countryId), [countries, countryId]);

  // Задачи страны
  const countryTasks = useMemo(() => {
    return quests.filter((q: any) => q.countryId === countryId && !q.programId);
  }, [quests, countryId]);

  // Требования (документы)
  const requirements = useMemo(() => {
     if (!country) return [];
     const reqIds = country.required_document_ids || []; 
     return documents.filter(d => reqIds.includes(d.id));
  }, [documents, country]);

  // Инициализация tempRequiredDocs при входе в режим редактирования
  const enterEditMode = () => {
    if (country) {
      setTempRequiredDocs(country.required_document_ids || []);
    }
    setIsEditingDocs(true);
  };

  // Обработка сохранения документов страны
  const handleSaveCountryDocs = async () => {
      if (!country) return;
      const token = localStorage.getItem("accessToken");
      
      try {
          const res = await fetch(`${API_URL}/admin/countries/${country.id}`, {
              method: "PATCH",
              headers: { 
                  "Content-Type": "application/json",
                  Authorization: `Bearer ${token}` 
              },
              body: JSON.stringify({ requiredDocumentIds: tempRequiredDocs })
          });

          if (!res.ok) throw new Error("Ошибка сохранения");
          
          setIsEditingDocs(false);
          if (refreshData) await refreshData(); // Обновляем данные на клиенте
      } catch(e) {
          console.error(e);
          alert("Не удалось сохранить список документов");
      }
  };

  // Exit edit mode
  const exitEditMode = () => {
    setIsEditingDocs(false);
    setTempRequiredDocs([]);
  };

  // Toggle checkbox
  const toggleDoc = (docId: number) => {
    setTempRequiredDocs(prev => 
      prev.includes(docId) 
        ? prev.filter(id => id !== docId)
        : [...prev, docId]
    );
  };

  const handleCreateNew = () => {
    setEditingQuest({
        id: -Date.now(),
        title: "Новая задача",
        stage: "Документы",
        description: "",
        xpReward: 10,
    });
  };

  const handleRemoveQuest = (questId: number) => {
    if (confirm("Удалить задачу из шаблона страны?")) {
        onDeleteTask(questId);
    }
  };
  
  const handleSaveQuest = async (updatedQuest: any) => {
      await onSaveTask(updatedQuest);
      setEditingQuest(null);
  };

  if (!country) {
    return (
        <div className="h-full flex flex-col items-center justify-center text-zinc-400 p-8 text-center bg-zinc-900 border border-zinc-800 rounded-xl">
            <div className="text-4xl mb-3 opacity-50">🌍</div>
            <p>Выберите страну слева, чтобы настроить её трек.</p>
        </div>
    );
  }

  return (
    <div className="flex flex-col h-full bg-zinc-900 border border-zinc-800 rounded-2xl overflow-hidden relative shadow-xl">
      
      {/* --- HEADER (как в модалке) --- */}
      <div className="relative h-48 bg-zinc-800 shrink-0">
          {/* Фоновое изображение (можно сделать динамическим, пока ставим красивый плейсхолдер) */}
          <div className="w-full h-full bg-gradient-to-r from-blue-900 to-indigo-900 opacity-80" />
          <div className="absolute inset-0 bg-[url('https://images.unsplash.com/photo-1451187580459-43490279c0fa?q=80&w=2072&auto=format&fit=crop')] bg-cover bg-center opacity-20 mix-blend-overlay" />
          
          <div className="absolute inset-0 bg-gradient-to-t from-zinc-900 to-transparent" />
          
          <div className="absolute bottom-5 left-6 right-6">
              <div className="flex items-center gap-2 mb-2">
                  <span className="px-2 py-0.5 rounded-full bg-white/10 text-white text-xs backdrop-blur-md border border-white/10 uppercase tracking-wider font-bold">
                      Базовый трек
                  </span>
                  <span className="text-2xl">{country.flag_icon}</span>
              </div>
              <h2 className="text-3xl font-bold text-white leading-tight shadow-sm">{country.name}</h2>
          </div>
      </div>

      {/* --- CONTENT (как в модалке) --- */}
      <div className="flex-1 overflow-y-auto p-6 space-y-8 bg-zinc-900">
          
          {/* Info Row */}
          <div className="flex flex-wrap gap-6 text-sm pb-6 border-b border-zinc-800">
              <div className="flex flex-col">
                  <span className="text-zinc-500 text-xs uppercase tracking-wider font-bold mb-1">Статус</span>
                  <span className="font-semibold text-green-400">Активна</span>
              </div>
              <div className="flex flex-col">
                  <span className="text-zinc-500 text-xs uppercase tracking-wider font-bold mb-1">Студентов</span>
                  <span className="font-semibold text-zinc-200">12 (Demo)</span>
              </div>
              <div className="flex flex-col">
                  <span className="text-zinc-500 text-xs uppercase tracking-wider font-bold mb-1">Задач</span>
                  <span className="font-semibold text-zinc-200">{countryTasks.length}</span>
              </div>
          </div>

          {/* Requirements Section */}
          <div>
              <h3 className="text-lg font-bold mb-4 flex items-center gap-2 text-white">
                  <span className="text-blue-500">📄</span> Требования к поступлению
              </h3>
              {!isEditingDocs ? (
                <>
                  {requirements.length > 0 ? (
                      <div className="grid grid-cols-1 gap-2">
                          {requirements.map((doc: any) => (
                              <div key={doc.id} className="p-3 rounded-xl bg-zinc-800/50 border border-zinc-800 text-sm flex items-center gap-3">
                                  <span className="text-green-500 text-xs">●</span>
                                  <span className="text-zinc-300">{doc.title}</span>
                              </div>
                          ))}
                      </div>
                  ) : (
                      <p className="text-sm text-zinc-500 italic p-4 border border-dashed border-zinc-800 rounded-xl text-center">
                          Список документов не настроен.
                      </p>
                  )}
                  <button 
                    onClick={enterEditMode}
                    className="mt-3 text-xs text-blue-500 hover:text-blue-400 transition flex items-center gap-1 font-medium"
                  >
                      ✏️ Настроить список документов
                  </button>
                </>
              ) : (
                <div className="mt-4 pt-4 border-t border-zinc-700">
                  <div className="space-y-2 max-h-60 overflow-y-auto">
                    {documents.map((doc: any) => (
                      <label key={doc.id} className="flex items-center gap-2 p-2 rounded-lg hover:bg-zinc-800/50 cursor-pointer">
                        <input
                          type="checkbox"
                          checked={tempRequiredDocs.includes(doc.id)}
                          onChange={() => toggleDoc(doc.id)}
                          className="rounded"
                        />
                        <span className="text-sm text-zinc-300">{doc.title}</span>
                      </label>
                    ))}
                  </div>
                  <div className="flex gap-2 mt-4 pt-4 border-t border-zinc-700">
                    <button
                      onClick={handleSaveCountryDocs}
                      className="flex-1 px-3 py-2 bg-blue-600 hover:bg-blue-500 text-white rounded-lg text-sm font-medium transition"
                    >
                      Сохранить
                    </button>
                    <button
                      onClick={exitEditMode}
                      className="px-3 py-2 bg-zinc-700 hover:bg-zinc-600 text-zinc-300 rounded-lg text-sm transition"
                    >
                      Отмена
                    </button>
                  </div>
                </div>
              )}
          </div>

          {/* Tasks Section (Путь поступления) */}
          <div>
               <div className="flex justify-between items-end mb-4">
                   <h3 className="text-lg font-bold flex items-center gap-2 text-white">
                      <span className="text-yellow-500">🚩</span> Путь поступления
                  </h3>
                  <button 
                    onClick={handleCreateNew}
                    className="text-xs bg-blue-600 hover:bg-blue-500 text-white px-3 py-1.5 rounded-lg transition shadow-sm font-medium"
                  >
                    + Задача
                  </button>
               </div>
              
              <div className="space-y-2">
                   {countryTasks.length > 0 ? countryTasks.map((task: any) => (
                       <div key={task.id} className="group flex items-center justify-between p-3 rounded-xl border border-zinc-800 bg-zinc-800/30 hover:bg-zinc-800 transition relative overflow-hidden">
                           <div className="relative z-10">
                               <div className="flex items-center gap-2 mb-0.5">
                                    <div className="text-[10px] text-zinc-500 uppercase font-bold tracking-wide">{task.stage}</div>
                                    {task.isCritical && <span className="text-[9px] bg-red-500/20 text-red-500 px-1 rounded border border-red-500/30">Критично</span>}
                               </div>
                               <div className="font-medium text-sm text-zinc-200">{task.title}</div>
                           </div>
                           
                           <div className="flex items-center gap-3 relative z-10">
                               {/* Submission Type Icon */}
                               <div className="text-zinc-500 text-xs" title={`Тип сдачи: ${task.submissionType}`}>
                                   {task.submissionType === 'file' ? '📄' : task.submissionType === 'link' ? '🔗' : task.submissionType === 'text' ? '📝' : '☑️'}
                               </div>
                               <div className="text-xs font-bold text-yellow-600 bg-yellow-500/10 border border-yellow-500/20 px-2 py-1 rounded">
                                   +{task.xpReward} XP
                               </div>
                               
                               {/* Hover Actions */}
                               <div className="absolute right-0 top-1/2 -translate-y-1/2 flex gap-1 bg-zinc-800 pl-2 opacity-0 group-hover:opacity-100 transition-opacity">
                                    <button 
                                       onClick={() => setEditingQuest(task)} 
                                       className="p-1.5 hover:bg-zinc-700 rounded text-blue-400"
                                       title="Редактировать"
                                   >
                                       ✏️
                                   </button>
                                   <button 
                                       onClick={() => handleRemoveQuest(task.id)} 
                                       className="p-1.5 hover:bg-zinc-700 rounded text-red-400"
                                       title="Удалить"
                                   >
                                       🗑️
                                   </button>
                               </div>
                           </div>
                       </div>
                   )) : (
                       <div className="text-center py-8 text-zinc-500 text-sm bg-zinc-800/30 rounded-xl border border-dashed border-zinc-800">
                           Список задач пуст. Добавьте первую задачу.
                       </div>
                   )}
              </div>

          </div>
      </div>

      {/* Footer Actions */}
      <div className="p-4 border-t border-zinc-800 bg-zinc-900/90 backdrop-blur flex justify-between items-center text-xs text-zinc-500">
          <span>ID: {country.id}</span>
          <div className="flex gap-2">
            <button className="px-3 py-1.5 rounded-lg bg-zinc-800 hover:bg-zinc-700 text-zinc-300 transition">
                Настройки страны
            </button>
          </div>
      </div>

      {/* Edit Modal */}
      {editingQuest && (
        <QuestEditModal
          quest={editingQuest}
          onSave={handleSaveQuest}
          onClose={() => setEditingQuest(null)}
        />
      )}
    </div>
  );
}
--- END FILE: apps/web/app/curator/admin/countries/CountryDetailPanel.tsx ---

--- BEGIN FILE: apps/web/app/curator/admin/countries/ProgramDetailModal.tsx ---
"use client";
import { useState, useMemo } from "react";
import { useCountry } from "../../../../shared/CountryContext";

type Props = {
  program: any;
  onClose: () => void;
  onEdit: () => void;
};

export default function ProgramDetailModal({ program, onClose, onEdit }: Props) {
  const { documents, quests } = useCountry();

  // Имитация получения связанных задач (в реале это связь через БД)
  // Берем задачи страны + специфичные задачи программы (если бы они были)
  const relatedTasks = useMemo(() => {
    return quests.filter(q => 
        // Либо задачи конкретно этой страны
        (program.university?.countryId && q.countryId === program.university.countryId) ||
        // Либо задачи конкретно этого университета (если есть)
        (q.universityId === program.universityId)
    );
  }, [quests, program]);

  // Требования (документы)
  const requirements = useMemo(() => {
     // Берем айдишники из программы
     const reqIds = program.required_document_ids || []; 
     // Для демо добавим пару дефолтных, если список пуст
     const idsToShow = reqIds.length > 0 ? reqIds : [101, 201, 502]; 
     return documents.filter(d => idsToShow.includes(d.id));
  }, [documents, program]);

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/70 backdrop-blur-sm" onClick={onClose}>
      <div 
        className="w-full max-w-2xl bg-white dark:bg-zinc-900 rounded-2xl shadow-2xl overflow-hidden flex flex-col max-h-[90vh]" 
        onClick={e => e.stopPropagation()}
      >
        {/* Красивый Header с фоном */}
        <div className="relative h-48 bg-zinc-800 shrink-0">
            {program.imageUrl ? (
                <img src={program.imageUrl} alt={program.title} className="w-full h-full object-cover opacity-60" />
            ) : (
                <div className="w-full h-full bg-gradient-to-r from-blue-600 to-purple-600 opacity-80" />
            )}
            
            <div className="absolute inset-0 bg-gradient-to-t from-zinc-900 to-transparent" />
            
            <div className="absolute bottom-4 left-6 right-6">
                <div className="flex items-center gap-2 mb-1">
                    <span className="px-2 py-0.5 rounded-full bg-white/20 text-white text-xs backdrop-blur-md border border-white/10">
                        {program.category || "General"}
                    </span>
                    {program.university && (
                         <span className="px-2 py-0.5 rounded-full bg-black/40 text-white text-xs backdrop-blur-md border border-white/10 flex items-center gap-1">
                             <span>{program.university.country?.flagIcon}</span>
                             {program.university.name}
                         </span>
                    )}
                </div>
                <h2 className="text-2xl font-bold text-white leading-tight shadow-sm">{program.title}</h2>
            </div>

            <button 
                onClick={onClose}
                className="absolute top-4 right-4 w-8 h-8 rounded-full bg-black/20 hover:bg-black/40 text-white flex items-center justify-center transition backdrop-blur-sm"
            >
                ✕
            </button>
        </div>

        {/* Контент с прокруткой */}
        <div className="flex-1 overflow-y-auto p-6 space-y-6">
            
            {/* Основная инфо */}
            <div className="flex flex-wrap gap-4 text-sm text-zinc-600 dark:text-zinc-400 border-b border-zinc-100 dark:border-zinc-800 pb-4">
                <div className="flex items-center gap-2">
                    <span>📅</span>
                    <span>Дедлайн: <b className="text-zinc-900 dark:text-zinc-100">{program.deadline || "Не указан"}</b></span>
                </div>
                {program.link && (
                    <a href={program.link} target="_blank" className="flex items-center gap-2 text-blue-500 hover:underline">
                        <span>🔗</span> Официальный сайт
                    </a>
                )}
            </div>

            {/* Требования */}
            <div>
                <h3 className="text-lg font-semibold mb-3 flex items-center gap-2">
                    <span className="text-blue-500">📄</span> Требования к поступлению
                </h3>
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-2">
                    {requirements.map(doc => (
                        <div key={doc.id} className="p-2 rounded bg-zinc-50 dark:bg-zinc-800/50 border border-zinc-100 dark:border-zinc-800 text-sm flex items-center gap-2">
                            <span className="text-green-500 text-xs">●</span>
                            {doc.title}
                        </div>
                    ))}
                    {requirements.length === 0 && <span className="text-zinc-500 italic text-sm">Требования не указаны</span>}
                </div>
            </div>

            {/* Путь абитуриента (Задачи) */}
            <div>
                 <h3 className="text-lg font-semibold mb-3 flex items-center gap-2">
                    <span className="text-yellow-500">🚩</span> Путь поступления
                </h3>
                <div className="space-y-2">
                    {relatedTasks.length > 0 ? relatedTasks.map(task => (
                        <div key={task.id} className="flex items-center justify-between p-3 rounded-xl border border-zinc-100 dark:border-zinc-800 bg-white dark:bg-zinc-800/20">
                            <div>
                                <div className="text-xs text-zinc-500 uppercase font-bold tracking-wide mb-0.5">{task.stage}</div>
                                <div className="font-medium text-sm">{task.title}</div>
                            </div>
                            <div className="text-xs font-bold text-yellow-600 bg-yellow-100 dark:bg-yellow-900/30 px-2 py-1 rounded">
                                +{task.xpReward} XP
                            </div>
                        </div>
                    )) : (
                        <div className="text-center py-4 text-zinc-500 text-sm bg-zinc-50 dark:bg-zinc-800/30 rounded-xl">
                            Стандартные задачи страны будут применены автоматически.
                        </div>
                    )}
                </div>
            </div>
        </div>

        {/* Футер действий */}
        <div className="p-4 border-t border-zinc-100 dark:border-zinc-800 bg-zinc-50 dark:bg-zinc-900/50 flex justify-end gap-3 shrink-0">
            <button onClick={onEdit} className="btn bg-zinc-200 dark:bg-zinc-800 text-sm">
                Редактировать
            </button>
            <button onClick={onClose} className="btn btn-primary text-sm">
                Закрыть
            </button>
        </div>
      </div>
    </div>
  );
}
--- END FILE: apps/web/app/curator/admin/countries/ProgramDetailModal.tsx ---

--- BEGIN FILE: apps/web/app/curator/admin/countries/ProgramDetailPanel.tsx ---
"use client";
import { useMemo } from "react";
import { useCountry, Program } from "../../../../shared/CountryContext";

type Props = {
  program: Program;
  onClose: () => void; // Вернуться к стране
  onEdit: () => void;
};

export default function ProgramDetailPanel({ program, onClose, onEdit }: Props) {
  const { documents, quests, universities, countries } = useCountry();

  const university = useMemo(() => 
    universities.find(u => u.id === program.university_id), 
  [universities, program]);

  const country = useMemo(() => 
    countries.find(c => c.id === university?.countryId), 
  [countries, university]);

  // Получаем связанные задачи (логика как в модалке)
  const relatedTasks = useMemo(() => {
    return quests.filter((q: any) => 
        (university?.countryId && q.countryId === university?.countryId) ||
        (q.universityId === program.university_id) ||
        (q.programId === program.id)
    );
  }, [quests, program, university]);

  // Требования (документы)
  const requirements = useMemo(() => {
     const reqIds = program.required_document_ids || []; 
     return documents.filter((d: any) => reqIds.includes(d.id));
  }, [documents, program]);

  return (
    <div className="flex flex-col h-full bg-zinc-900 border border-zinc-800 rounded-2xl overflow-hidden relative shadow-xl">
      
      {/* --- HEADER --- */}
      <div className="relative h-48 bg-zinc-800 shrink-0">
          {program.image_url ? (
              <img src={program.image_url} alt={program.title} className="w-full h-full object-cover opacity-60" />
          ) : (
              <div className="w-full h-full bg-gradient-to-r from-blue-600 to-purple-600 opacity-80" />
          )}
          
          <div className="absolute inset-0 bg-gradient-to-t from-zinc-900 to-transparent" />
          
          {/* Кнопка "Назад" / "Закрыть" */}
          <button 
              onClick={onClose}
              className="absolute top-4 right-4 w-8 h-8 rounded-full bg-black/40 hover:bg-black/60 text-white flex items-center justify-center transition backdrop-blur-md z-20 border border-white/10"
              title="Вернуться к стране"
          >
              ✕
          </button>

          <div className="absolute bottom-5 left-6 right-6">
              <div className="flex flex-wrap items-center gap-2 mb-2">
                  <span className="px-2 py-0.5 rounded-full bg-white/20 text-white text-xs backdrop-blur-md border border-white/10">
                      {program.category || "General"}
                  </span>
                  {university && country && (
                       <span className="px-2 py-0.5 rounded-full bg-black/40 text-white text-xs backdrop-blur-md border border-white/10 flex items-center gap-1">
                           <span>{country.flag_icon}</span>
                           <span className="truncate max-w-[150px]">{university.name}</span>
                       </span>
                  )}
              </div>
              <h2 className="text-2xl font-bold text-white leading-tight shadow-sm">{program.title}</h2>
          </div>
      </div>

      {/* --- CONTENT --- */}
      <div className="flex-1 overflow-y-auto p-6 space-y-8 bg-zinc-900 custom-scrollbar">
          
          {/* Основная инфо */}
          <div className="flex flex-col gap-3 text-sm text-zinc-400 border-b border-zinc-800 pb-6">
              <div className="flex items-center justify-between">
                  <span className="text-zinc-500">Дедлайн подачи:</span>
                  <b className="text-zinc-200">{program.deadline || "Не указан"}</b>
              </div>
              {program.link && (
                  <div className="flex items-center justify-between">
                      <span className="text-zinc-500">Источник:</span>
                      <a href={program.link} target="_blank" className="flex items-center gap-2 text-blue-500 hover:underline">
                          Официальный сайт ↗
                      </a>
                  </div>
              )}
          </div>

          {/* Требования */}
          <div>
              <h3 className="text-lg font-bold mb-4 flex items-center gap-2 text-white">
                  <span className="text-blue-500">📄</span> Требования к поступлению
              </h3>
              <div className="space-y-2">
                  {requirements.length > 0 ? requirements.map((doc: any) => (
                      <div key={doc.id} className="p-3 rounded-xl bg-zinc-800/50 border border-zinc-800 text-sm flex items-start gap-3">
                          <span className="text-green-500 text-xs mt-1">●</span>
                          <div>
                              <div className="text-zinc-300 font-medium">{doc.title}</div>
                              <div className="text-zinc-500 text-xs">{doc.category}</div>
                          </div>
                      </div>
                  )) : (
                      <p className="text-sm text-zinc-500 italic p-4 border border-dashed border-zinc-800 rounded-xl text-center">
                          Требования не указаны
                      </p>
                  )}
              </div>
          </div>

          {/* Путь абитуриента (Задачи) */}
          <div>
               <div className="flex justify-between items-center mb-4">
                   <h3 className="text-lg font-bold flex items-center gap-2 text-white">
                      <span className="text-yellow-500">🚩</span> Путь поступления
                  </h3>
               </div>
               
              <div className="space-y-2">
                  {relatedTasks.length > 0 ? relatedTasks.map((task: any) => (
                      <div key={task.id} className="flex items-center justify-between p-3 rounded-xl border border-zinc-800 bg-zinc-800/30">
                          <div className="overflow-hidden">
                              <div className="text-[10px] text-zinc-500 uppercase font-bold tracking-wide mb-0.5">{task.stage}</div>
                              <div className="font-medium text-sm text-zinc-200 truncate pr-2">{task.title}</div>
                          </div>
                          <div className="flex items-center gap-2">
                            {task.isCritical && (
                                <span className="text-[10px] bg-red-500/10 text-red-500 border border-red-500/20 px-1.5 py-0.5 rounded" title="Критическая задача">!</span>
                            )}
                            <div className="text-xs font-bold text-yellow-600 bg-yellow-500/10 border border-yellow-500/20 px-2 py-1 rounded shrink-0">
                                +{task.xpReward} XP
                            </div>
                          </div>
                      </div>
                  )) : (
                      <div className="text-center py-6 text-zinc-500 text-sm bg-zinc-800/30 rounded-xl border border-dashed border-zinc-800">
                          Будут применены стандартные задачи страны.
                      </div>
                  )}
              </div>
          </div>
      </div>

      {/* Footer Actions */}
      <div className="p-4 border-t border-zinc-800 bg-zinc-900/90 backdrop-blur flex justify-between items-center gap-3">
          <button 
            onClick={onClose} 
            className="px-4 py-2 rounded-lg bg-zinc-800 hover:bg-zinc-700 text-zinc-400 hover:text-zinc-200 transition text-sm"
          >
              Закрыть
          </button>
          <button 
            onClick={onEdit} 
            className="flex-1 px-4 py-2 rounded-lg bg-blue-600 hover:bg-blue-500 text-white transition text-sm font-medium"
          >
              Редактировать программу
          </button>
      </div>
    </div>
  );
}
--- END FILE: apps/web/app/curator/admin/countries/ProgramDetailPanel.tsx ---

--- BEGIN FILE: apps/web/app/curator/admin/countries/ProgramEditModal.tsx ---
"use client";
import { useState, useEffect, useMemo } from "react";
import { useCountry } from "@/shared/CountryContext";
import QuestEditor from "./QuestEditor";

const API_URL = process.env.NEXT_PUBLIC_API_URL ?? "http://localhost:4000/api";

type Props = {
  program?: any; // Если null - создание, иначе редактирование
  universityId: string;
  onSave: (data: any) => Promise<void>;
  onClose: () => void;
};

const CATEGORIES = ["IT", "Business", "Engineering", "Arts/Design", "Law", "Medicine", "Science", "Humanities"];

export default function ProgramEditModal({ program, universityId, onSave, onClose }: Props) {
  const { documents, quests, refreshData } = useCountry();
  const [activeTab, setActiveTab] = useState<'info' | 'docs' | 'tasks'>('info');
  const [loading, setLoading] = useState(false);

  // Form Data
  const [formData, setFormData] = useState({
    title: "",
    category: "IT",
    deadline: "",
    link: "",
    imageUrl: "",
    universityId: universityId,
    requiredDocumentIds: [] as number[]
  });

  useEffect(() => {
    if (program) {
      setFormData({
        title: program.title,
        category: program.category || "IT",
        deadline: program.deadline || "",
        link: program.link || "",
        imageUrl: program.imageUrl || "",
        universityId: program.university?.id || universityId,
        requiredDocumentIds: program.required_document_ids || []
      });
    }
  }, [program, universityId]);

  // --- Handlers for Info & Docs ---

  const handleSubmitInfo = async (e?: React.FormEvent) => {
    if(e) e.preventDefault();
    setLoading(true);
    try {
      await onSave({ ...formData, id: program?.id });
      // Не закрываем модалку сразу, если это редактирование, чтобы пользователь мог перейти к таскам
      if (!program) onClose(); 
      else alert("Информация сохранена");
    } catch (e) {
      console.error(e);
    } finally {
      setLoading(false);
    }
  };

  const toggleDocument = (docId: number) => {
      setFormData(prev => {
          const ids = new Set(prev.requiredDocumentIds);
          if (ids.has(docId)) ids.delete(docId);
          else ids.add(docId);
          return { ...prev, requiredDocumentIds: Array.from(ids) };
      });
  };

  // --- Handlers for Tasks (QuestEditor) ---

  // Профиль для QuestEditor, фильтрующий задачи только этой программы
  const programProfile = useMemo(() => {
      if (!program) return null;
      // Фильтруем квесты, у которых programId совпадает с текущим
      // (В реальном приложении это поле должно приходить с бэка в массиве quests)
      // Для мока пока используем логику "если бы оно было"
      const programTasks = quests.filter((q: any) => q.programId === program.id);
      
      return {
          universityId: "program-specific",
          countryId: "program-specific",
          programId: program.id, // Важно для сохранения
          assignedQuests: programTasks
      };
  }, [program, quests]);

  const handleSaveTask = async (task: any) => {
      if (!program?.id) {
          alert("Сначала сохраните программу, чтобы добавлять к ней задачи.");
          return;
      }
      const token = localStorage.getItem("accessToken");
      const payload = {
          ...task,
          programId: program.id, // Привязываем к программе
          countryId: null,      // Отвязываем от страны
          universityId: null    // Отвязываем от вуза
      };
      if (task.id < 0) delete payload.id;

      await fetch(`${API_URL}/admin/task-templates`, {
          method: "POST",
          headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` },
          body: JSON.stringify(payload)
      });
      await refreshData(); // Обновляем глобальный контекст
  };

  const handleDeleteTask = async (id: number) => {
      const token = localStorage.getItem("accessToken");
      await fetch(`${API_URL}/admin/task-templates/${id}`, { method: "DELETE", headers: { Authorization: `Bearer ${token}` } });
      await refreshData();
  };

  const inputClass = "w-full mt-1 p-2 rounded bg-zinc-800 border border-zinc-700 text-sm focus:border-blue-500 focus:outline-none transition";

  return (
    <div className="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center p-4 z-50">
      <div className="w-full max-w-4xl bg-zinc-900 border border-zinc-800 rounded-2xl shadow-2xl flex flex-col max-h-[90vh]" onClick={(e) => e.stopPropagation()}>
        
        {/* Header */}
        <div className="p-6 border-b border-zinc-800 flex justify-between items-center">
            <div>
                <h2 className="text-xl font-bold">{program ? "Настройка программы" : "Создание программы"}</h2>
                <p className="text-sm text-zinc-500">{program?.title || "Новая программа"}</p>
            </div>
            <button onClick={onClose} className="text-zinc-500 hover:text-white transition text-2xl">&times;</button>
        </div>

        {/* Tabs */}
        <div className="flex border-b border-zinc-800 px-6">
            <button 
                onClick={() => setActiveTab('info')}
                className={`py-3 px-4 text-sm font-medium border-b-2 transition ${activeTab === 'info' ? 'border-blue-500 text-blue-500' : 'border-transparent text-zinc-500 hover:text-zinc-300'}`}
            >
                1. Основное
            </button>
            <button 
                onClick={() => setActiveTab('docs')}
                className={`py-3 px-4 text-sm font-medium border-b-2 transition ${activeTab === 'docs' ? 'border-blue-500 text-blue-500' : 'border-transparent text-zinc-500 hover:text-zinc-300'}`}
            >
                2. Документы
            </button>
            <button 
                onClick={() => setActiveTab('tasks')}
                disabled={!program} // Нельзя добавлять задачи, пока программа не создана
                className={`py-3 px-4 text-sm font-medium border-b-2 transition ${activeTab === 'tasks' ? 'border-blue-500 text-blue-500' : 'border-transparent text-zinc-500 hover:text-zinc-300 disabled:opacity-30 disabled:cursor-not-allowed'}`}
            >
                3. Задачи (Кастомизация)
            </button>
        </div>

        {/* Content */}
        <div className="flex-1 overflow-y-auto p-6">
            
            {/* TAB: INFO */}
            {activeTab === 'info' && (
                <form id="prog-form" onSubmit={handleSubmitInfo} className="space-y-4 max-w-lg">
                     <div>
                        <label className="text-xs text-zinc-400">Название (Специальность)</label>
                        <input value={formData.title} onChange={e => setFormData({...formData, title: e.target.value})} className={inputClass} required placeholder="MSc Computer Science" />
                    </div>
                    <div className="grid grid-cols-2 gap-4">
                        <div>
                            <label className="text-xs text-zinc-400">Категория</label>
                            <select value={formData.category} onChange={e => setFormData({...formData, category: e.target.value})} className={inputClass}>
                                {CATEGORIES.map(c => <option key={c} value={c}>{c}</option>)}
                            </select>
                        </div>
                        <div>
                            <label className="text-xs text-zinc-400">Дедлайн</label>
                            <input type="date" value={formData.deadline} onChange={e => setFormData({...formData, deadline: e.target.value})} className={inputClass} />
                        </div>
                    </div>
                    <div>
                        <label className="text-xs text-zinc-400">Ссылка на сайт</label>
                        <input value={formData.link} onChange={e => setFormData({...formData, link: e.target.value})} className={inputClass} placeholder="https://..." />
                    </div>
                    <div>
                        <label className="text-xs text-zinc-400">URL картинки (Cover)</label>
                        <input value={formData.imageUrl} onChange={e => setFormData({...formData, imageUrl: e.target.value})} className={inputClass} placeholder="https://..." />
                    </div>
                    <div className="pt-4">
                        <button type="submit" disabled={loading} className="btn btn-primary w-full">
                            {loading ? "Сохранение..." : "Сохранить изменения"}
                        </button>
                    </div>
                </form>
            )}

            {/* TAB: DOCS */}
            {activeTab === 'docs' && (
                <div className="space-y-4">
                    <p className="text-sm text-zinc-400 mb-4">
                        Выберите документы, которые <b>обязательны</b> именно для этой программы (в дополнение к страновым).
                    </p>
                    <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                        {documents.map(doc => {
                            const isSelected = formData.requiredDocumentIds.includes(doc.id);
                            return (
                                <div 
                                    key={doc.id} 
                                    onClick={() => toggleDocument(doc.id)}
                                    className={`p-3 rounded-lg border cursor-pointer transition flex items-center gap-3 ${
                                        isSelected 
                                        ? 'bg-blue-900/20 border-blue-500/50' 
                                        : 'bg-zinc-800 border-zinc-700 hover:border-zinc-500'
                                    }`}
                                >
                                    <div className={`w-5 h-5 rounded border flex items-center justify-center ${isSelected ? 'bg-blue-600 border-blue-600' : 'border-zinc-500'}`}>
                                        {isSelected && <span className="text-xs text-white">✓</span>}
                                    </div>
                                    <div className="text-sm">
                                        <div className="font-medium text-zinc-200">{doc.title}</div>
                                        <div className="text-xs text-zinc-500">{doc.category}</div>
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                    <button onClick={() => handleSubmitInfo()} className="btn btn-primary mt-4">Сохранить список документов</button>
                </div>
            )}

            {/* TAB: TASKS */}
            {activeTab === 'tasks' && program && (
                <div>
                    <div className="bg-yellow-500/10 border border-yellow-500/20 p-4 rounded-xl mb-6">
                        <h4 className="text-yellow-500 font-bold text-sm mb-1">Кастомизация трека</h4>
                        <p className="text-xs text-yellow-200/70">
                            Задачи, добавленные здесь, появятся у студента <b>только</b> если он выберет эту программу. 
                            Они дополнят стандартный список задач по стране.
                        </p>
                    </div>

                    <QuestEditor 
                        profile={programProfile}
                        onUpdateProfile={() => {}}
                        apiSave={handleSaveTask}
                        apiDelete={handleDeleteTask}
                    />
                </div>
            )}

        </div>
      </div>
    </div>
  );
}
--- END FILE: apps/web/app/curator/admin/countries/ProgramEditModal.tsx ---

--- BEGIN FILE: apps/web/app/curator/admin/countries/QuestEditModal.tsx ---
"use client";
import { useState, useEffect } from "react";

type Props = {
  quest: any;
  onSave: (quest: any) => void;
  onClose: () => void;
};

export default function QuestEditModal({ quest, onSave, onClose }: Props) {
  const [formData, setFormData] = useState(quest);

  useEffect(() => {
    setFormData(quest);
  }, [quest]);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
    const { name, value, type } = e.target;
    const checked = (e.target as HTMLInputElement).checked;
    setFormData((prev: any) => ({ 
        ...prev, 
        [name]: type === 'checkbox' ? checked : (name === 'xpReward' ? Number(value) : value) 
    }));
  };
  
  const handleSubmit = (e: React.FormEvent) => {
      e.preventDefault();
      onSave(formData);
  }

  return (
    <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center p-4 z-50" onClick={onClose}>
      <div className="w-full max-w-lg card p-6 bg-zinc-900" onClick={e => e.stopPropagation()}>
        <form onSubmit={handleSubmit}>
          <h2 className="text-lg font-semibold mb-4">Редактор Задачи</h2>
          <div className="space-y-4">
            <div>
              <label className="text-xs text-zinc-400">Название</label>
              <input type="text" name="title" value={formData.title} onChange={handleChange} className="w-full mt-1 input-style" required />
            </div>
            
            <div className="grid grid-cols-2 gap-4">
                <div>
                   <label className="text-xs text-zinc-400">Этап (Stage)</label>
                   <input type="text" name="stage" value={formData.stage} onChange={handleChange} className="w-full mt-1 input-style" list="stages" />
                   <datalist id="stages">
                       <option value="Подготовка" />
                       <option value="Документы" />
                       <option value="Виза" />
                       <option value="Экзамены" />
                   </datalist>
                </div>
                <div>
                   <label className="text-xs text-zinc-400">Опыт (XP)</label>
                   <input type="number" name="xpReward" value={formData.xpReward} onChange={handleChange} className="w-full mt-1 input-style" />
                </div>
            </div>

            <div>
               <label className="text-xs text-zinc-400">Тип сдачи</label>
               <select name="submissionType" value={formData.submissionType || 'text'} onChange={handleChange} className="w-full mt-1 input-style appearance-none">
                   <option value="text">Текст</option>
                   <option value="file">Файл (PDF/Img)</option>
                   <option value="link">Ссылка</option>
                   <option value="none">Без ответа (Чекбокс)</option>
                   <option value="credentials">Доступы (Логин/Пароль)</option>
               </select>
            </div>

            <div>
               <label className="text-xs text-zinc-400">Дедлайн (текст или смещение)</label>
               <input 
                   type="text" 
                   name="deadline" 
                   value={formData.deadline || ''} 
                   onChange={handleChange} 
                   className="w-full mt-1 input-style" 
                   placeholder="Напр: 2026-05-01 или +30 дней" 
               />
            </div>

            <div>
              <label className="text-xs text-zinc-400">Описание</label>
              <textarea name="description" value={formData.description} onChange={handleChange} rows={4} className="w-full mt-1 input-style" />
            </div>

            <div className="flex items-center gap-3 p-3 bg-zinc-800/50 rounded-lg border border-zinc-800">
               <input 
                   type="checkbox" 
                   name="isCritical" 
                   id="isCritical"
                   checked={formData.isCritical || false} 
                   onChange={handleChange} 
                   className="w-4 h-4 rounded border-zinc-600 bg-zinc-700 text-red-600 focus:ring-red-500" 
               />
               <label htmlFor="isCritical" className="text-sm select-none cursor-pointer text-zinc-300">
                   Критическая задача (блокирует прогресс)
               </label>
            </div>

          </div>
          <div className="flex justify-end gap-3 mt-6">
            <button type="button" onClick={onClose} className="btn bg-zinc-800 hover:bg-zinc-700 text-zinc-300">Отмена</button>
            <button type="submit" className="btn btn-primary">Сохранить</button>
          </div>
        </form>
      </div>
      <style jsx>{`
        .input-style {
          border-radius: 0.5rem;
          border: 1px solid #3f3f46; /* zinc-700 */
          padding: 0.5rem 0.75rem;
          background-color: #18181b; /* zinc-900 */
          color: white;
          font-size: 0.875rem;
        }
        .input-style:focus {
          outline: 2px solid #3b82f6; /* blue-500 */
          border-color: #3b82f6;
        }
      `}</style>
    </div>
  );
}
--- END FILE: apps/web/app/curator/admin/countries/QuestEditModal.tsx ---

--- BEGIN FILE: apps/web/app/curator/admin/countries/QuestEditor.tsx ---
"use client";
import { useState } from "react";
import QuestEditModal from "./QuestEditModal";

type Props = {
  profile?: any;
  countryName?: string;
  flagIcon?: string;
  onUpdateProfile: (p: any) => void;
  apiSave?: (quest: any) => void;
  apiDelete?: (id: number) => void;
};

export default function QuestEditor({ profile, countryName, flagIcon, apiSave, apiDelete }: Props) {
  const [editingQuest, setEditingQuest] = useState<any | null>(null);

  if (!profile) {
    return (
        <div className="h-full flex flex-col items-center justify-center text-zinc-400 p-8 text-center">
            <div className="text-4xl mb-3 opacity-50">🌍</div>
            <p>Выберите страну слева, чтобы настроить её задачи.</p>
        </div>
    );
  }

  const handleRemoveQuest = (questId: number) => {
    if (confirm("Удалить задачу из шаблона страны?")) {
        apiDelete?.(questId);
    }
  };
  
  const handleSaveQuest = (updatedQuest: any) => {
      apiSave?.(updatedQuest);
      setEditingQuest(null);
  };
  
  const handleCreateNew = () => {
    setEditingQuest({
        id: -Date.now(),
        title: "Новая задача",
        stage: "Документы",
        description: "",
        xpReward: 10,
    });
  };

  return (
    <div className="flex flex-col h-full bg-zinc-900 border border-zinc-800 rounded-xl overflow-hidden relative">
      {/* Header с фоном */}
      <div className="relative h-40 shrink-0 bg-zinc-800">
         <div className="w-full h-full bg-gradient-to-br from-blue-900 via-zinc-900 to-black opacity-80" />
         <div className="absolute inset-0 bg-[url('https://images.unsplash.com/photo-1451187580459-43490279c0fa?q=80&w=2072&auto=format&fit=crop')] bg-cover bg-center opacity-20 mix-blend-overlay" />
         
         <div className="absolute bottom-4 left-5 right-5">
             <div className="flex items-center gap-2 mb-1">
                <span className="text-2xl">{flagIcon}</span>
                <span className="px-2 py-0.5 rounded-full bg-white/10 text-white/80 text-[10px] uppercase tracking-wider backdrop-blur-md border border-white/10">
                    Базовый трек
                </span>
             </div>
             <h2 className="text-xl font-bold text-white leading-tight shadow-sm">
                 {countryName || "Страна не выбрана"}
             </h2>
             <p className="text-xs text-zinc-400 mt-1 line-clamp-1">
                 Задачи, обязательные для всех поступающих в эту страну.
             </p>
         </div>
      </div>

      {/* Список задач */}
      <div className="flex-1 overflow-y-auto p-4 custom-scrollbar bg-zinc-950/50">
          
          <div className="flex justify-between items-center mb-4">
              <h3 className="text-sm font-semibold text-zinc-300 flex items-center gap-2">
                  <span className="text-yellow-500">🚩</span> Путь поступления
              </h3>
              <button 
                onClick={handleCreateNew}
                className="text-xs bg-blue-600 hover:bg-blue-500 text-white px-3 py-1.5 rounded-lg transition shadow-sm flex items-center gap-1"
              >
                <span>+</span> Задача
              </button>
          </div>

          {profile.assignedQuests.length === 0 ? (
              <div className="text-center py-12 border-2 border-dashed border-zinc-800 rounded-xl bg-zinc-900/50">
                  <div className="text-2xl mb-2 opacity-50">📭</div>
                  <p className="text-xs text-zinc-500">Список задач пуст</p>
                  <button onClick={handleCreateNew} className="mt-3 text-xs text-blue-400 hover:underline">
                      Создать первую задачу
                  </button>
              </div>
          ) : (
            <div className="space-y-2">
                {profile.assignedQuests.map((quest: any) => (
                <div key={quest.id} className="group flex items-center justify-between p-3 rounded-xl border border-zinc-800 bg-zinc-900 hover:border-zinc-700 transition cursor-default relative overflow-hidden">
                    <div className="relative z-10">
                        <div className="text-[10px] uppercase font-bold text-zinc-500 tracking-wider mb-0.5 flex items-center gap-2">
                            {quest.stage}
                        </div>
                        <div className="font-medium text-sm text-zinc-200">
                            {quest.title}
                        </div>
                    </div>
                    
                    <div className="flex items-center gap-3 relative z-10">
                        <div className="text-zinc-600 text-xs" title={quest.submissionType}>
                           {quest.submissionType === 'file' ? '📄' : quest.submissionType === 'link' ? '🔗' : quest.submissionType === 'none' ? '☑️' : '📝'}
                        </div>
                        <div className="text-xs font-bold text-yellow-600 bg-yellow-500/10 border border-yellow-500/20 px-2 py-1 rounded">
                            +{quest.xpReward} XP
                        </div>                        
                        {/* Actions overlay */}
                        <div className="absolute right-0 top-1/2 -translate-y-1/2 flex gap-1 bg-zinc-900 pl-2 opacity-0 group-hover:opacity-100 transition-opacity">
                             <button 
                                onClick={() => setEditingQuest(quest)} 
                                className="p-1.5 hover:bg-zinc-800 rounded text-blue-400"
                                title="Редактировать"
                            >
                                ✏️
                            </button>
                            <button 
                                onClick={() => handleRemoveQuest(quest.id)} 
                                className="p-1.5 hover:bg-zinc-800 rounded text-red-400"
                                title="Удалить"
                            >
                                🗑️
                            </button>
                        </div>
                    </div>

                </div>
                ))}
            </div>
          )}
      </div>

      {editingQuest && (
        <QuestEditModal
          quest={editingQuest}
          onSave={handleSaveQuest}
          onClose={() => setEditingQuest(null)}
        />
      )}
    </div>
  );
}
--- END FILE: apps/web/app/curator/admin/countries/QuestEditor.tsx ---

--- BEGIN FILE: apps/web/app/curator/admin/countries/UniversityAccordion.tsx ---
"use client";
import { useState, useRef, useEffect } from "react";
import { University, Program } from "../../../../shared/CountryContext";

type Props = {
  university: University;
  programs: Program[];
  onSelectProgram: (program: Program) => void;
  onEditProgram: (program: Program) => void; // Для быстрого редактирования из списка
  onDeleteProgram: (id: number) => void;
};

// Функция группировки программ по категориям
const groupPrograms = (programs: Program[]) => {
  const groups: Record<string, Program[]> = {};
  programs.forEach(p => {
    const cat = p.category || "Общее";
    if (!groups[cat]) groups[cat] = [];
    groups[cat].push(p);
  });
  
  // Сортировка программ внутри групп A-Z
  Object.keys(groups).forEach(key => {
      groups[key].sort((a, b) => a.title.localeCompare(b.title));
  });
  
  return groups;
};

export default function UniversityAccordion({ university, programs, onSelectProgram, onEditProgram, onDeleteProgram }: Props) {
  const [isOpen, setIsOpen] = useState(false);
  const contentRef = useRef<HTMLDivElement>(null);
  const [height, setHeight] = useState("0px");

  const groupedPrograms = groupPrograms(programs);
  const categories = Object.keys(groupedPrograms).sort();

  useEffect(() => {
      // Динамический расчет высоты для анимации
      if (isOpen && contentRef.current) {
          setHeight(`${contentRef.current.scrollHeight}px`);
      } else {
          setHeight("0px");
      }
  }, [isOpen, programs]); // Пересчитываем при открытии или изменении программ

  return (
    <div className="border border-zinc-200 dark:border-zinc-700 rounded-xl overflow-hidden bg-white dark:bg-zinc-900 transition-all hover:border-zinc-400 dark:hover:border-zinc-600 mb-2">
      {/* Header Аккордеона */}
      <button 
        onClick={() => setIsOpen(!isOpen)}
        className="w-full flex items-center justify-between p-3 text-left hover:bg-zinc-50 dark:hover:bg-zinc-800/50 transition"
      >
        <div className="flex items-center gap-3">
             <span className="text-xl">{university.logo_url}</span>
             <div>
                 <div className="font-semibold text-sm">{university.name}</div>
                 <div className="text-xs text-zinc-500">{programs.length} программ</div>
             </div>
        </div>
        <div className={`transform transition-transform duration-300 ${isOpen ? "rotate-180" : ""}`}>
            ▼
        </div>
      </button>

      {/* Выпадающий контент */}
      <div 
        style={{ maxHeight: height, opacity: isOpen ? 1 : 0 }}
        className="transition-all duration-300 ease-in-out overflow-hidden bg-zinc-50 dark:bg-zinc-900/50"
        ref={contentRef}
      >
         <div className="p-3 pt-0">
            {programs.length === 0 ? (
                <p className="text-xs text-zinc-400 p-2 italic">Нет добавленных программ</p>
            ) : (
                <div className="space-y-4 mt-2">
                    {categories.map(cat => (
                        <div key={cat}>
                            <h4 className="text-xs font-bold text-zinc-400 uppercase tracking-wider mb-1 ml-1">{cat}</h4>
                            <ul className="space-y-1">
                                {groupedPrograms[cat].map(prog => (
                                    <li key={prog.id} className="group flex items-center justify-between p-2 rounded-lg hover:bg-white dark:hover:bg-zinc-800 border border-transparent hover:border-zinc-200 dark:hover:border-zinc-700 transition cursor-pointer"
                                        onClick={() => onSelectProgram(prog)}
                                    >
                                        <span className="text-sm truncate pr-2">{prog.title}</span>
                                        <div className="flex gap-2 opacity-0 group-hover:opacity-100 transition">
                                            <button 
                                                onClick={(e) => { e.stopPropagation(); onEditProgram(prog); }} 
                                                className="text-xs text-blue-500 hover:underline"
                                            >
                                                Ред
                                            </button>
                                            <button 
                                                onClick={(e) => { e.stopPropagation(); onDeleteProgram(prog.id); }} 
                                                className="text-xs text-red-500 hover:underline"
                                            >
                                                Удал
                                            </button>
                                        </div>
                                    </li>
                                ))}
                            </ul>
                        </div>
                    ))}
                </div>
            )}
            
            {/* Кнопка добавления программы прямо в этот вуз (опционально можно добавить) */}
         </div>
      </div>
    </div>
  );
}
--- END FILE: apps/web/app/curator/admin/countries/UniversityAccordion.tsx ---

--- BEGIN FILE: apps/web/app/curator/admin/countries/page.tsx ---
"use client";
import { useEffect, useState, useMemo } from "react";
import { useCountry, Program } from "../../../../shared/CountryContext";
import ProgramEditModal from "./ProgramEditModal";
import UniversityAccordion from "./UniversityAccordion";
// import ProgramDetailModal from "./ProgramDetailModal"; // Больше не нужен
import CountryDetailPanel from "./CountryDetailPanel";
import ProgramDetailPanel from "./ProgramDetailPanel"; // <--- Импортируем новый компонент

const API_URL = process.env.NEXT_PUBLIC_API_URL ?? "http://localhost:4000/api";

export default function ConfiguratorPage() {
  const { countries, universities, refreshData, quests } = useCountry();
  const [selectedCountryId, setSelectedCountryId] = useState<string | null>(null);
  
  // Состояние
  const [programs, setPrograms] = useState<Program[]>([]);
  const [loadingPrograms, setLoadingPrograms] = useState(false);
  
  // Модальные окна
  const [editingProgram, setEditingProgram] = useState<Program | null>(null);
  
  // Вместо модалки для просмотра, используем состояние для панели
  const [viewingProgram, setViewingProgram] = useState<Program | null>(null);
  
  const [isProgramModalOpen, setIsProgramModalOpen] = useState(false);
  const [activeUniversityIdForCreate, setActiveUniversityIdForCreate] = useState<string | null>(null);
  const [isCountryModalOpen, setIsCountryModalOpen] = useState(false); // Для создания страны


  // Инициализация страны (выбираем первую по умолчанию)
  useEffect(() => {
      if (countries.length > 0 && !selectedCountryId) {
          setSelectedCountryId(countries[0].id);
      }
  }, [countries]);

  // При смене страны сбрасываем выбранную программу
  useEffect(() => {
      setViewingProgram(null);
  }, [selectedCountryId]);

  const activeCountry = useMemo(() => 
    countries.find(c => c.id === selectedCountryId), 
  [countries, selectedCountryId]);

  // Загрузка программ
  useEffect(() => {
      if (selectedCountryId) {
          setLoadingPrograms(true);
          const token = localStorage.getItem("accessToken");
          fetch(`${API_URL}/admin/programs/search?countryId=${selectedCountryId}`, {
              headers: { Authorization: `Bearer ${token}` }
          })
          .then(async (res) => {
              if (res.ok) {
                  const data = await res.json();
                  setPrograms(Array.isArray(data) ? data : []);
              }
          })
          .finally(() => setLoadingPrograms(false));
      }
  }, [selectedCountryId]);

  const filteredUniversities = useMemo(() => {
      return universities.filter((u: any) => u.countryId === selectedCountryId);
  }, [universities, selectedCountryId]);

  // --- CRUD Actions ---
  const handleSaveProgram = async (data: any) => {
      const token = localStorage.getItem("accessToken");
      const method = data.id ? "PATCH" : "POST";
      const url = data.id ? `${API_URL}/admin/programs/${data.id}` : `${API_URL}/admin/programs`;
      
      const res = await fetch(url, {
          method,
          headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` },
          body: JSON.stringify(data)
      });
      
      if (res.ok) {
           const resP = await fetch(`${API_URL}/admin/programs/search?countryId=${selectedCountryId}`, {
              headers: { Authorization: `Bearer ${token}` }
           });
           const updatedPrograms = await resP.json();
           setPrograms(updatedPrograms);
           
           // Если мы редактировали текущую просматриваемую программу, обновим её данные в панели
           if (viewingProgram && data.id) {
               const updatedCurrent = updatedPrograms.find((p: any) => p.id === data.id);
               if (updatedCurrent) setViewingProgram(updatedCurrent);
           }
      }
  };

  const handleDeleteProgram = async (id: number) => {
       if(!confirm("Удалить программу?")) return;
       const token = localStorage.getItem("accessToken");
       await fetch(`${API_URL}/admin/programs/${id}`, { method: "DELETE", headers: { Authorization: `Bearer ${token}` } });
       setPrograms(prev => prev.filter(p => p.id !== id));
       if (viewingProgram?.id === id) setViewingProgram(null);
  };
  
  const saveTaskTemplate = async (task: any) => {
    const token = localStorage.getItem("accessToken");
    const payload = { ...task, countryId: selectedCountryId };
    if (task.id < 0) delete payload.id;
    await fetch(`${API_URL}/admin/task-templates`, {
        method: "POST",
        headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` },
        body: JSON.stringify(payload)
    });
    await refreshData();
  };

  const deleteTaskTemplate = async (id: number) => {
    const token = localStorage.getItem("accessToken");
    await fetch(`${API_URL}/admin/task-templates/${id}`, { method: "DELETE", headers: { Authorization: `Bearer ${token}` } });
    await refreshData();
  };

  // Создание страны
  const handleCreateCountry = async (e: React.FormEvent<HTMLFormElement>) => {
      e.preventDefault();
      const formData = new FormData(e.currentTarget);
      const token = localStorage.getItem("accessToken");
      await fetch(`${API_URL}/admin/countries`, {
          method: "POST",
          headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` },
          body: JSON.stringify({ id: formData.get("id"), name: formData.get("name"), flagIcon: formData.get("flag") })
      });
      await refreshData();
      setIsCountryModalOpen(false);
  };


  return (
    <div className="flex flex-col h-[calc(100vh-6rem)]">
      <div className="mb-4 shrink-0">
        <h1 className="text-2xl font-semibold">База знаний</h1>
        <p className="text-zinc-500 text-sm">Настройка стран, университетов и образовательных треков.</p>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-[260px_1fr_380px] gap-6 flex-1 overflow-hidden">
        
        {/* Колонка 1: Страны (Сайдбар навигации) */}
        <div className="card flex flex-col bg-white dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-800 overflow-hidden">
          <div className="p-3 border-b border-zinc-100 dark:border-zinc-800 bg-zinc-50 dark:bg-zinc-900/50">
             <h2 className="text-xs font-bold text-zinc-500 uppercase tracking-wider">Страны</h2>
          </div>
          <div className="flex-1 overflow-y-auto p-2">
            <ul className="space-y-1">
                {countries.map((c: any) => (
                <li key={c.id}>
                    <button
                    onClick={() => setSelectedCountryId(c.id)}
                    className={`w-full text-left px-3 py-2.5 rounded-lg transition text-sm flex items-center justify-between group ${
                        selectedCountryId === c.id 
                        ? 'bg-blue-600 text-white shadow-md' 
                        : 'hover:bg-zinc-100 dark:hover:bg-zinc-800 text-zinc-700 dark:text-zinc-300'
                    }`}
                    >
                        <span className="flex items-center gap-2">
                            <span className="text-lg leading-none">{c.flag_icon}</span> 
                            <span className="font-medium">{c.name}</span>
                        </span>
                        {selectedCountryId === c.id && <span className="text-xs opacity-70">●</span>}
                    </button>
                </li>
                ))}
            </ul>
          </div>
          <div className="p-2 border-t border-zinc-100 dark:border-zinc-800">
            <button 
                onClick={() => setIsCountryModalOpen(true)}
                className="w-full py-2 border border-dashed border-zinc-300 dark:border-zinc-700 rounded-lg text-xs text-zinc-500 hover:border-blue-500 hover:text-blue-500 transition"
            >
                + Добавить страну
            </button>
          </div>

        </div>

        {/* Колонка 2: Университеты (Центральная область) */}
        <div className="flex flex-col gap-4 overflow-hidden">
            <div className="flex items-center justify-between shrink-0 px-1">
                 <div>
                     <h2 className="font-bold text-lg flex items-center gap-2">
                        {activeCountry?.flag_icon} {activeCountry?.name}
                        <span className="text-zinc-400 font-normal text-sm">/ Университеты</span>
                     </h2>
                 </div>
                 <button className="text-xs bg-zinc-900 text-white dark:bg-white dark:text-black px-3 py-1.5 rounded-lg hover:opacity-90 transition font-medium">
                     + Добавить ВУЗ
                 </button>
            </div>
            
            <div className="flex-1 overflow-y-auto pr-2 custom-scrollbar">
                {filteredUniversities.length === 0 ? (
                    <div className="h-full flex flex-col items-center justify-center text-zinc-400 bg-zinc-50 dark:bg-zinc-900/30 rounded-xl border border-dashed border-zinc-200 dark:border-zinc-800">
                        <div className="text-3xl mb-2 opacity-50">🏛️</div>
                        <p>В этой стране пока нет университетов</p>
                    </div>
                ) : (
                    <div className="space-y-4 pb-10">
                        {filteredUniversities.map((uni: any) => (
                            <UniversityAccordion
                                key={uni.id}
                                university={uni}
                                programs={programs.filter(p => p.university_id === uni.id || (p as any).universityId === uni.id)}
                                onSelectProgram={(p) => setViewingProgram(p)}
                                onEditProgram={(p) => { setEditingProgram(p); setActiveUniversityIdForCreate(uni.id); setIsProgramModalOpen(true); }}
                                onDeleteProgram={handleDeleteProgram}
                            />
                        ))}
                        <div className="h-4"></div> {/* Spacer */}
                    </div>
                )}
            </div>
        </div>

        {/* Колонка 3: Детали (Сменная панель: Страна или Программа) */}
        <div className="h-full overflow-hidden">
            {viewingProgram ? (
                <ProgramDetailPanel 
                    program={viewingProgram}
                    onClose={() => setViewingProgram(null)}
                    onEdit={() => {
                        setEditingProgram(viewingProgram);
                        setActiveUniversityIdForCreate(viewingProgram.university_id || (viewingProgram as any).universityId);
                        setIsProgramModalOpen(true);
                    }}
                />
            ) : (
                <CountryDetailPanel
                    countryId={selectedCountryId || ""}
                    onSaveTask={saveTaskTemplate}
                    onDeleteTask={deleteTaskTemplate}
                 />
            )}
         </div>
      </div>
      
      {/* Modals */}
      {isProgramModalOpen && activeUniversityIdForCreate && (
        <ProgramEditModal
            program={editingProgram}
            universityId={activeUniversityIdForCreate}
            onSave={handleSaveProgram}
            onClose={() => setIsProgramModalOpen(false)}
        />
      )}

      {isCountryModalOpen && (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/70 backdrop-blur-sm">
            <div className="card w-full max-w-sm p-6 bg-zinc-900">
                <h3 className="text-lg font-bold mb-4">Новая страна</h3>
                <form onSubmit={handleCreateCountry} className="space-y-3">
                    <div>
                        <label className="text-xs text-zinc-500">ID (slug)</label>
                        <input name="id" required className="w-full p-2 bg-zinc-800 rounded border border-zinc-700" placeholder="e.g. fr" />
                    </div>
                    <div>
                        <label className="text-xs text-zinc-500">Название</label>
                        <input name="name" required className="w-full p-2 bg-zinc-800 rounded border border-zinc-700" placeholder="France" />
                    </div>
                    <div>
                        <label className="text-xs text-zinc-500">Флаг (Emoji)</label>
                        <input name="flag" required className="w-full p-2 bg-zinc-800 rounded border border-zinc-700" placeholder="🇫🇷" />
                    </div>
                    <div className="flex gap-2 justify-end mt-4">
                        <button type="button" onClick={() => setIsCountryModalOpen(false)} className="btn text-xs">Отмена</button>
                        <button type="submit" className="btn btn-primary text-xs">Создать</button>
                    </div>
                </form>
            </div>
        </div>
      )}
    </div>
  );


}
--- END FILE: apps/web/app/curator/admin/countries/page.tsx ---

--- BEGIN FILE: apps/web/app/curator/admin/moderators/BindStudentModal.tsx ---
"use client";
import { useState, useEffect } from "react";

const API_URL = process.env.NEXT_PUBLIC_API_URL ?? "http://localhost:4000/api";

type StudentSimple = {
  id: string;
  fullName: string;
  countryId: string;
};

type Props = {
  moderatorId: string; // ID пользователя-модератора
  onClose: () => void;
  onSuccess: () => void;
};

export default function BindStudentModal({ moderatorId, onClose, onSuccess }: Props) {
  const [students, setStudents] = useState<StudentSimple[]>([]);
  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());
  const [loading, setLoading] = useState(true);
  const [submitting, setSubmitting] = useState(false);

  useEffect(() => {
    const fetchFreeStudents = async () => {
      const token = localStorage.getItem("accessToken");
      try {
        const res = await fetch(`${API_URL}/admin/students/unassigned`, {
          headers: { Authorization: `Bearer ${token}` }
        });
        if (res.ok) {
          setStudents(await res.json());
        }
      } catch (e) {
        console.error(e);
      } finally {
        setLoading(false);
      }
    };
    fetchFreeStudents();
  }, []);

  const toggleStudent = (id: string) => {
    const newSet = new Set(selectedIds);
    if (newSet.has(id)) newSet.delete(id);
    else newSet.add(id);
    setSelectedIds(newSet);
  };

  const handleSubmit = async () => {
    if (selectedIds.size === 0) return;
    setSubmitting(true);
    const token = localStorage.getItem("accessToken");
    try {
      const res = await fetch(`${API_URL}/admin/moderators/${moderatorId}/assign-students`, {
        method: "POST",
        headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` },
        body: JSON.stringify({ studentIds: Array.from(selectedIds) })
      });
      if (res.ok) {
        onSuccess();
        onClose();
      } else {
        alert("Ошибка привязки");
      }
    } catch (e) {
      alert("Ошибка сети");
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <div className="fixed inset-0 bg-black/60 flex items-center justify-center p-4 z-50 backdrop-blur-sm" onClick={onClose}>
      <div className="w-full max-w-md bg-white dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-800 rounded-2xl shadow-2xl flex flex-col max-h-[80vh]" onClick={e => e.stopPropagation()}>
        <div className="p-4 border-b border-zinc-100 dark:border-zinc-800 flex justify-between items-center">
          <h3 className="font-bold">Привязать студентов</h3>
          <button onClick={onClose} className="text-zinc-500 hover:text-black dark:hover:text-white">&times;</button>
        </div>
        
        <div className="flex-1 overflow-y-auto p-2">
          {loading ? (
            <div className="text-center py-8 text-zinc-500">Загрузка...</div>
          ) : students.length === 0 ? (
            <div className="text-center py-8 text-zinc-500">Нет свободных студентов</div>
          ) : (
            <div className="space-y-1">
              {students.map(s => {
                const isSelected = selectedIds.has(s.id);
                return (
                  <div 
                    key={s.id} 
                    onClick={() => toggleStudent(s.id)}
                    className={`flex items-center gap-3 p-3 rounded-xl cursor-pointer transition border ${
                      isSelected 
                      ? "bg-blue-50 dark:bg-blue-900/20 border-blue-500" 
                      : "bg-transparent border-transparent hover:bg-zinc-100 dark:hover:bg-zinc-800"
                    }`}
                  >
                    <div className={`w-5 h-5 rounded-full border flex items-center justify-center ${isSelected ? "bg-blue-500 border-blue-500" : "border-zinc-400"}`}>
                      {isSelected && <span className="text-white text-xs">✓</span>}
                    </div>
                    <div>
                        <div className="font-medium text-sm">{s.fullName}</div>
                        <div className="text-xs text-zinc-500 uppercase">{s.countryId}</div>
                    </div>
                  </div>
                )
              })}
            </div>
          )}
        </div>

        <div className="p-4 border-t border-zinc-100 dark:border-zinc-800 flex justify-between items-center">
            <span className="text-xs text-zinc-500">Выбрано: {selectedIds.size}</span>
            <button 
                onClick={handleSubmit} 
                disabled={submitting || selectedIds.size === 0}
                className="btn btn-primary text-sm px-6"
            >
                {submitting ? "Сохранение..." : "Привязать"}
            </button>
        </div>
      </div>
    </div>
  );
}
--- END FILE: apps/web/app/curator/admin/moderators/BindStudentModal.tsx ---

--- BEGIN FILE: apps/web/app/curator/admin/moderators/ModeratorModal.tsx ---
"use client";
import { useState, useEffect, useRef } from "react";

const API_URL = process.env.NEXT_PUBLIC_API_URL ?? "http://localhost:4000/api";

type Props = {
  moderator?: any | null; // Если null - режим создания
  onClose: () => void;
  onSave: (data: any) => Promise<any>;
  onDelete?: (id: string) => Promise<void>;
};

export default function ModeratorModal({ moderator, onClose, onSave, onDelete }: Props) {
  const [formData, setFormData] = useState({
    email: "",
    fullName: "",
    specialization: "",
    bio: "",
    avatarUrl: "",
    isActive: true,
    password: ""
  });
  const [showPassword, setShowPassword] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [createdPassword, setCreatedPassword] = useState<string | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    if (moderator) {
      setFormData({
        email: moderator.email,
        fullName: moderator.curator?.fullName || "",
        specialization: moderator.curator?.specialization || "",
        bio: moderator.curator?.bio || "",
        avatarUrl: moderator.curator?.avatarUrl || "",
        isActive: moderator.isActive,
        password: moderator.password || "" // <--- Подставляем пароль
      });
    }
  }, [moderator]);

  const handleFileUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!e.target.files?.[0]) return;
    const file = e.target.files[0];
    const formData = new FormData();
    formData.append('file', file);

    try {
      const token = localStorage.getItem("accessToken");
      const res = await fetch(`${API_URL}/files/upload`, {
        method: 'POST',
        headers: { Authorization: `Bearer ${token}` },
        body: formData
      });
      if (res.ok) {
        const data = await res.json();
        setFormData(prev => ({ ...prev, avatarUrl: data.url }));
      }
    } catch (err) {
      alert("Ошибка загрузки");
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    try {
      const payload: any = { ...formData, id: moderator?.id };
      if (!payload.password) delete payload.password;

      const result = await onSave(payload);

      if (!moderator && result?.generatedPassword) {
        setCreatedPassword(result.generatedPassword);
      } else {
        onClose();
      }
    } catch (err) {
      alert("Ошибка сохранения");
    } finally {
      setIsLoading(false);
    }
  };

  if (createdPassword) {
    return (
      <div className="fixed inset-0 bg-black/60 flex items-center justify-center p-4 z-50">
        <div className="w-full max-w-md card p-6 bg-zinc-900 text-center">
          <div className="text-4xl mb-4">✅</div>
          <h3 className="text-xl font-bold mb-2">Куратор создан</h3>
          <p className="text-zinc-400 mb-4">Скопируйте пароль и передайте сотруднику:</p>

          <div className="bg-zinc-800 p-4 rounded-xl border border-zinc-700 font-mono text-xl select-all mb-6 text-green-400">
            {createdPassword}
          </div>

          <button onClick={onClose} className="btn btn-primary w-full">
            Закрыть
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="fixed inset-0 bg-black/60 flex items-center justify-center p-4 z-50 overflow-y-auto">
      <div className="w-full max-w-lg card p-6 bg-zinc-900 my-8">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-lg font-bold">
            {moderator ? "Редактировать профиль" : "Новый куратор"}
          </h2>
          <button onClick={onClose} className="text-2xl leading-none">&times;</button>
        </div>

        <form onSubmit={handleSubmit} className="space-y-4">
          <div className="flex items-center gap-4">
            <div
              className="w-20 h-20 rounded-full bg-zinc-800 flex items-center justify-center overflow-hidden border border-zinc-700 cursor-pointer hover:border-blue-500 transition relative group"
              onClick={() => fileInputRef.current?.click()}
            >
              {formData.avatarUrl ? (
                // eslint-disable-next-line @next/next/no-img-element
                <img src={formData.avatarUrl} alt="Avatar" className="w-full h-full object-cover" />
              ) : (
                <span className="text-2xl text-zinc-500">📷</span>
              )}
              <div className="absolute inset-0 bg-black/40 flex items-center justify-center opacity-0 group-hover:opacity-100 transition">
                <span className="text-xs text-white">Изменить</span>
              </div>
            </div>
            <input type="file" ref={fileInputRef} className="hidden" onChange={handleFileUpload} accept="image/*" />
            <div className="text-sm text-zinc-500">
              Нажмите на фото, чтобы загрузить аватар.
            </div>
          </div>

          <div className="grid grid-cols-2 gap-4">
            <div>
              <label className="text-xs text-zinc-400">ФИО</label>
              <input
                value={formData.fullName}
                onChange={(e) => setFormData({ ...formData, fullName: e.target.value })}
                className="w-full mt-1 p-2 rounded-xl bg-zinc-800 border border-zinc-700 text-sm"
                placeholder="Иван Иванов"
              />
            </div>
            <div>
              <label className="text-xs text-zinc-400">Специализация</label>
              <input
                value={formData.specialization}
                onChange={(e) => setFormData({ ...formData, specialization: e.target.value })}
                className="w-full mt-1 p-2 rounded-xl bg-zinc-800 border border-zinc-700 text-sm"
                placeholder="Визы, США"
              />
            </div>
          </div>

          <div>
            <label className="text-xs text-zinc-400">Email (Логин)</label>
            <input
              type="email"
              required
              value={formData.email}
              onChange={(e) => setFormData({ ...formData, email: e.target.value })}
              className="w-full mt-1 p-2 rounded-xl bg-zinc-800 border border-zinc-700 text-sm"
              placeholder="curator@abbit.com"
            />
          </div>

          <div>
            <label className="text-xs text-zinc-400">Пароль</label>
            <div className="relative">
              <input
                type={showPassword ? "text" : "password"}
                value={formData.password}
                onChange={(e) => setFormData({ ...formData, password: e.target.value })}
                className="w-full mt-1 p-2 rounded-xl bg-zinc-800 border border-zinc-700 text-sm font-mono pr-8"
                placeholder={moderator ? "Текущий пароль" : "Пароль"}
              />
              <button
                type="button"
                onClick={() => setShowPassword(!showPassword)}
                className="absolute right-3 top-3 text-zinc-500 hover:text-zinc-300"
              >
                {showPassword ? "🙈" : "👁️"}
              </button>
              <button
                type="button"
                onClick={() => {
                  const pwd = Math.random().toString(36).slice(-8);
                  setFormData({ ...formData, password: pwd });
                  setShowPassword(true);
                }}
                className="absolute right-10 top-3 text-zinc-500 hover:text-zinc-300 transform active:scale-95 transition-transform"
                title="Сгенерировать пароль"
              >
                🎲
              </button>
            </div>
          </div>

          <div>
            <label className="text-xs text-zinc-400">О себе</label>
            <textarea
              value={formData.bio}
              onChange={(e) => setFormData({ ...formData, bio: e.target.value })}
              className="w-full mt-1 p-2 rounded-xl bg-zinc-800 border border-zinc-700 text-sm"
              rows={3}
            />
          </div>

          {moderator && (
            <div className="flex items-center gap-3 p-3 bg-zinc-800/50 rounded-xl">
              <input
                type="checkbox"
                id="active"
                checked={formData.isActive}
                onChange={(e) => setFormData({ ...formData, isActive: e.target.checked })}
                className="w-5 h-5 rounded"
              />
              <label htmlFor="active" className="text-sm cursor-pointer select-none">
                Активный аккаунт (доступ разрешен)
              </label>
            </div>
          )}

          <div className="flex justify-between items-center mt-6">
            {moderator && onDelete ? (
              <button
                type="button"
                onClick={async () => {
                  if (confirm("Удалить куратора безвозвратно?")) {
                    await onDelete(moderator.id);
                    onClose();
                  }
                }}
                className="btn bg-red-100 dark:bg-red-900/30 text-red-600 dark:text-red-400 text-sm px-3"
              >
                Удалить
              </button>
            ) : <div></div>}
            <div className="flex gap-2">
              <button type="button" onClick={onClose} className="btn bg-zinc-200 dark:bg-zinc-800 text-black dark:text-zinc-300">
                Отмена
              </button>
              <button type="submit" disabled={isLoading} className="btn btn-primary">
                {isLoading ? "Сохранение..." : moderator ? "Сохранить" : "Создать"}
              </button>
            </div>
          </div>
        </form>
      </div>
    </div>
  );
}
--- END FILE: apps/web/app/curator/admin/moderators/ModeratorModal.tsx ---

--- BEGIN FILE: apps/web/app/curator/admin/moderators/page.tsx ---
"use client";
import { useEffect, useState, useMemo } from "react";
import Link from "next/link";
import { useCountry } from "@/shared/CountryContext";
import ModeratorModal from "./ModeratorModal";
import BindStudentModal from "./BindStudentModal";
import Calendar from "@/shared/Calendar";
import type { CalendarEvent } from "@/shared/Calendar";
import allQuestsTemplate from "@/mock/quest_templates.json"; // Мок для генерации событий


const API_URL = process.env.NEXT_PUBLIC_API_URL ?? "http://localhost:4000/api";

type Moderator = {
  id: string;
  email: string;
  isActive: boolean;
  password?: string; // <--- Добавили
  createdAt: string;
  curator?: { // Data from relation
      fullName: string;
      specialization: string;
      bio: string;
      avatarUrl: string;
  };
};

type StudentShort = {
  id: string;
  fullName: string;
  countryId?: string;
  xpTotal: number;
};

export default function ModeratorsPage() {
  const { countries } = useCountry();
  const [moderators, setModerators] = useState<Moderator[]>([]);
  const [students, setStudents] = useState<StudentShort[]>([]);
  const [selectedModeratorId, setSelectedModeratorId] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [modalMode, setModalMode] = useState<'create' | 'edit'>('create');
  const [isBindModalOpen, setIsBindModalOpen] = useState(false);
  // --- НОВОЕ: Состояние табов ---
  const [activeTab, setActiveTab] = useState<'info' | 'calendar' | 'tasks'>('info');

  const fetchModerators = async () => {
    const token = localStorage.getItem("accessToken");
    try {
      const res = await fetch(`${API_URL}/admin/moderators`, {
        headers: { Authorization: `Bearer ${token}` }
      });
      if (res.ok) {
        const data = await res.json();
        // Removed mock enrichment, data comes from backend
        setModerators(data.curators);
        setStudents(data.students);
        // Если ничего не выбрано, выбираем первого
        if (!selectedModeratorId && data.curators.length > 0) setSelectedModeratorId(data.curators[0].id);
      }
    } catch (e) { console.error(e); } finally { setLoading(false); }
  };

  useEffect(() => {
    fetchModerators();
  }, []);

  // Хелпер для получения студентов конкретного модератора (Mock Logic)
  const getModeratorStudents = (modId: string) => {
      const modIndex = moderators.findIndex(m => m.id === modId);
      if (modIndex === -1) return [];
      return students.filter((s, idx) => idx % moderators.length === modIndex);
  };

  const activeMod = moderators.find(m => m.id === selectedModeratorId);
  const linkedStudents = activeMod ? getModeratorStudents(activeMod.id) : [];

  // --- НОВОЕ: Генерация статистики и данных для табов ---
  const moderatorStats = useMemo(() => {
      if (!activeMod) return { totalXP: 0, studentsCount: 0, pendingReviews: 0 };
      const totalXP = linkedStudents.reduce((acc, s) => acc + s.xpTotal, 0);
      // Имитация: у каждого 3-го студента есть задача на проверку
      const pendingReviews = Math.floor(linkedStudents.length / 3); 
      return { totalXP, studentsCount: linkedStudents.length, pendingReviews };
  }, [activeMod, linkedStudents]);

  const moderatorEvents = useMemo(() => {
      if (!activeMod) return [];
      const events: CalendarEvent[] = [];
      // Генерируем фейковые дедлайны для студентов этого куратора
      linkedStudents.forEach((student, i) => {
          // Берем пару случайных квестов
          const q1 = allQuestsTemplate[i % allQuestsTemplate.length];
          if (q1 && q1.deadline) {
              events.push({
                  date: q1.deadline,
                  title: `${q1.title} (${student.fullName})`,
                  type: 'quest'
              });
          }
      });
      return events;
  }, [activeMod, linkedStudents, allQuestsTemplate]);

  const moderatorReviewTasks = useMemo(() => {
      if (!activeMod) return [];
      // Генерируем фейковый список задач на проверку
      const tasks = [];
      for(let i = 0; i < moderatorStats.pendingReviews; i++) {
          const student = linkedStudents[i];
          tasks.push({
              id: i + 1000,
              title: "Загрузка паспорта",
              studentName: student.fullName,
              date: new Date().toISOString().split('T')[0]
          });
      }
      return tasks;
  }, [activeMod, linkedStudents, moderatorStats]);

  const handleSaveModerator = async (data: any) => {
      const token = localStorage.getItem("accessToken");
      let res;
      
      // Pass full data object (includes profile fields and password)
      if (data.id) {
          res = await fetch(`${API_URL}/admin/moderators/${data.id}`, {
              method: "PATCH",
              headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` },
              body: JSON.stringify(data)
          });
      } else {
          res = await fetch(`${API_URL}/admin/moderators`, {
              method: "POST",
              headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` },
              body: JSON.stringify(data)
          });
      }
      
      if (res.ok) {
          const result = await res.json();
          // ВАЖНО: Обновляем список модераторов после успешного сохранения
          await fetchModerators(); 
          return result; 
      } else {
          throw new Error("Failed");
      }
  };

  const handleDeleteModerator = async (id: string) => {
      const token = localStorage.getItem("accessToken");
      try {
          await fetch(`${API_URL}/admin/moderators/${id}`, {
              method: "DELETE",
              headers: { Authorization: `Bearer ${token}` }
          });
          // Убираем из списка и сбрасываем выбор, если удалили активного
          setModerators(prev => prev.filter(m => m.id !== id));
          if (selectedModeratorId === id) setSelectedModeratorId(null);
      } catch (e) {
          console.error(e);
          alert("Ошибка удаления");
      }
  };

  if (loading) return <div className="p-8 text-zinc-500">Загрузка данных...</div>;

  return (
    <div className="h-[calc(100vh-6rem)] flex flex-col">
      <div className="mb-4">
        <h1 className="text-2xl font-semibold">Управление Модераторами</h1>
        <p className="text-zinc-400 text-sm">Профили кураторов и распределение студентов.</p>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-[300px_1fr] gap-6 h-full overflow-hidden">
        {/* Список модераторов */}
        <div className="card overflow-y-auto p-2">
          <div className="p-2 flex justify-between items-center mb-2">
              <span className="text-xs font-bold text-zinc-500 uppercase">Список ({moderators.length})</span>
              <button 
                onClick={() => { setModalMode('create'); setIsModalOpen(true); }}
                className="text-xs bg-zinc-200 dark:bg-zinc-800 px-2 py-1 rounded hover:bg-zinc-300 dark:hover:bg-zinc-700 transition"
              >
                + Добавить
              </button>
          </div>
          <ul className="space-y-1">
            {moderators.map((mod, index) => (
              <li key={mod.id}>
                <button
                  onClick={() => setSelectedModeratorId(mod.id)}
                  className={`w-full text-left px-3 py-3 rounded-xl transition flex items-center gap-3 ${
                    selectedModeratorId === mod.id 
                      ? "bg-black text-white dark:bg-zinc-800" 
                      : "hover:bg-zinc-100 dark:hover:bg-zinc-800/50"
                  }`}
                >
                  <div className="w-8 h-8 rounded-full bg-zinc-200 dark:bg-zinc-700 flex items-center justify-center text-xs font-bold text-zinc-600 dark:text-zinc-300 overflow-hidden">
                    {mod.curator?.avatarUrl ? (
                         <img src={mod.curator.avatarUrl} className="w-full h-full object-cover" />
                    ) : (
                        mod.curator?.fullName?.[0]?.toUpperCase() || mod.email[0]?.toUpperCase()
                    )}
                  </div>
                  <div className="overflow-hidden">
                    <div className="font-medium text-sm truncate">{mod.curator?.fullName || mod.email}</div>
                    <div className="text-xs text-zinc-500 truncate">{mod.curator?.specialization || "Куратор"}</div>
                    
                    {/* Реальный индикатор на основе той же логики, что и в деталях */}
                    {Math.floor(getModeratorStudents(mod.id).length / 3) > 0 && (
                         <div className="flex items-center gap-1 mt-1">
                             <span className="w-2 h-2 rounded-full bg-yellow-500"></span>
                             <span className="text-[10px] text-zinc-400">Есть задачи</span>
                         </div>
                     )}
                  </div>
                </button>
              </li>
            ))}
          </ul>
        </div>

        {/* Профиль и студенты */}
        {activeMod ? (
          <div className="flex flex-col gap-4 overflow-y-auto pr-1">
            {/* Резюме */}
            <div className="card p-6">
              <div className="flex justify-between items-start mb-6">
                <div className="flex gap-4 items-center">
                  <div className="w-16 h-16 rounded-full overflow-hidden bg-zinc-200 dark:bg-zinc-700 flex items-center justify-center">
                    {activeMod.curator?.avatarUrl ? (
                      <img 
                        src={activeMod.curator.avatarUrl} 
                        alt="Avatar" 
                        className="w-full h-full object-cover" 
                      />
                    ) : (
                      <div className="text-2xl text-zinc-500 font-bold">
                        {activeMod.curator?.fullName?.[0]?.toUpperCase() || activeMod.email[0]?.toUpperCase()}
                      </div>
                    )}
                  </div>
                  <div>
                    <h2 className="text-xl font-bold">{activeMod.curator?.fullName || "Без имени"}</h2>
                    <p className="text-zinc-500 text-sm">{activeMod.email}</p>
                    <span className={`inline-flex items-center px-2 py-0.5 rounded text-xs font-medium mt-1 ${activeMod.isActive ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`}>
                      {activeMod.isActive ? 'Активен' : 'Отключен'}
                    </span>
                  </div>
                </div>
                <button 
                    onClick={() => { setModalMode('edit'); setIsModalOpen(true); }}
                    className="btn border border-zinc-300 dark:border-zinc-700 text-xs"
                >
                    Редактировать
                </button>
              </div>
              
              {/* Табы */}
              <div className="flex border-b border-zinc-200 dark:border-zinc-700 mb-4">
                  <button 
                    onClick={() => setActiveTab('info')}
                    className={`px-4 py-2 text-sm font-medium border-b-2 transition ${activeTab === 'info' ? 'border-black dark:border-white text-black dark:text-white' : 'border-transparent text-zinc-500 hover:text-zinc-700'}`}
                  >
                    Инфо / Статистика
                  </button>
                  <button 
                    onClick={() => setActiveTab('calendar')}
                    className={`px-4 py-2 text-sm font-medium border-b-2 transition ${activeTab === 'calendar' ? 'border-black dark:border-white text-black dark:text-white' : 'border-transparent text-zinc-500 hover:text-zinc-700'}`}
                  >
                    Календарь
                  </button>
                  <button 
                    onClick={() => setActiveTab('tasks')}
                    className={`px-4 py-2 text-sm font-medium border-b-2 transition ${activeTab === 'tasks' ? 'border-black dark:border-white text-black dark:text-white' : 'border-transparent text-zinc-500 hover:text-zinc-700'}`}
                  >
                    Задачи ({moderatorStats.pendingReviews})
                  </button>
              </div>

              {/* Контент табов */}
              <div className="min-h-[300px]">
                {activeTab === 'info' && (
                    <div className="space-y-6">
                         <div className="grid grid-cols-3 gap-4">
                            <div className="bg-zinc-50 dark:bg-zinc-800 p-3 rounded-xl text-center">
                                <div className="text-2xl font-bold">{moderatorStats.studentsCount}</div>
                                <div className="text-xs text-zinc-500">Студентов</div>
                            </div>
                            <div className="bg-zinc-50 dark:bg-zinc-800 p-3 rounded-xl text-center">
                                <div className="text-2xl font-bold text-yellow-600">{moderatorStats.totalXP}</div>
                                <div className="text-xs text-zinc-500">Общий XP</div>
                            </div>
                             <div className="bg-zinc-50 dark:bg-zinc-800 p-3 rounded-xl text-center">
                                <div className="text-2xl font-bold text-blue-600">{moderatorStats.pendingReviews}</div>
                                <div className="text-xs text-zinc-500">На проверке</div>
                            </div>
                         </div>

                         <div>
                            <div className="flex justify-between items-center mb-3">
                                <h3 className="font-semibold text-sm">Список студентов</h3>
                                <button 
                                    onClick={() => setIsBindModalOpen(true)}
                                    className="text-xs text-blue-500 hover:underline"
                                >+ Привязать</button>
                            </div>
                            <div className="space-y-2">
                                {linkedStudents.map(s => {
                                     const country = countries.find((c: any) => c.id === s.countryId);
                                     return (
                                        <Link 
                                            key={s.id} 
                                            href={`/curator/students?studentId=${s.id}`}
                                            className="block p-3 rounded-xl border border-zinc-200 dark:border-zinc-700 bg-white dark:bg-zinc-800/50 hover:border-blue-500 hover:shadow-md transition group"
                                        >
                                            <div className="flex justify-between items-center">
                                                <span className="font-medium text-sm text-zinc-800 dark:text-zinc-200 group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-colors">{s.fullName}</span>
                                                <span className="text-lg" title={country?.name}>{country?.flag_icon}</span>
                                            </div>
                                            <div className="flex justify-between items-center mt-2">
                                                <div className="text-[10px] text-zinc-400">XP: <span className="text-zinc-600 dark:text-zinc-300 font-bold">{s.xpTotal}</span></div>
                                                <div className="text-[10px] text-blue-500 opacity-0 group-hover:opacity-100 transition-opacity flex items-center gap-1">
                                                    Перейти к досье <span>→</span>
                                                </div>
                                            </div>
                                        </Link>
                                     )
                                })}
                                {linkedStudents.length === 0 && (
                                    <div className="text-center py-6 text-zinc-500 text-sm italic border border-dashed border-zinc-200 dark:border-zinc-800 rounded-xl">
                                        Нет привязанных студентов
                                    </div>
                                )}
                            </div>
                         </div>
                    </div>
                )}

                {activeTab === 'calendar' && (
                    <div>
                        <p className="text-xs text-zinc-500 mb-2">Дедлайны студентов этого куратора:</p>
                        <Calendar events={moderatorEvents} />
                    </div>
                )}

                {activeTab === 'tasks' && (
                    <div>
                        <h3 className="font-semibold text-sm mb-3">Очередь на проверку</h3>
                        {moderatorReviewTasks.length > 0 ? (
                            <ul className="space-y-2">
                                {moderatorReviewTasks.map(task => (
                                    <li key={task.id} className="p-3 bg-zinc-50 dark:bg-zinc-800 rounded-lg flex justify-between items-center">
                                        <div>
                                            <div className="font-medium text-sm">{task.title}</div>
                                            <div className="text-xs text-zinc-500">Студент: {task.studentName}</div>
                                        </div>
                                        <button className="btn bg-white dark:bg-black border border-zinc-200 dark:border-zinc-700 text-xs py-1 px-3">
                                            Проверить
                                        </button>
                                    </li>
                                ))}
                            </ul>
                        ) : (
                            <p className="text-center text-zinc-500 py-8">Очередь пуста 🎉</p>
                        )}
                    </div>
                )}
              </div>
            </div>

          </div>
        ) : (
          <div className="flex items-center justify-center text-zinc-400">Выберите модератора</div>
        )}
      </div>

      {isBindModalOpen && activeMod && (
        <BindStudentModal 
            moderatorId={activeMod.id}
            onClose={() => setIsBindModalOpen(false)}
            onSuccess={fetchModerators}
        />
      )}

      {isModalOpen && (
        <ModeratorModal 
            moderator={modalMode === 'edit' ? activeMod : null}
            onClose={() => setIsModalOpen(false)}
            onSave={handleSaveModerator}
            onDelete={handleDeleteModerator}
        />
      )}
    </div>
  );
}
--- END FILE: apps/web/app/curator/admin/moderators/page.tsx ---

--- BEGIN FILE: apps/web/app/curator/calendar/page.tsx ---
"use client";
import allStudents from "@/mock/students.json";
import allQuestTemplates from "@/mock/quest_templates.json";
import allPrograms from "@/mock/programs.json";
import { useMemo } from "react";
import Calendar, { CalendarEvent } from "@/shared/Calendar";

export default function CuratorCalendarPage() {

  const allEvents = useMemo(() => {
    const events: CalendarEvent[] = [];

    // Собираем дедлайны по квестам для каждого студента
    allStudents.forEach(student => {
        // В реальном приложении здесь нужно будет брать назначенные квесты
        // Для мока, возьмем несколько случайных квестов
        const assignedQuestIds = [1, 10, 11, 20, 21].filter(() => Math.random() > 0.5);
        
        assignedQuestIds.forEach(questId => {
            const quest = allQuestTemplates.find(q => q.id === questId);
            if (quest && quest.deadline) {
                events.push({
                    date: quest.deadline,
                    title: `${quest.title} (${student.name})`,
                    type: 'quest'
                });
            }
        });

        // Добавляем дедлайны по программам
        student.selected_program_ids.forEach(progId => {
            const program = allPrograms.find(p => p.id === progId);
            if (program && program.deadline) {
                events.push({
                    date: program.deadline,
                    title: `Подача: ${program.title.substring(0, 15)}... (${student.name})`,
                    type: 'program'
                });
            }
        });
    });

    return events;
  }, []);

  return (
    <div>
      <h1 className="text-2xl font-semibold mb-2">Календарь Дедлайнов</h1>
      <p className="text-zinc-400 text-sm mb-6">Обзор всех дедлайнов по студентам.</p>
      <Calendar events={allEvents} />
    </div>
  );
}
--- END FILE: apps/web/app/curator/calendar/page.tsx ---

--- BEGIN FILE: apps/web/app/curator/dashboard/page.tsx ---
"use client";
import Link from "next/link";
import allStudents from "@/mock/students.json";
import allProgress from "@/mock/student_progress.json";
import allQuests from "@/mock/quest_templates.json";
import allCountries from "@/mock/countries.json";
import { useMemo } from "react";

type StudentProgress = { [key: number]: { status: string } };

export default function CuratorDashboard() {

  const studentData = useMemo(() => {
    return allStudents.map(student => {
      const country = allCountries.find(c => c.id === student.country_id);
      if (!country) return { ...student, totalQuests: 0, completedQuests: 0, progressPercentage: 0, alerts: [], flag: '', countryName: '' };

      const requiredQuests = new Set(country.required_quest_ids);
      const studentProgress: StudentProgress = (allProgress as any)[student.id] || {};

      const completedQuests = Object.keys(studentProgress)
        .map(Number)
        .filter(questId => requiredQuests.has(questId) && studentProgress[questId].status === 'done');

      const onReviewQuests = Object.keys(studentProgress)
        .map(Number)
        .filter(questId => requiredQuests.has(questId) && studentProgress[questId].status === 'review');

      const progressPercentage = requiredQuests.size > 0 ? (completedQuests.length / requiredQuests.size) * 100 : 0;

      // Формируем "красные флаги"
      const alerts = [];
      if (onReviewQuests.length > 0) {
        alerts.push({ type: 'review', text: `На проверке: ${onReviewQuests.length} квеста` });
      }
      if (progressPercentage < 30) {
        alerts.push({ type: 'warning', text: 'Низкий прогресс' });
      }

      return {
        ...student,
        countryName: country.name,
        flag: country.flag_icon,
        totalQuests: requiredQuests.size,
        completedQuests: completedQuests.length,
        progressPercentage,
        alerts
      };
    });
  }, []);

  return (
    <div>
      <h1 className="text-2xl font-semibold">Панель Студентов</h1>
      <p className="text-zinc-600 dark:text-zinc-300 mb-6">Обзор прогресса всех активных студентов.</p>

      <div className="space-y-4">
        {studentData.map(student => (
          <Link key={student.id} href={`/curator/student/${student.id}`} className="card block p-4 hover:bg-black/5 dark:hover:bg-white/5 transition">
            <div className="flex items-center justify-between">
              <div>
                <div className="font-semibold">{student.name}</div>
                <div className="text-sm text-zinc-500">{student.flag} {student.countryName}</div>
              </div>
              <div className="flex items-center gap-4">
                <div className="text-right">
                  <div className="font-medium text-sm">Прогресс</div>
                  <div className="text-xs text-zinc-500">{student.completedQuests} / {student.totalQuests} квестов</div>
                </div>
                <div className="w-24">
                  <div className="w-full bg-zinc-200 dark:bg-zinc-700 rounded-full h-2">
                    <div className="bg-blue-600 h-2 rounded-full" style={{ width: `${student.progressPercentage}%` }}></div>
                  </div>
                </div>
              </div>
            </div>
            {student.alerts.length > 0 && (
              <div className="mt-3 flex items-center gap-2 border-t pt-2">
                {student.alerts.map((alert, index) => (
                  <span key={index} className={`text-xs px-2 py-1 rounded-full ${alert.type === 'review' ? 'bg-yellow-500/10 text-yellow-700' : 'bg-red-500/10 text-red-700'}`}>
                    {alert.text}
                  </span>
                ))}
              </div>
            )}
          </Link>
        ))}
      </div>
    </div>
  );
}
--- END FILE: apps/web/app/curator/dashboard/page.tsx ---

--- BEGIN FILE: apps/web/app/curator/layout.tsx ---
"use client";
import { useAuth } from "@/shared/AuthContext";
import Sidebar from "@/shared/Sidebar";
import Navbar from "@/shared/Navbar";
import { useRouter } from "next/navigation";
import { useEffect } from "react";

export default function CuratorLayout({ children }: { children: React.ReactNode }) {
  const { user, loading } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if (!loading && (!user || (user.role !== "curator" && user.role !== "admin"))) {
      router.replace("/login");
    }
  }, [user, loading, router]);

  if (loading || !user) return <div className="min-h-screen bg-zinc-50 dark:bg-black flex items-center justify-center">Проверка доступа...</div>;

  return (
    <div className="min-h-screen bg-zinc-50 dark:bg-black">
      <div className="container py-6">
        <div className="grid grid-cols-1 sm:grid-cols-[16rem_1fr] gap-6">
          <Sidebar />
          <div className="flex flex-col min-w-0">
             <Navbar />
             <main className="card p-4 flex-1">{children}</main>
          </div>
        </div>
      </div>
    </div>
  );
}
--- END FILE: apps/web/app/curator/layout.tsx ---

--- BEGIN FILE: apps/web/app/curator/programs-search/page.tsx ---
"use client";
import { useState, useEffect } from "react";
import { useCountry } from "@/shared/CountryContext";

const API_URL = process.env.NEXT_PUBLIC_API_URL ?? "http://localhost:4000/api";

const CATEGORIES = ["IT", "Business", "Engineering", "Arts/Design", "Law", "Medicine", "Science", "Humanities"];

export default function ProgramsSearchPage() {
  const { countries, universities } = useCountry();
  
  const [filterCountry, setFilterCountry] = useState("");
  const [filterUniversity, setFilterUniversity] = useState("");
  const [filterCategory, setFilterCategory] = useState(""); // <--- Новый фильтр
  const [searchQuery, setSearchQuery] = useState("");
  const [results, setResults] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    const fetchPrograms = async () => {
        setLoading(true);
        const params = new URLSearchParams();
        if (filterCountry) params.append("countryId", filterCountry);
        if (filterUniversity) params.append("universityId", filterUniversity);
        if (filterCategory) params.append("category", filterCategory); // <--- Отправка на бэк
        if (searchQuery) params.append("search", searchQuery);

        const token = localStorage.getItem("accessToken");
        try {
            const res = await fetch(`${API_URL}/admin/programs/search?${params.toString()}`, {
                headers: { Authorization: `Bearer ${token}` }
            });
            if (res.ok) {
                setResults(await res.json());
            }
        } catch(e) {
            console.error(e);
        } finally {
            setLoading(false);
        }
    };
    
    const timer = setTimeout(fetchPrograms, 300);
    return () => clearTimeout(timer);
  }, [filterCountry, filterUniversity, filterCategory, searchQuery]);

  return (
    <div>
      <h1 className="text-2xl font-semibold mb-4">Поиск образовательных программ</h1>
      
      {/* Filters */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6 bg-zinc-50 dark:bg-zinc-800 p-4 rounded-xl border border-zinc-200 dark:border-zinc-700">
        <div>
            <label className="text-xs text-zinc-500 block mb-1">Страна</label>
            <select 
                className="w-full p-2 rounded-lg bg-white dark:bg-zinc-900 border border-zinc-300 dark:border-zinc-600 text-sm"
                value={filterCountry}
                onChange={(e) => { setFilterCountry(e.target.value); setFilterUniversity(""); }}
            >
                <option value="">Все страны</option>
                {countries.map(c => <option key={c.id} value={c.id}>{c.flag_icon} {c.name}</option>)}
            </select>
        </div>
        <div>
            <label className="text-xs text-zinc-500 block mb-1">Университет</label>
            <select 
                className="w-full p-2 rounded-lg bg-white dark:bg-zinc-900 border border-zinc-300 dark:border-zinc-600 text-sm"
                value={filterUniversity}
                onChange={(e) => setFilterUniversity(e.target.value)}
                disabled={!filterCountry}
            >
                <option value="">Все университеты</option>
                {universities
                    .filter(u => !filterCountry || u.countryId === filterCountry)
                    .map(u => <option key={u.id} value={u.id}>{u.name}</option>)
                }
            </select>
        </div>
        <div>
            <label className="text-xs text-zinc-500 block mb-1">Категория</label>
            <select 
                className="w-full p-2 rounded-lg bg-white dark:bg-zinc-900 border border-zinc-300 dark:border-zinc-600 text-sm"
                value={filterCategory}
                onChange={(e) => setFilterCategory(e.target.value)}
            >
                <option value="">Все категории</option>
                {CATEGORIES.map(cat => <option key={cat} value={cat}>{cat}</option>)}
            </select>
        </div>
        <div>
             <label className="text-xs text-zinc-500 block mb-1">Поиск</label>
             <input 
                type="text"
                placeholder="Название..."
                className="w-full p-2 rounded-lg bg-white dark:bg-zinc-900 border border-zinc-300 dark:border-zinc-600 text-sm"
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
             />
        </div>
      </div>

      {/* Results */}
      <div className="space-y-3">
         {loading ? (
             <div className="text-center text-zinc-500 py-10">Поиск...</div>
         ) : results.length === 0 ? (
             <div className="text-center text-zinc-500 py-10">Программы не найдены</div>
         ) : (
             results.map((prog) => (
                 <div key={prog.id} className="card p-4 hover:shadow-md transition border border-zinc-100 dark:border-zinc-800">
                    <div className="flex justify-between items-start">
                        <div>
                            <div className="flex items-center gap-2 mb-1">
                                <span className="text-xl">{prog.university?.country?.flagIcon}</span>
                                <span className="text-xs font-bold text-zinc-500 uppercase">{prog.university?.name}</span>
                                {prog.category && (
                                    <span className="text-[10px] bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300 px-2 py-0.5 rounded-full ml-2">
                                        {prog.category}
                                    </span>
                                )}
                            </div>
                            <h3 className="text-lg font-bold">{prog.title}</h3>
                            <div className="flex gap-4 mt-2 text-sm text-zinc-600 dark:text-zinc-400">
                                <span>📅 Дедлайн: <b>{prog.deadline || "Не указан"}</b></span>
                            </div>
                        </div>
                        {prog.link && (
                            <a 
                                href={prog.link} 
                                target="_blank" 
                                className="btn border border-zinc-200 dark:border-zinc-700 text-sm px-3 py-1"
                            >
                                На сайт ↗
                            </a>
                        )}
                    </div>
                 </div>
             ))
         )}
      </div>
    </div>
  );
}
--- END FILE: apps/web/app/curator/programs-search/page.tsx ---

--- BEGIN FILE: apps/web/app/curator/review/page.tsx ---
"use client";
import { useEffect, useState } from "react";
import { useAuth } from "@/shared/AuthContext";
import { useProgress } from "@/shared/ProgressContext";

type CommentState = Record<number, string>;

// --- НОВОЕ: Иконка для кнопки "Отправить на доработку" ---
const RefreshIcon = () => (
  <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M4 4v5h5M20 20v-5h-5M4 4l1.5 1.5A9 9 0 0120.5 10M20 20l-1.5-1.5A9 9 0 003.5 14" />
  </svg>
);

// --- НОВОЕ: Хелпер для определения, является ли строка именем файла ---
const isFileName = (submission: any): boolean => {
  if (typeof submission !== 'string') return false;
  // Проверяем на наличие популярных расширений файлов
  return /\.(pdf|jpg|jpeg|png|doc|docx)$/i.test(submission);
};

export default function ReviewPage() {
  const { reviewQueue, fetchReviewQueue, approveQuest, requestChanges } = useProgress();
  const [comments, setComments] = useState<CommentState>({});
  const { user } = useAuth();

  useEffect(() => {
      if (user?.role === 'curator' || user?.role === 'admin') {
          fetchReviewQueue();
      }
  }, [user]);

  const handleCommentChange = (questId: number, text: string) => {
    setComments(prev => ({ ...prev, [questId]: text }));
  };

  const handleRequestChanges = async (questId: number) => {
    const comment = comments[questId];
    if (!comment) {
      alert("Пожалуйста, напишите комментарий для студента.");
      return;
    }
    await requestChanges(questId, comment);
    setComments(prev => {
      const updated = { ...prev };
      delete updated[questId];
      return updated;
    });
  };

  return (
    <div>
      <div className="mb-6">
        <h1 className="text-2xl font-semibold">Ревью Задач</h1>
        <p className="text-zinc-600 dark:text-zinc-300">
          Здесь отображаются все задачи студентов, ожидающие вашей проверки.
        </p>
      </div>

      {reviewQueue.length === 0 ? (
        <div className="text-center py-12">
          <div className="text-4xl mb-3">🎉</div>
          <h3 className="font-semibold">Все задачи проверены</h3>
        </div>
      ) : (
        <div className="space-y-6">
          {reviewQueue.map((task: any) => {
            const submission = task.submission;
            return (
              <div key={task.id} className="card p-5 bg-zinc-800/50 border border-zinc-700/50">
                <h3 className="font-semibold text-lg">{task.title}</h3>
                <div className="text-xs text-zinc-400 mb-4">
                  Отправлено: {task.student?.fullName || "Student"}
                </div>

                <div className="bg-zinc-900 rounded-lg p-3 text-sm mb-4">
                  <p className="font-medium text-zinc-400 mb-2">Прикрепленные данные:</p>
                  {isFileName(submission) ? (
                    <div className="flex items-center justify-between">
                        <span className="text-xs break-words font-mono text-zinc-300">{String(submission)}</span>
                    </div>
                  ) : (
                    <pre className="text-xs whitespace-pre-wrap font-mono text-zinc-300"><code>{JSON.stringify(submission, null, 2)}</code></pre>
                  )}
                </div>

                <div>
                  <textarea
                    value={comments[task.id] || ""}
                    onChange={(e) => handleCommentChange(task.id, e.target.value)}
                    className="w-full mt-2 rounded-xl border border-zinc-700 p-3 text-sm bg-zinc-900"
                    rows={2}
                    placeholder="Комментарий..."
                  />
                </div>

                <div className="flex items-center gap-4 mt-4">
                  <button
                    className="flex-1 btn bg-white text-black"
                    onClick={() => approveQuest(task.id)}
                  >
                    <span className="text-green-500">✅</span> Одобрить
                  </button>
                  <button
                    className="flex-1 btn border border-amber-500/50 text-amber-400"
                    onClick={() => handleRequestChanges(task.id)}
                  >
                    <RefreshIcon /> На доработку
                  </button>
                </div>
              </div>
            );
          })}
        </div>
      )}
    </div>
  );
}
--- END FILE: apps/web/app/curator/review/page.tsx ---

--- BEGIN FILE: apps/web/app/curator/student/[studentId]/EditProfileModal.tsx ---
"use client";
import { useState, useEffect } from "react";
import { useCountry, Program } from "@/shared/CountryContext";

const API_URL = process.env.NEXT_PUBLIC_API_URL ?? "http://localhost:4000/api";

type Props = {
  student: any;
  onClose: () => void;
  onSave: (data: any) => void;
};

export default function EditProfileModal({ student, onClose, onSave }: Props) {
  const { countries, universities } = useCountry();
  const [availablePrograms, setAvailablePrograms] = useState<Program[]>([]);
  const [loadingProgs, setLoadingProgs] = useState(false);

  const [formData, setFormData] = useState({
      fullName: student.fullName,
      countryId: student.countryId ? Number(student.countryId) : undefined,
      // ИСПРАВЛЕНИЕ: Добавлен тип (id: any)
      selectedProgramIds: (student.selectedProgramIds || []).map((id: any) => Number(id))
  });

  // Загружаем программы для выбранной страны
  useEffect(() => {
      if (formData.countryId) {
          setLoadingProgs(true);
          const token = localStorage.getItem("accessToken");
          fetch(`${API_URL}/admin/programs/search?countryId=${formData.countryId}`, {
              headers: { Authorization: `Bearer ${token}` }
          })
          .then(res => res.json())
          .then(data => {
              setAvailablePrograms(Array.isArray(data) ? data : []);
          })
          .finally(() => setLoadingProgs(false));
      } else {
          setAvailablePrograms([]);
      }
  }, [formData.countryId]);

  const handleSubmit = (e: React.FormEvent) => {
      e.preventDefault();
      onSave(formData);
  };

  const toggleProgram = (progId: number) => {
      setFormData(prev => {
          const current = new Set(prev.selectedProgramIds);
          if (current.has(progId)) current.delete(progId);
          else current.add(progId);
          return { ...prev, selectedProgramIds: Array.from(current) };
      });
  };

  return (
    <div className="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center p-4 z-50 animate-in fade-in duration-200">
      <div className="w-full max-w-lg bg-zinc-900 border border-zinc-800 rounded-2xl shadow-2xl flex flex-col max-h-[90vh]">
        
        <div className="p-6 border-b border-zinc-800 flex justify-between items-center">
            <h2 className="text-xl font-bold">Настройка профиля</h2>
            <button onClick={onClose} className="text-zinc-500 hover:text-white transition text-2xl">&times;</button>
        </div>

        <div className="flex-1 overflow-y-auto p-6 space-y-6">
            <form id="edit-student-form" onSubmit={handleSubmit} className="space-y-4">
                <div>
                    <label className="text-xs text-zinc-400 font-medium ml-1">ФИО Студента</label>
                    <input 
                        value={formData.fullName} 
                        onChange={e => setFormData({...formData, fullName: e.target.value})}
                        className="w-full mt-1 p-3 rounded-xl bg-zinc-800 border border-zinc-700 text-sm focus:border-blue-500 focus:outline-none"
                    />
                </div>
                
                <div>
                    <label className="text-xs text-zinc-400 font-medium ml-1">Страна поступления</label>
                    <select 
                        value={formData.countryId || ''}
                        onChange={e => setFormData({
                            ...formData, 
                            countryId: e.target.value ? Number(e.target.value) : undefined,
                            selectedProgramIds: [] // Сброс программ при смене страны
                        })}
                        className="w-full mt-1 p-3 rounded-xl bg-zinc-800 border border-zinc-700 text-sm focus:border-blue-500 focus:outline-none"
                    >
                        {countries.map(c => <option key={c.id} value={c.id}>{c.flag_icon} {c.name}</option>)}
                    </select>
                </div>

                <div>
                    <label className="text-xs text-zinc-400 font-medium ml-1 mb-2 block">
                        Целевые программы {loadingProgs && <span className="animate-pulse ml-2">Загрузка...</span>}
                    </label>
                    
                    <div className="space-y-2 max-h-60 overflow-y-auto pr-2 custom-scrollbar">
                        {availablePrograms.length > 0 ? availablePrograms.map(prog => {
                             const uniName = universities.find(u => u.id === prog.university_id || u.id === (prog as any).university?.id)?.name || "ВУЗ";
                             const isSelected = formData.selectedProgramIds.includes(prog.id);
                             
                             return (
                                <div 
                                    key={prog.id} 
                                    onClick={() => toggleProgram(prog.id)}
                                    className={`p-3 rounded-xl border cursor-pointer transition flex items-start gap-3 ${
                                        isSelected 
                                        ? 'bg-blue-900/20 border-blue-500/50' 
                                        : 'bg-zinc-800/50 border-zinc-700 hover:border-zinc-500'
                                    }`}
                                >
                                    <div className={`mt-0.5 w-5 h-5 rounded border flex items-center justify-center shrink-0 ${isSelected ? 'bg-blue-600 border-blue-600' : 'border-zinc-600'}`}>
                                        {isSelected && <span className="text-xs text-white">✓</span>}
                                    </div>
                                    <div>
                                        <div className={`font-medium text-sm ${isSelected ? 'text-blue-100' : 'text-zinc-300'}`}>{prog.title}</div>
                                        <div className="text-xs text-zinc-500 mt-0.5">{uniName}</div>
                                    </div>
                                </div>
                             );
                        }) : (
                            <div className="text-center py-4 text-zinc-500 text-sm bg-zinc-800/30 rounded-xl border border-dashed border-zinc-700">
                                Программы для этой страны не найдены
                            </div>
                        )}
                    </div>
                    <p className="text-[10px] text-zinc-500 mt-2 ml-1">
                        * При добавлении программы студенту автоматически назначатся её специфические задачи.
                    </p>
                </div>
            </form>
        </div>

        <div className="p-6 border-t border-zinc-800 bg-zinc-900/50 flex justify-end gap-3">
            <button type="button" onClick={onClose} className="btn bg-zinc-800 text-zinc-300 hover:bg-zinc-700">Отмена</button>
            <button type="submit" form="edit-student-form" className="btn btn-primary">Сохранить изменения</button>
        </div>
      </div>
    </div>
  );
}
--- END FILE: apps/web/app/curator/student/[studentId]/EditProfileModal.tsx ---

--- BEGIN FILE: apps/web/app/curator/student/[studentId]/page.tsx ---
"use client";
import { useMemo, useEffect, useState } from "react";
import { useParams } from "next/navigation";
import { useCountry } from "@/shared/CountryContext";
import EditProfileModal from "./EditProfileModal";

const API_URL = process.env.NEXT_PUBLIC_API_URL ?? "http://localhost:4000/api";

export default function StudentDossierPage() {
  const params = useParams();
  const studentId = params.studentId as string;
  
  const { countries, quests: allQuests, programs: allPrograms } = useCountry();
  const [student, setStudent] = useState<any>(null);
  const [tasks, setTasks] = useState<any[]>([]);
  const [isEditOpen, setIsEditOpen] = useState(false);
  const [isTaskModalOpen, setIsTaskModalOpen] = useState(false); // Для модалки новой задачи
  const [loading, setLoading] = useState(true);
  
  // Mock binding code (в реальности придет с API в объекте student)
  const bindingCode = student?.bindingCode || `S-${Math.floor(1000 + Math.random() * 9000)}`;

  const fetchStudentData = async () => {
      const token = localStorage.getItem("accessToken");
      try {
        // 1. Получаем профиль студента (через эндпоинт пользователя или students/:id)
        // В MVP мы добавили students/:id
        const resS = await fetch(`${API_URL}/students/${studentId}`, { headers: { Authorization: `Bearer ${token}` }});
        const sData = await resS.json();
        // Мокаем binding code, если его нет
        setStudent({ ...sData, bindingCode: sData.bindingCode || "S-4291" });

        // 2. Получаем задачи (через админку пока нет эндпоинта "получить задачи конкретного юзера", 
        // но в TasksService есть findAllForUser. 
        // Для MVP используем заглушку или добавим эндпоинт в TasksController)
        // *Временное решение:* покажем просто список, если есть доступ, или заглушку.
        // В коде выше мы не добавили эндпоинт для куратора, чтобы смотреть задачи конкретного студента.
        // Допустим, мы используем mock или добавим в TasksController позже.
      } catch(e) { console.error(e); } finally { setLoading(false); }
  };

  useEffect(() => { fetchStudentData(); }, []);

  // Мок создания задачи (Ad-hoc)
  const handleCreateAdHocTask = async (taskTitle: string) => {
      // Тут будет POST /tasks с studentId
      alert(`Задача "${taskTitle}" назначена студенту (Mock)`);
      setIsTaskModalOpen(false);
  };

  const country = useMemo(() => countries.find(c => c.id === student?.countryId), [student, countries]);

  if (loading) return <div>Загрузка...</div>;
  if (!student || !country) {
    return <div>Студент не найден.</div>;
  }

  // Mock quests filter (в реальности данные придут с бэка)
  const requiredQuests = allQuests; // Пока показываем все шаблоны как пример

  // Вычисляем программы из контекста useCountry (так как мы уже их загрузили там)
  const selectedProgramsData = useMemo(() => {
    if (!student?.selectedProgramIds) return [];
    return (allPrograms || []).filter(p => student.selectedProgramIds.includes(p.id));
  }, [student, allPrograms]);

  const handleResetPassword = async () => {
      if(!confirm("Сбросить пароль студента на '12345678'?")) return;
      const token = localStorage.getItem("accessToken");
      await fetch(`${API_URL}/admin/users/${student.user.id}/reset-password`, {
          method: "PATCH",
          headers: { Authorization: `Bearer ${token}`, "Content-Type": "application/json" }
      });
      alert("Пароль сброшен");
  };

  const handleUpdateProfile = async (data: any) => {
      const token = localStorage.getItem("accessToken");
      await fetch(`${API_URL}/students/${student.id}`, {
          method: "PATCH",
          headers: { Authorization: `Bearer ${token}`, "Content-Type": "application/json" },
          body: JSON.stringify(data)
      });
      setIsEditOpen(false);
      fetchStudentData();
  };

  const approveQuest = (questId: number) => {
    // ... (оставим как есть заглушку или подключим API)
    alert(`(Mock) Квест #${questId} для студента ${student.fullName} одобрен.`);
  };

  const rejectQuest = (questId: number) => { /* ... */ };

  return (
    <div>
      <div className="mb-6 flex justify-between items-center">
        <div>
          <h1 className="text-2xl font-semibold">{student.fullName}</h1>
          <p className="text-zinc-500">Досье студента | Операция: {country.flag_icon} {country.name}</p>
        </div>
        <div className="flex gap-2">
            <button onClick={() => setIsEditOpen(true)} className="btn bg-zinc-200 text-black text-sm">Ред. профиль</button>
            <button onClick={handleResetPassword} className="btn bg-red-100 text-red-700 text-sm">Сброс пароля</button>
        </div>
      </div>

      {/* Блок Telegram и быстрых действий */}
      <div className="grid md:grid-cols-2 gap-4 mb-6">
        <div className="card p-4 flex items-center justify-between bg-blue-50 dark:bg-blue-900/10 border-blue-100 dark:border-blue-900">
            <div>
                <div className="text-xs text-blue-600 dark:text-blue-400 font-bold uppercase">Telegram Binding</div>
                <div className="text-2xl font-mono font-bold tracking-wider mt-1">{bindingCode}</div>
                <div className="text-xs text-zinc-500 mt-1">Команда: <code>/link {bindingCode}</code></div>
            </div>
            <div className="text-3xl">🤖</div>
        </div>
        <div className="card p-4 flex items-center justify-between">
             <div>
                <div className="font-semibold">Индивидуальная задача</div>
                <div className="text-xs text-zinc-500">Назначить задачу вне общего плана</div>
            </div>
            <button onClick={() => setIsTaskModalOpen(true)} className="btn btn-primary text-sm">+ Задача</button>
        </div>
      </div>

      {/* Блок целевых программ */}
      <div className="mb-8">
        <h2 className="text-lg font-semibold mb-3">Целевые программы</h2>
        {selectedProgramsData.length > 0 ? (
          <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
            {selectedProgramsData.map(prog => (
              <div key={prog.id} className="p-3 bg-zinc-50 dark:bg-zinc-800/50 border border-zinc-200 dark:border-zinc-700/50 rounded-xl flex items-center justify-between">
                <div>
                  <div className="font-medium text-sm">{prog.title}</div>
                  <div className="text-xs text-zinc-500">Дедлайн: {prog.deadline || "—"}</div>
                </div>
                {/* Если есть университет в объекте, можно вывести лого */}
              </div>
            ))}
          </div>
        ) : (
          <p className="text-sm text-zinc-500 italic">Программы не выбраны.</p>
        )}
      </div>

      <div className="grid lg:grid-cols-3 gap-6">
        {/* ... остальной код рендера задач ... */}
      </div>
      
      {isEditOpen && (
          <EditProfileModal student={student} onClose={() => setIsEditOpen(false)} onSave={handleUpdateProfile} />
      )}
      
      {/* Простая модалка создания задачи (инлайн) */}
      {isTaskModalOpen && (
        <div className="fixed inset-0 bg-black/60 flex items-center justify-center p-4 z-50">
            <div className="card p-6 w-full max-w-md">
                <h3 className="font-bold mb-4">Новая задача</h3>
                <form onSubmit={(e) => {
                    e.preventDefault();
                    const formData = new FormData(e.currentTarget);
                    handleCreateAdHocTask(formData.get('title') as string);
                }}>
                    <label className="block text-sm mb-1">Название задачи</label>
                    <input name="title" required className="w-full p-2 border rounded-lg bg-zinc-50 dark:bg-zinc-800 mb-4" placeholder="Напр: Переделать справку" />
                    
                    <label className="block text-sm mb-1">Описание (опционально)</label>
                    <textarea name="desc" className="w-full p-2 border rounded-lg bg-zinc-50 dark:bg-zinc-800 mb-4" rows={3} />
                    
                    <div className="flex justify-end gap-2">
                        <button type="button" onClick={() => setIsTaskModalOpen(false)} className="btn">Отмена</button>
                        <button type="submit" className="btn btn-primary">Назначить</button>
                    </div>
                </form>
            </div>
        </div>
      )}
    </div>
  );
}
--- END FILE: apps/web/app/curator/student/[studentId]/page.tsx ---

--- BEGIN FILE: apps/web/app/curator/students/StudentModal.tsx ---
"use client";
import { useState, useEffect } from "react";
import { useCountry } from "@/shared/CountryContext";
import { useAuth } from "@/shared/AuthContext";

export type StudentFull = {
  id: string;
  fullName: string;
  email: string;
  countryId: string;
  xpTotal: number;
  password?: string; // <--- Добавили
  isActive: boolean;
  bindingCode: string;
  curatorId?: string; // Новое поле
  curatorName?: string; // Новое поле
};

type Props = {
  student?: StudentFull | null;
  onClose: () => void;
  onSave: (data: Partial<StudentFull>) => Promise<void>;
  onDelete?: (id: string) => Promise<void>; // <--- NEW
};

const API_URL = process.env.NEXT_PUBLIC_API_URL ?? "http://localhost:4000/api";

export default function StudentModal({ student, onClose, onSave, onDelete }: Props) {
  const { countries } = useCountry();
  const { user } = useAuth();
  const isAdmin = user?.role === 'admin';
  const isEdit = !!student;

  // Куратор может редактировать своих, админ всех.
  // Упростим: дадим редактировать, если это админ или если это создание.
  // Или просто разрешим редактировать поля.
  const isViewOnly = !isAdmin && isEdit && student?.curatorId !== user?.curatorId;

  const [fullName, setFullName] = useState(student?.fullName || "");
  const [email, setEmail] = useState(student?.email || "");
  const [password, setPassword] = useState(student?.password || ""); // <--- State для пароля
  const [showPassword, setShowPassword] = useState(false); // <--- Глаз
  const [countryId, setCountryId] = useState(student?.countryId || countries[0]?.id || "");
  const [isActive, setIsActive] = useState(student?.isActive ?? true);
  const [curatorId, setCuratorId] = useState(student?.curatorId || "");

  const [curators, setCurators] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);

  // Загружаем список кураторов для дропдауна
  useEffect(() => {
    const fetchCurators = async () => {
      const token = localStorage.getItem("accessToken");
      try {
        const res = await fetch(`${API_URL}/admin/moderators`, {
          headers: { Authorization: `Bearer ${token}` }
        });
        if (res.ok) {
          const data = await res.json();
          setCurators(data.curators);
        }
      } catch (e) { console.error(e); }
    };
    fetchCurators();
  }, []);

  useEffect(() => {
    if (student) {
      setFullName(student.fullName);
      setEmail(student.email);
      setPassword(student.password || ""); // <--- Заполняем при редактировании
      setCountryId(student.countryId || ""); // FIX: Ensure it's not null
      setIsActive(student.isActive ?? true);
      setCuratorId(student.curatorId || "");
    } else {
      setFullName("");
      setEmail("");
      setPassword(""); // Можно сгенерировать дефолтный: Math.random().toString(36).slice(-8)
      setCountryId(countries[0]?.id || "");
      setIsActive(true);
      // Если создает куратор, ставим его сразу
      if (user?.role === 'curator' && user.curatorId) {
        setCuratorId(user.curatorId);
      } else {
        setCuratorId("");
      }
    }
  }, [student, countries, user]);

  const handleSubmit = async (e?: React.FormEvent) => {
    if (e) e.preventDefault();
    setLoading(true);

    const data: Partial<StudentFull> & { password?: string } = {
      fullName,
      email,
      password: password || undefined, // Отправляем, только если не пустой (для новых обязателен на бэке)
      countryId,
      isActive,
      curatorId: curatorId === "" ? undefined : curatorId,
    };

    if (isEdit) {
      data.id = student!.id;
    }

    try {
      await onSave(data);
      onClose();
    } catch (error) {
      console.error(error);
      alert("Ошибка при сохранении");
    } finally {
      setLoading(false);
    }
  };

  const inputClass = "w-full p-2 border rounded bg-white dark:bg-zinc-800 border-zinc-300 dark:border-zinc-700 disabled:opacity-50";

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-50" onClick={onClose}>
      <div className="bg-white dark:bg-zinc-900 p-6 rounded-lg max-w-md w-full max-h-[90vh] overflow-y-auto shadow-xl" onClick={e => e.stopPropagation()}>
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-bold">
            {isEdit ? "Редактировать студента" : "Новый студент"}
          </h2>
          <button onClick={onClose} className="text-2xl text-zinc-500">&times;</button>
        </div>
        <form onSubmit={handleSubmit}>
          <div className="space-y-4">
            <div>
              <label className="block text-xs text-zinc-500 mb-1">Полное имя</label>
              <input
                type="text"
                value={fullName}
                onChange={(e) => setFullName(e.target.value)}
                required
                className={inputClass}
              />
            </div>
            <div className="grid grid-cols-2 gap-4">
              <div>
                <label className="block text-xs text-zinc-500 mb-1">Email (Логин)</label>
                <input
                  type="email"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  required
                  className={inputClass}
                />
              </div>
              <div className="relative">
                <label className="block text-xs text-zinc-500 mb-1">Пароль</label>
                <input
                  type={showPassword ? "text" : "password"}
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  className={`${inputClass} pr-10 font-mono`} // Added padding-right and font-mono
                  placeholder={!isEdit ? "Обязательно" : "Пароль скрыт"} // Changed placeholder
                  required={!isEdit}
                />
                <button
                  type="button"
                  onClick={() => setShowPassword(!showPassword)}
                  className="absolute right-3 top-7 text-xs text-zinc-400 hover:text-zinc-600"
                >
                  {showPassword ? "🙈" : "👁️"}
                </button>
                <button
                  type="button"
                  onClick={() => {
                    const pwd = Math.random().toString(36).slice(-8);
                    setPassword(pwd);
                    setShowPassword(true);
                  }}
                  className="absolute right-9 top-7 text-xs text-zinc-400 hover:text-zinc-600 transform active:scale-95 transition-transform"
                  title="Сгенерировать пароль"
                >
                  🎲
                </button>
              </div>
            </div>

            <div className="grid grid-cols-2 gap-4">
              <div>
                <label className="block text-xs text-zinc-500 mb-1">Страна</label>
                <select
                  value={countryId}
                  onChange={(e) => setCountryId(e.target.value)}
                  className={inputClass}
                >
                  {countries.map((c) => (
                    <option key={c.id} value={c.id}>
                      {c.flag_icon} {c.name}
                    </option>
                  ))}
                </select>
              </div>
              <div>
                <label className="block text-xs text-zinc-500 mb-1">Куратор</label>
                <select
                  value={curatorId}
                  onChange={(e) => setCuratorId(e.target.value)}
                  className={inputClass}
                >
                  <option value="">-- Нет --</option>
                  {curators.map((c) => (
                    <option key={c.id} value={c.curator?.id}>
                      {c.curator?.fullName || c.email}
                    </option>
                  ))}
                </select>
              </div>
            </div>

            <div className="flex items-center pt-2">
              <input
                type="checkbox"
                id="isActive"
                checked={isActive}
                onChange={(e) => setIsActive(e.target.checked)}
                className="mr-2 w-4 h-4"
              />
              <label htmlFor="isActive" className="text-sm">Активный аккаунт</label>
            </div>
          </div>

          <div className="flex justify-between mt-6">
            {/* Кнопка удаления (только если редактирование и есть функция) */}
            {isEdit && student && onDelete ? (
              <button
                type="button"
                onClick={async () => {
                  if (confirm("Удалить студента и все его данные безвозвратно?")) {
                    await onDelete(student.id);
                    onClose();
                  }
                }}
                className="px-4 py-2 bg-red-100 text-red-700 hover:bg-red-200 rounded text-sm"
              >
                Удалить
              </button>
            ) : <div></div>}

            <div className="flex gap-2">
              <button
                type="button"
                onClick={onClose}
                className="px-4 py-2 border rounded text-sm hover:bg-zinc-50 dark:hover:bg-zinc-800"
                disabled={loading}
              >
                Отмена
              </button>
              <button
                type="submit"
                className="px-4 py-2 bg-blue-600 text-white rounded text-sm hover:bg-blue-700 disabled:opacity-50"
                disabled={loading}
              >
                {loading ? "Сохранение..." : isEdit ? "Сохранить" : "Создать"}
              </button>
            </div>
          </div>
        </form>
      </div>
    </div>
  );
}
--- END FILE: apps/web/app/curator/students/StudentModal.tsx ---

--- BEGIN FILE: apps/web/app/curator/students/page.tsx ---
"use client";
import { useEffect, useState, useMemo } from "react";
import { useSearchParams } from "next/navigation";
import { useCountry } from "@/shared/CountryContext";
import { useAuth } from "@/shared/AuthContext";
import StudentModal, { StudentFull } from "./StudentModal";
import Avatar from "@/shared/Avatar";
import QuestDetailModal from "@/app/student/quests/QuestDetailModal";
import Calendar from "@/shared/Calendar";
import type { CalendarEvent } from "@/shared/Calendar";

const API_URL = process.env.NEXT_PUBLIC_API_URL ?? "http://localhost:4000/api";

// Типы для задач
type StudentTask = {
  id: number;
  title: string;
  status: "TODO" | "REVIEW" | "CHANGES_REQUESTED" | "DONE";
  xpReward: number;
  stage: string;
  description: string;
  deadline?: string;
  submission?: any;
};

// Тип для куратора в фильтре
type CuratorOption = {
    id: string; // curatorId
    fullName: string;
    userId: string;
};

export default function StudentPanelPage() {
  const { countries } = useCountry();
  const { user } = useAuth();
  const searchParams = useSearchParams();
  
  const [students, setStudents] = useState<StudentFull[]>([]);
  const [curators, setCurators] = useState<CuratorOption[]>([]); // Список кураторов для фильтра
  const [selectedStudentId, setSelectedStudentId] = useState<string | null>(null);
  const [studentTasks, setStudentTasks] = useState<StudentTask[]>([]);
  const [tasksLoading, setTasksLoading] = useState(false);
  const [loading, setLoading] = useState(true);
  
  // Фильтры
  const [searchTerm, setSearchTerm] = useState("");
  const [listTab, setListTab] = useState<'my' | 'all'>('my');
  const [filterCuratorId, setFilterCuratorId] = useState<string>(""); // Фильтр по куратору (для админа)
  
  // Табы правой панели
  const [activeTab, setActiveTab] = useState<'info' | 'calendar' | 'tasks'>('info'); 
  
  // Modal states
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingStudent, setEditingStudent] = useState<StudentFull | null>(null);
  const [selectedTask, setSelectedTask] = useState<StudentTask | null>(null);
  const [isTaskModalOpen, setIsTaskModalOpen] = useState(false);

  // 1. Установка дефолтного таба в зависимости от роли
  useEffect(() => {
    if (user?.role === 'admin') {
        setListTab('all');
    } else {
        setListTab('my');
    }
  }, [user]);

  // 2. Загрузка данных
  const fetchData = async () => {
    const token = localStorage.getItem("accessToken");
    try {
        // Загружаем студентов
        const resStudents = await fetch(`${API_URL}/admin/students`, {
            headers: { Authorization: `Bearer ${token}` }
        });
        if(resStudents.ok) {
            setStudents(await resStudents.json());
        }

        // Если Админ, загружаем список кураторов для фильтра
        if (user?.role === 'admin') {
            const resModerators = await fetch(`${API_URL}/admin/moderators`, {
                headers: { Authorization: `Bearer ${token}` }
            });
            if (resModerators.ok) {
                const data = await resModerators.json();
                // Мапим данные для селекта
                const options = data.curators.map((c: any) => ({
                    id: c.curator?.id, // ID сущности Curator (нужен для связи со студентом)
                    userId: c.id,      // ID User
                    fullName: c.curator?.fullName || c.email
                })).filter((c: any) => c.id); // Убираем тех, у кого нет профиля куратора
                setCurators(options);
            }
        }
    } catch(e) { 
        console.error(e); 
    } finally { 
        setLoading(false); 
    }
  };

  useEffect(() => {
    if (user) fetchData();
  }, [user]);

  // Эффект для выбора студента из URL
  useEffect(() => {
      const targetId = searchParams.get('studentId');
      if (targetId && students.length > 0) {
          if (students.find(s => s.id === targetId)) {
              setSelectedStudentId(targetId);
          }
      }
  }, [searchParams, students]);

  // 3. Загрузка задач при выборе студента
  useEffect(() => {
      if (selectedStudentId) {
          setTasksLoading(true);
          const token = localStorage.getItem("accessToken");
          fetch(`${API_URL}/curator/students/${selectedStudentId}/tasks`, {
              headers: { Authorization: `Bearer ${token}` }
          })
          .then(async (res) => {
              if (res.ok) {
                  const data = await res.json();
                  if (Array.isArray(data)) {
                      setStudentTasks(data);
                  } else {
                      setStudentTasks([]);
                  }
              } else {
                  setStudentTasks([]);
              }
          })
          .catch(err => {
              console.error(err);
              setStudentTasks([]);
          })
          .finally(() => setTasksLoading(false));
      } else {
          setStudentTasks([]);
      }
  }, [selectedStudentId]);

  // 4. Логика фильтрации
  const filteredStudents = useMemo(() => {
    let list = students;

    // Таб "Мои"
    if (listTab === 'my') {
        if (user?.curatorId) {
            list = list.filter(s => s.curatorId === user.curatorId);
        } else {
            // Если у пользователя нет curatorId (например, чистый админ), список пуст
            list = [];
        }
    }

    // Таб "Все" + Фильтр по куратору (только для админа)
    if (listTab === 'all' && user?.role === 'admin' && filterCuratorId) {
        list = list.filter(s => s.curatorId === filterCuratorId);
    }

    // Поиск по тексту
    if (searchTerm) {
        const lower = searchTerm.toLowerCase();
        list = list.filter(s => 
            s.fullName.toLowerCase().includes(lower) || 
            s.email.toLowerCase().includes(lower)
        );
    }
    return list;
  }, [students, searchTerm, listTab, user, filterCuratorId]);

  const activeStudent = useMemo(() => 
    students.find(s => s.id === selectedStudentId), 
  [students, selectedStudentId]);

  const activeCountry = useMemo(() => 
    countries.find(c => c.id === activeStudent?.countryId),
  [countries, activeStudent]);

  // Статистика
  const stats = useMemo(() => {
      if (!Array.isArray(studentTasks)) return { total: 0, done: 0, review: 0, percent: 0 };
      const total = studentTasks.length;
      const done = studentTasks.filter(t => t.status === 'DONE').length;
      const review = studentTasks.filter(t => t.status === 'REVIEW').length;
      const percent = total > 0 ? Math.round((done / total) * 100) : 0;
      return { total, done, review, percent };
  }, [studentTasks]);

  // Календарь
  const calendarEvents = useMemo(() => {
      if (!Array.isArray(studentTasks)) return [];
      return studentTasks
        .filter(t => t.deadline && t.status !== 'DONE')
        .map(t => ({
            date: t.deadline!,
            title: t.title,
            type: 'quest' as const
        }));
  }, [studentTasks]);

  // Канбан
  const columns = useMemo(() => {
      if (!Array.isArray(studentTasks)) return { todo: [], review: [], done: [] };
      return {
        todo: studentTasks.filter(t => t.status === "TODO"),
        review: studentTasks.filter(t => t.status === "REVIEW" || t.status === "CHANGES_REQUESTED"),
        done: studentTasks.filter(t => t.status === "DONE"),
      };
  }, [studentTasks]);

  const handleSaveStudent = async (data: any) => {
    const token = localStorage.getItem("accessToken");
    let res;
    
    if (!data.id && user?.curatorId && !data.curatorId) {
        data.curatorId = user.curatorId;
    }

    const payload = { ...data };

    if (data.id) {
        res = await fetch(`${API_URL}/admin/students/${data.id}`, {
            method: "PATCH",
            headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` },
            body: JSON.stringify(payload)
        });
    } else {
        res = await fetch(`${API_URL}/admin/students`, {
            method: "POST",
            headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` },
            body: JSON.stringify(payload)
        });
    }

    if (res.ok) {
        await fetchData(); // Обновляем список
        return await res.json();
    } else {
        throw new Error("Failed");
    }
  };

  const handleDeleteStudent = async (id: string) => {
      const token = localStorage.getItem("accessToken");
      try {
          const res = await fetch(`${API_URL}/admin/students/${id}`, {
              method: "DELETE",
              headers: { Authorization: `Bearer ${token}` }
          });
          if (res.ok) {
              setStudents(prev => prev.filter(s => s.id !== id));
              if (selectedStudentId === id) setSelectedStudentId(null);
          } else {
              alert("Ошибка при удалении");
          }
      } catch (e) {
          console.error(e);
      }
  };

  const handleCreateAdHocTask = async (taskTitle: string) => { 
      alert("Mock create task"); 
      setIsTaskModalOpen(false); 
  };

  if (loading) return <div className="p-8 text-zinc-500">Загрузка данных...</div>;

  return (
    <div className="h-[calc(100vh-6rem)] flex flex-col">
      <div className="mb-4">
        <h1 className="text-2xl font-semibold">Студенты</h1>
        <p className="text-zinc-400 text-sm">Управление базой студентов и задачами.</p>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-[320px_1fr] gap-6 h-full overflow-hidden">
        
        {/* === Левая колонка: Список === */}
        <div className="card flex flex-col overflow-hidden bg-white dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-800">
            <div className="p-3 border-b border-zinc-100 dark:border-zinc-800 space-y-3">
                {/* Табы - показываем "Мои", только если у юзера есть curatorId */}
                <div className="flex bg-zinc-100 dark:bg-zinc-800 p-1 rounded-xl">
                    {user?.curatorId && (
                        <button 
                            onClick={() => setListTab('my')}
                            className={`flex-1 text-xs font-medium py-1.5 rounded-lg transition ${listTab === 'my' ? 'bg-white dark:bg-zinc-700 shadow-sm text-black dark:text-white' : 'text-zinc-500 hover:text-zinc-700'}`}
                        >
                            Мои студенты
                        </button>
                    )}
                    <button 
                        onClick={() => setListTab('all')}
                        className={`flex-1 text-xs font-medium py-1.5 rounded-lg transition ${listTab === 'all' ? 'bg-white dark:bg-zinc-700 shadow-sm text-black dark:text-white' : 'text-zinc-500 hover:text-zinc-700'}`}
                    >
                        Все студенты
                    </button>
                </div>

                {/* Фильтр по куратору (ТОЛЬКО ДЛЯ АДМИНА) */}
                {user?.role === 'admin' && listTab === 'all' && (
                    <div>
                        <select 
                            value={filterCuratorId}
                            onChange={(e) => setFilterCuratorId(e.target.value)}
                            className="w-full bg-zinc-50 dark:bg-zinc-800 border-none rounded-xl py-2 px-3 text-sm focus:ring-2 focus:ring-blue-500 outline-none cursor-pointer"
                        >
                            <option value="">Все кураторы</option>
                            {curators.map(c => (
                                <option key={c.id} value={c.id}>{c.fullName}</option>
                            ))}
                            {/* Опция для поиска студентов без куратора, если нужно, можно добавить value="null" и обработать */}
                        </select>
                    </div>
                )}

                {/* Поиск */}
                <div className="relative">
                    <input 
                        type="text" 
                        placeholder="Поиск по имени..." 
                        value={searchTerm}
                        onChange={e => setSearchTerm(e.target.value)}
                        className="w-full bg-zinc-50 dark:bg-zinc-800 border-none rounded-xl py-2 pl-9 pr-4 text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                    />
                    <span className="absolute left-3 top-2.5 text-zinc-400">🔍</span>
                </div>
                
                {/* Кнопка добавить (только Админ) */}
                {user?.role === 'admin' && (
                    <button onClick={() => { setEditingStudent(null); setIsModalOpen(true); }} className="w-full btn btn-primary text-xs py-2">
                        + Новый студент
                    </button>
                )}
            </div>
            
            <div className="overflow-y-auto p-2 flex-1">
                {filteredStudents.length === 0 ? (
                    <div className="text-center py-8 text-zinc-500 text-sm">
                        {listTab === 'my' ? "У вас нет студентов" : "Список пуст"}
                    </div>
                ) : (
                    <ul className="space-y-1">
                        {filteredStudents.map(student => (
                            <li key={student.id}>
                                <button
                                    onClick={() => setSelectedStudentId(student.id)}
                                    className={`w-full text-left px-3 py-3 rounded-xl transition flex items-center gap-3 relative ${
                                        selectedStudentId === student.id 
                                        ? "bg-black text-white dark:bg-zinc-800 shadow-md" 
                                        : "hover:bg-zinc-100 dark:hover:bg-zinc-800/50"
                                    }`}
                                >
                                    <Avatar name={student.fullName} level={Math.floor(student.xpTotal/200)+1} className="w-8 h-8 text-xs shrink-0" />
                                    <div className="overflow-hidden flex-1">
                                        <div className="font-medium text-sm truncate">{student.fullName}</div>
                                        <div className="flex items-center gap-2 text-[10px] opacity-70">
                                            <span className="truncate">{student.email}</span>
                                        </div>
                                    </div>
                                    {listTab === 'all' && student.curatorName && (
                                        <div className="text-[9px] px-1.5 py-0.5 rounded border border-zinc-200 bg-zinc-100 text-zinc-500 dark:border-zinc-700 dark:bg-zinc-800">
                                            {student.curatorName.split(' ')[0]}
                                        </div>
                                    )}
                                </button>
                            </li>
                        ))}
                    </ul>
                )}
            </div>
        </div>

        {/* === Правая колонка: Детали студента === */}
        {activeStudent ? (
            <div className="flex flex-col h-full overflow-hidden">
                {/* Header Info */}
                <div className="card p-4 mb-4 bg-white dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-800">
                    <div className="flex justify-between items-start">
                        <div className="flex items-center gap-4">
                            <Avatar name={activeStudent.fullName} level={Math.floor(activeStudent.xpTotal/200)+1} className="w-14 h-14 text-xl" />
                            <div>
                                <h2 className="text-xl font-bold">{activeStudent.fullName}</h2>
                                <div className="flex flex-wrap items-center gap-3 text-xs text-zinc-500 mt-1">
                                    <span>{activeCountry?.flag_icon} {activeCountry?.name || "Нет страны"}</span>
                                    <span>XP: <span className="text-yellow-600 font-bold">{activeStudent.xpTotal}</span></span>
                                    <span className="font-mono text-blue-500 bg-blue-50 dark:bg-blue-900/20 px-2 py-0.5 rounded">{activeStudent.bindingCode}</span>
                                </div>
                            </div>
                        </div>
                        <div className="flex gap-2">
                             <button onClick={() => setIsTaskModalOpen(true)} className="btn bg-zinc-100 dark:bg-zinc-800 text-xs px-3 py-2">+ Задача</button>
                             <button onClick={() => { setEditingStudent(activeStudent); setIsModalOpen(true); }} className="btn border border-zinc-200 dark:border-zinc-700 text-xs px-3 py-2">Настройки</button>
                        </div>
                    </div>

                    {/* Tabs Navigation */}
                    <div className="flex gap-6 mt-6 border-b border-zinc-100 dark:border-zinc-800">
                        <button 
                            onClick={() => setActiveTab('info')}
                            className={`pb-2 text-sm font-medium border-b-2 transition ${activeTab === 'info' ? 'border-blue-500 text-blue-600' : 'border-transparent text-zinc-500 hover:text-zinc-700'}`}
                        >
                            Инфо / Статистика
                        </button>
                        <button 
                            onClick={() => setActiveTab('calendar')}
                            className={`pb-2 text-sm font-medium border-b-2 transition ${activeTab === 'calendar' ? 'border-blue-500 text-blue-600' : 'border-transparent text-zinc-500 hover:text-zinc-700'}`}
                        >
                            Календарь
                        </button>
                        <button 
                            onClick={() => setActiveTab('tasks')}
                            className={`pb-2 text-sm font-medium border-b-2 transition ${activeTab === 'tasks' ? 'border-blue-500 text-blue-600' : 'border-transparent text-zinc-500 hover:text-zinc-700'}`}
                        >
                            Задачи ({studentTasks.length})
                        </button>
                    </div>
                </div>

                {/* Tab Content */}
                <div className="flex-1 overflow-hidden">
                    {activeTab === 'info' && (
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 h-full overflow-y-auto pr-2">
                             <div className="card p-4 space-y-4">
                                <h3 className="font-semibold text-sm">Прогресс по задачам</h3>
                                <div className="space-y-3">
                                    <div className="flex justify-between text-sm">
                                        <span className="text-zinc-500">Всего задач</span>
                                        <span className="font-bold">{stats.total}</span>
                                    </div>
                                    <div className="flex justify-between text-sm">
                                        <span className="text-zinc-500">Выполнено</span>
                                        <span className="font-bold text-green-600">{stats.done}</span>
                                    </div>
                                    <div className="flex justify-between text-sm">
                                        <span className="text-zinc-500">На проверке</span>
                                        <span className="font-bold text-blue-600">{stats.review}</span>
                                    </div>
                                    <div className="w-full bg-zinc-100 dark:bg-zinc-800 rounded-full h-2.5 mt-2">
                                        <div className="bg-green-500 h-2.5 rounded-full" style={{ width: `${stats.percent}%` }}></div>
                                    </div>
                                    <p className="text-xs text-center text-zinc-400">{stats.percent}% завершено</p>
                                </div>
                             </div>
                             <div className="card p-4">
                                <h3 className="font-semibold text-sm mb-2">Детали</h3>
                                <div className="text-sm space-y-2">
                                    <p><span className="text-zinc-500">Email:</span> {activeStudent.email}</p>
                                    <p><span className="text-zinc-500">Куратор:</span> {activeStudent.curatorName || 'Нет'}</p>
                                    <p><span className="text-zinc-500">Активен:</span> {activeStudent.isActive ? 'Да' : 'Нет'}</p>
                                </div>
                             </div>
                        </div>
                    )}

                    {activeTab === 'calendar' && (
                        <div className="card p-4 h-full overflow-y-auto">
                            <Calendar events={calendarEvents} />
                        </div>
                    )}

                    {activeTab === 'tasks' && (
                        <div className="h-full overflow-x-auto overflow-y-hidden">
                             {tasksLoading ? (
                                 <div className="p-10 text-center text-zinc-500">Загрузка задач...</div>
                             ) : (
                                <div className="grid grid-cols-3 gap-4 h-full min-w-[800px]">
                                    <KanbanCol title="К выполнению" tasks={columns.todo} onTaskClick={setSelectedTask} />
                                    <KanbanCol title="На проверке" tasks={columns.review} onTaskClick={setSelectedTask} />
                                    <KanbanCol title="Готово" tasks={columns.done} onTaskClick={setSelectedTask} />
                                </div>
                             )}
                        </div>
                    )}
                </div>
            </div>
        ) : (
            <div className="flex flex-col items-center justify-center text-zinc-400 h-full card bg-white dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-800">
                <div className="text-4xl mb-3 opacity-50">👨‍🎓</div>
                <p>Выберите студента из списка</p>
            </div>
        )}
      </div>

      {isModalOpen && (
          <StudentModal 
              student={editingStudent} 
              onClose={() => setIsModalOpen(false)} 
              onSave={handleSaveStudent as any}
              onDelete={handleDeleteStudent} // <--- передаем функцию
          />
      )}
      {selectedTask && <QuestDetailModal quest={selectedTask as any} onClose={() => setSelectedTask(null)} />}
      {isTaskModalOpen && (
        <div className="fixed inset-0 bg-black/60 flex items-center justify-center p-4 z-50">
            <div className="card p-6 w-full max-w-md">
                <h3 className="font-bold mb-4">Новая задача</h3>
                <form onSubmit={(e) => { e.preventDefault(); const formData = new FormData(e.currentTarget); handleCreateAdHocTask(formData.get('title') as string); }}>
                    <input name="title" required className="w-full p-2 border rounded-lg bg-zinc-50 dark:bg-zinc-800 mb-4" placeholder="Название задачи" />
                    <div className="flex justify-end gap-2">
                        <button type="button" onClick={() => setIsTaskModalOpen(false)} className="btn">Отмена</button>
                        <button type="submit" className="btn btn-primary">Назначить</button>
                    </div>
                </form>
            </div>
        </div>
      )}
    </div>
  );
}

// Компонент колонки
function KanbanCol({ title, tasks, onTaskClick }: { title: string, tasks: StudentTask[], onTaskClick: (t: StudentTask) => void }) {
    return (
        <div className="flex flex-col h-full">
            <div className="mb-2 flex items-center justify-between px-1">
                <span className="text-xs font-bold uppercase text-zinc-500">{title}</span>
                <span className="text-xs bg-zinc-200 dark:bg-zinc-800 px-2 py-0.5 rounded-full">{tasks.length}</span>
            </div>
            <div className="flex-1 bg-zinc-50 dark:bg-zinc-900/30 rounded-xl p-2 overflow-y-auto space-y-2 border border-zinc-200/50 dark:border-zinc-800/50">
                {tasks.map(task => (
                    <div key={task.id} onClick={() => onTaskClick(task)} className="p-3 rounded-lg border bg-white dark:bg-zinc-800 border-zinc-200 dark:border-zinc-700 shadow-sm cursor-pointer hover:shadow-md transition">
                         <div className="flex justify-between items-start gap-2">
                            <span className="text-[10px] font-medium text-zinc-500 uppercase tracking-tight">{task.stage}</span>
                            <span className="text-[10px] font-bold text-yellow-600">+{task.xpReward}</span>
                        </div>
                        <div className="font-medium text-sm mt-1">{task.title}</div>
                        {task.status === 'CHANGES_REQUESTED' && <div className="mt-2 text-[10px] bg-red-100 text-red-700 px-2 py-0.5 rounded inline-block">Правки</div>}
                        {task.status === 'REVIEW' && <div className="mt-2 text-[10px] bg-blue-100 text-blue-700 px-2 py-0.5 rounded inline-block">На проверке</div>}
                    </div>
                ))}
            </div>
        </div>
    )
}
--- END FILE: apps/web/app/curator/students/page.tsx ---

--- BEGIN FILE: apps/web/app/globals.css ---
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}

/* utilities used by Student/Curator screens */
.container {
  @apply mx-auto px-4;
}
.card {
  @apply rounded-2xl shadow border border-black/5 dark:border-white/10 bg-white dark:bg-zinc-900;
}
.btn {
  @apply inline-flex items-center justify-center rounded-xl px-4 py-2 font-medium;
}
.btn-primary {
  @apply bg-black text-white dark:bg-white dark:text-black;
}
--- END FILE: apps/web/app/globals.css ---

--- BEGIN FILE: apps/web/app/layout.tsx ---
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { AuthProvider } from "@/shared/AuthContext";
import { ProgressProvider } from "@/shared/ProgressContext";
import { CountryProvider } from "@/shared/CountryContext";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <AuthProvider>
          <ProgressProvider>
            <CountryProvider>
              {children}
            </CountryProvider>
          </ProgressProvider>
        </AuthProvider>
      </body>
    </html>
  );
}
--- END FILE: apps/web/app/layout.tsx ---

--- BEGIN FILE: apps/web/app/login/page.tsx ---
"use client";
import { useAuth } from "@/shared/AuthContext";
import { useRouter } from "next/navigation";
import { useEffect, useState } from "react";
import Link from "next/link";

export default function LoginPage() {
  const auth = useAuth();
  const router = useRouter();

  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (auth.user) {
      const role = auth.user.role.toLowerCase();
      if (role === "student") {
        router.replace("/student/dashboard");
      } else {
        router.replace("/curator/dashboard");
      }
    }
  }, [auth.user, router]);

  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    if (!email || !password) {
      setError("Please enter email and password");
      return;
    }
    try {
      setLoading(true);
      await auth.login(email, password);
    } catch (e: any) {
      setError(e.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="relative min-h-screen flex items-center justify-center overflow-hidden bg-black selection:bg-indigo-500/30">
      {/* Abstract Background Gradients */}
      <div className="absolute top-[-20%] left-[-10%] w-[50%] h-[50%] bg-purple-600/20 rounded-full blur-[120px]" />
      <div className="absolute bottom-[-10%] right-[-5%] w-[40%] h-[40%] bg-blue-600/20 rounded-full blur-[100px]" />

      {/* Glassmorphism Card */}
      <div className="relative w-full max-w-md p-1">
        <div className="absolute inset-0 bg-gradient-to-b from-white/10 to-white/5 rounded-3xl blur-sm" />
        <div className="relative bg-zinc-900/60 backdrop-blur-xl border border-white/10 shadow-2xl rounded-3xl p-8 sm:p-10">

          <div className="text-center mb-10">
            <h1 className="text-3xl font-bold bg-gradient-to-r from-blue-400 via-indigo-400 to-purple-400 bg-clip-text text-transparent">
              Welcome Back
            </h1>
            <p className="text-zinc-400 text-sm mt-3">
              Enter your credentials to continue your journey
            </p>
          </div>

          <form className="space-y-6" onSubmit={handleLogin}>
            <div className="space-y-2">
              <label className="text-xs font-medium text-zinc-300 uppercase tracking-wider ml-1">Email</label>
              <input
                type="email"
                required
                className="w-full bg-zinc-800/50 border border-white/5 rounded-xl px-4 py-3 text-zinc-100 placeholder:text-zinc-600 focus:outline-none focus:ring-2 focus:ring-indigo-500/50 focus:border-transparent transition-all"
                placeholder="name@example.com"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
              />
            </div>

            <div className="space-y-2">
              <label className="text-xs font-medium text-zinc-300 uppercase tracking-wider ml-1">Password</label>
              <input
                type="password"
                required
                className="w-full bg-zinc-800/50 border border-white/5 rounded-xl px-4 py-3 text-zinc-100 placeholder:text-zinc-600 focus:outline-none focus:ring-2 focus:ring-indigo-500/50 focus:border-transparent transition-all"
                placeholder="••••••••"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
              />
            </div>

            <button
              type="submit"
              disabled={loading}
              className="w-full relative group overflow-hidden rounded-xl bg-gradient-to-r from-blue-600 to-indigo-600 p-[1px] shadow-lg shadow-indigo-500/20 transition-all hover:shadow-indigo-500/40 disabled:opacity-70 disabled:cursor-not-allowed"
            >
              <div className="relative bg-zinc-900/0 group-hover:bg-white/5 transition-colors rounded-xl h-full px-6 py-3.5">
                <span className="font-semibold text-white tracking-wide">
                  {loading ? (
                    <span className="flex items-center justify-center gap-2">
                      <svg className="animate-spin h-4 w-4" viewBox="0 0 24 24">
                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" fill="none" />
                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
                      </svg>
                      Signing in...
                    </span>
                  ) : (
                    "Sign In"
                  )}
                </span>
              </div>
            </button>
          </form>

          {error && (
            <div className="mt-6 p-4 rounded-xl bg-red-500/10 border border-red-500/20 backdrop-blur-sm">
              <p className="text-xs text-red-200 text-center font-medium">
                {error}
              </p>
            </div>
          )}

          <div className="mt-8 text-center">
            <p className="text-xs text-zinc-500">
              Don't have an account?{" "}
              <Link href="/register" className="text-indigo-400 hover:text-indigo-300 font-medium hover:underline transition-colors">
                Create Account
              </Link>
            </p>
          </div>
        </div>
      </div>
    </div>
  );
}
--- END FILE: apps/web/app/login/page.tsx ---

--- BEGIN FILE: apps/web/app/page.tsx ---
"use client";
import { useEffect } from "react";
import { useRouter } from "next/navigation";
import { useAuth } from "@/shared/AuthContext";

export default function RootPage() {
  const router = useRouter();
  const { user, loading } = useAuth();

  useEffect(() => {
    if (loading) return; // Ждем, пока AuthContext определит состояние пользователя

    if (!user) {
      router.replace("/login");
    } else if (user.role === "student") {
      router.replace("/student/dashboard");
    } else if (user.role === "curator") {
      router.replace("/curator/dashboard");
    }
  }, [user, loading, router]);

  return (
    <div className="min-h-screen bg-zinc-50 dark:bg-black flex items-center justify-center">Загрузка...</div>
  );
}
--- END FILE: apps/web/app/page.tsx ---

--- BEGIN FILE: apps/web/app/register/page.tsx ---
"use client";
import { useAuth } from "@/shared/AuthContext";
import { useRouter } from "next/navigation";
import { useEffect, useState } from "react";
import Link from "next/link";

export default function RegisterPage() {
  const auth = useAuth();
  const router = useRouter();

  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [role, setRole] = useState<"student" | "curator" | "admin">("student");
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (auth.user) {
      const r = auth.user.role.toLowerCase();
      router.replace(r === "student" ? "/student/dashboard" : "/curator/dashboard");
    }
  }, [auth.user, router]);

  const handleRegister = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);

    try {
      setLoading(true);
      await auth.register({ email, password, role });
    } catch (err: any) {
      setError(err.message || "Не удалось выполнить регистрацию");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-zinc-50 dark:bg-black flex items-center justify-center">
      <div className="w-full max-w-sm rounded-2xl shadow p-8 bg-white dark:bg-zinc-900">
        <div className="pt-4 mt-2">
          <h2 className="text-sm font-semibold mb-2 text-zinc-800 dark:text-zinc-100">
            Регистрация
          </h2>
          <form className="space-y-3" onSubmit={handleRegister}>
            <div>
              <label className="block text-xs text-zinc-500 mb-1">Email</label>
              <input
                type="email"
                required
                className="w-full rounded-xl border px-3 py-2 bg-white dark:bg-zinc-800"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
              />
            </div>
            <div>
              <label className="block text-xs text-zinc-500 mb-1">Пароль</label>
              <input
                type="password"
                required
                className="w-full rounded-xl border px-3 py-2 bg-white dark:bg-zinc-800"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
              />
            </div>
            <div>
              <label className="block text-xs text-zinc-500 mb-1">Роль</label>
              <div className="grid grid-cols-3 gap-2">
                {(["student", "curator", "admin"] as const).map((r) => (
                    <button
                        key={r}
                        type="button"
                        onClick={() => setRole(r)}
                        className={`text-xs py-2 rounded-lg border transition ${
                            role === r 
                            ? "bg-black text-white dark:bg-white dark:text-black border-transparent" 
                            : "bg-transparent border-zinc-200 dark:border-zinc-700 text-zinc-500 hover:bg-zinc-100 dark:hover:bg-zinc-800"
                        }`}
                    >
                        {r === 'student' ? 'Студент' : r === 'curator' ? 'Куратор' : 'Админ'}
                    </button>
                ))}
              </div>
            </div>
            
            <button
              type="submit"
              disabled={loading}
              className="w-full mt-4 rounded-2xl py-2.5 font-medium bg-blue-600 text-white disabled:bg-blue-300 hover:bg-blue-700 transition"
            >
              {loading ? "Создание аккаунта..." : "Зарегистрироваться"}
            </button>
          </form>

          {error && (
            <p className="mt-3 text-xs text-red-500 text-center">
              {error}
            </p>
          )}

          <div className="mt-6 text-center text-xs text-zinc-500">
             Есть аккаунт?{" "}
             <Link href="/login" className="text-blue-500 hover:underline">
               Войти
             </Link>
           </div>
        </div>
      </div>
    </div>
  );
}
--- END FILE: apps/web/app/register/page.tsx ---

--- BEGIN FILE: apps/web/app/shared/useUIStore.ts ---
"use client";
import { create } from "zustand";

type UIState = {
  sidebarCollapsed: boolean;
  toggleSidebar: () => void;
};

export const useUIStore = create<UIState>((set) => ({
  sidebarCollapsed: false,
  toggleSidebar: () => set((state) => ({ sidebarCollapsed: !state.sidebarCollapsed })),
}));
--- END FILE: apps/web/app/shared/useUIStore.ts ---

--- BEGIN FILE: apps/web/app/student/calendar/page.tsx ---
"use client";

import { useMemo } from "react";
import Calendar, { CalendarEvent } from "@/shared/Calendar";
import { useCountry } from "@/shared/CountryContext";

export default function StudentCalendarPage() {
  const { selectedCountry, quests, programs } = useCountry();

  const studentEvents = useMemo(() => {
    const events: CalendarEvent[] = [];
    if (!selectedCountry) return [];

    // 1. Дедлайны по квестам для выбранной страны
    const requiredQuestIds = new Set(selectedCountry.required_quest_ids);
    quests
      .filter(q => requiredQuestIds.has(q.id) && q.deadline)
      .forEach(q => {
        events.push({
          date: q.deadline,
          title: q.title,
          type: 'quest'
        });
      });

    // 2. Дедлайны по подаче в университеты (для примера возьмем все)
    programs.forEach(p => {
      events.push({
        date: p.deadline,
        title: `Подача: ${p.title}`,
        type: 'program'
      });
    });
    
    return events;
  }, [selectedCountry, quests, programs]);

  return (
    <div>
      <h1 className="text-2xl font-semibold mb-2">Календарь</h1>
      <p className="text-zinc-600 dark:text-zinc-300 mb-6">Ваши личные дедлайны по задачам и программам.</p>
      <Calendar events={studentEvents} />
    </div>
  );
}
--- END FILE: apps/web/app/student/calendar/page.tsx ---

--- BEGIN FILE: apps/web/app/student/dashboard/page.tsx ---
"use client";
import { useAuth } from "@/shared/AuthContext";
import { useCountry } from "@/shared/CountryContext";
import { useProgress } from "@/shared/ProgressContext";
import Link from "next/link";
import { useMemo } from "react";
import Avatar from "@/shared/Avatar";

export default function Dashboard() {
  const { user } = useAuth();
  const { selectedCountry, quests } = useCountry(); // documents не используется здесь напрямую
  const { tasks } = useProgress(); // Используем tasks вместо progress

  const { totalQuests, completedQuests, progressPercentage, totalXp, level } = useMemo(() => {
    if (!selectedCountry) {
      return { totalQuests: 0, completedQuests: 0, progressPercentage: 0, totalXp: 0, level: 1 };
    }

    // 1. Определяем ID и Заголовки обязательных квестов для выбранной страны
    const requiredQuestIds = new Set(selectedCountry.required_quest_ids);
    const requiredQuestTitles = new Set(
      quests
        .filter((q) => requiredQuestIds.has(q.id))
        .map((q) => q.title)
    );

    // 2. Находим выполненные задачи из списка задач пользователя (tasks), 
    // которые совпадают по названию с обязательными квестами
    const relevantCompletedTasks = tasks.filter(
      (t) => requiredQuestTitles.has(t.title) && t.status === 'DONE'
    );

    // 3. Считаем процент (по количеству обязательных квестов)
    const progressValue = requiredQuestIds.size > 0 
      ? (relevantCompletedTasks.length / requiredQuestIds.size) * 100 
      : 0;

    // 4. Считаем XP (берем награду из выполненных задач)
    const xp = relevantCompletedTasks.reduce((sum, t) => sum + (t.xpReward || 0), 0);
    
    // Уровень: каждые 200 XP
    const level = Math.floor(xp / 200) + 1;

    return {
      totalQuests: requiredQuestIds.size,
      completedQuests: relevantCompletedTasks.length,
      progressPercentage: progressValue,
      totalXp: xp,
      level
    };
  }, [selectedCountry, tasks, quests]);

  return (
    <div>
      <h1 className="text-2xl font-semibold mb-2">Адаптивный Штаб</h1>
      <p className="text-zinc-600 dark:text-zinc-300 mb-6">
        Добро пожаловать, {user?.name}! Здесь ваш центр управления операцией «Поступление».
      </p>

      <div className="grid sm:grid-cols-[1fr_2fr] gap-6 mb-6">
        <div className="card p-4 flex flex-col items-center text-center">
          <div className="mb-3">
             <Avatar name={user?.name || "Student"} level={level} className="w-20 h-20 text-3xl" />
          </div>
          <div className="font-semibold">{user?.name}</div>
          <div className="text-sm text-zinc-500">Уровень {level}</div>
          <div className="mt-2 text-lg font-bold text-yellow-500">{totalXp} XP</div>
        </div>
        <div className="card p-4">
          <div className="flex items-center justify-between mb-1">
            <h2 className="font-semibold">Прогресс по стране: {selectedCountry?.flag_icon} {selectedCountry?.name}</h2>
            <span className="text-sm font-medium">{completedQuests} / {totalQuests}</span>
          </div>
          <div className="w-full bg-zinc-200 dark:bg-zinc-700 rounded-full h-2.5">
            <div className="bg-blue-600 h-2.5 rounded-full" style={{ width: `${progressPercentage}%` }}></div>
          </div>
          <p className="text-xs text-zinc-500 mt-2">Выполнение квестов повышает ваш прогресс и опыт.</p>
        </div>
      </div>

      <div className="grid sm:grid-cols-2 lg:grid-cols-4 gap-4">
        <Link
          href="/student/quests"
          className="card p-4 hover:bg-black/5 dark:hover:bg-white/5 transition h-[200px] flex flex-col justify-center text-center"
        >
          <div className="text-xl font-semibold mb-1">Мои Квесты ({totalQuests})</div>
          <div className="text-sm text-zinc-600 dark:text-zinc-300">Динамический список задач по стране.</div>
        </Link>
        <Link
          href="/student/kanban"
          className="card p-4 hover:bg-black/5 dark:hover:bg-white/5 transition h-[200px] flex flex-col justify-center text-center"
        >
          <div className="text-xl font-semibold mb-1">Kanban Доска</div>
          <div className="text-sm text-zinc-600 dark:text-zinc-300">Визуальное управление задачами.</div>
        </Link>
        <Link
          href="/student/programs"
          className="card p-4 hover:bg-black/5 dark:hover:bg-white/5 transition h-[200px] flex flex-col justify-center text-center"
        >
          <div className="text-xl font-semibold mb-1">Мои Программы</div>
          <div className="text-sm text-zinc-600 dark:text-zinc-300">Целевые университеты и их требования.</div>
        </Link>
        <Link
          href="/student/folder"
          className="card p-4 hover:bg-black/5 dark:hover:bg-white/5 transition h-[200px] flex flex-col justify-center text-center"
        >
          <div className="text-xl font-semibold mb-1">Моя Папка ({selectedCountry?.required_document_ids.length || 0})</div>
          <div className="text-sm text-zinc-600 dark:text-zinc-300">Чек-лист документов для выбранной страны.</div>
        </Link>
      </div>
    </div>
  );
}
--- END FILE: apps/web/app/student/dashboard/page.tsx ---

--- BEGIN FILE: apps/web/app/student/folder/page.tsx ---
"use client";
import { useCountry } from "@/shared/CountryContext";
import { useProgress } from "@/shared/ProgressContext";
import { useMemo, useState } from "react";

export default function FolderPage() {
  const { documents, selectedCountry, quests } = useCountry();
  const { tasks } = useProgress(); // Используем tasks вместо progress

  const completedDocumentIds = useMemo(() => {
    const doneDocIds = new Set<number>();
    if (!selectedCountry) return doneDocIds;

    // 1. Находим выполненные задачи
    const doneTasks = tasks.filter((t) => t.status === 'DONE');

    // 2. Находим, к каким документам эти квесты привязаны.
    // Сопоставляем Task (из БД) с QuestTemplate (из JSON) по названию,
    // так как ID у них разные.
    doneTasks.forEach((task) => {
      const template = quests.find(q => q.title === task.title);
      if (template && template.links_to_document_id) {
        doneDocIds.add(template.links_to_document_id);
      }
    });

    return doneDocIds;
  }, [tasks, quests, selectedCountry]);

  if (!selectedCountry) return null;

  const required = new Set(selectedCountry.required_document_ids);
  const filtered = documents.filter((d) => required.has(d.id) && completedDocumentIds.has(d.id));

  const [isDownloading, setIsDownloading] = useState(false);

  const handleDownload = async () => {
    try {
      setIsDownloading(true);
      const token = localStorage.getItem("accessToken");
      const API_URL = process.env.NEXT_PUBLIC_API_URL ?? "http://localhost:4000/api";

      const res = await fetch(`${API_URL}/tasks/download-zip`, {
        headers: {
          Authorization: `Bearer ${token}`
        }
      });

      if (!res.ok) throw new Error("Failed to download");

      const blob = await res.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = "documents.zip";
      document.body.appendChild(a);
      a.click();
      a.remove();
      window.URL.revokeObjectURL(url);
    } catch (e) {
      console.error(e);
      alert("Не удалось скачать архив. Попробуйте позже.");
    } finally {
      setIsDownloading(false);
    }
  };

  return (
    <div>
      <div className="flex items-center justify-between mb-6">
        <div>
          <h1 className="text-2xl font-semibold mb-2">Моя Папка</h1>
          <p className="text-zinc-600 dark:text-zinc-300">
            Здесь хранятся все готовые и проверенные документы.
          </p>
        </div>
        <button
          className="btn btn-primary"
          onClick={handleDownload}
          disabled={filtered.length === 0 || isDownloading}
        >
          {isDownloading ? 'Скачивание...' : 'Скачать архивом'}
        </button>
      </div>
      {filtered.length === 0 ? (
        <div className="text-center py-10">
          <div className="text-4xl mb-3">🗂️</div>
          <p className="text-zinc-500">Папка пуста. Выполненные документы появятся здесь.</p>
        </div>
      ) : (
        <ul className="grid sm:grid-cols-2 md:grid-cols-3 gap-4">
          {filtered.map((d) => (
            <li key={d.id} className="card p-4 flex flex-col justify-between">
              <div>
                <div className="text-xs text-zinc-500">{d.category}</div>
                <div className="font-medium mt-1">{d.title}</div>
              </div>
              <div className="text-xs text-green-500 mt-3 font-semibold">Проверен</div>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
--- END FILE: apps/web/app/student/folder/page.tsx ---

--- BEGIN FILE: apps/web/app/student/kanban/page.tsx ---
"use client";
import { Task } from "@/shared/ProgressContext";
import { useProgress } from "@/shared/ProgressContext";
import { useState } from "react";
import QuestDetailModal from "../quests/QuestDetailModal";

const KanbanColumn = ({
  title,
  tasks,
  onSelectQuest,
}: {
  title: string;
  tasks: Task[];
  onSelectQuest: (task: Task) => void;
}) => (
  <div className="flex-1">
    <h2 className="text-lg font-semibold mb-4 px-1">{title}</h2>
    <div className="space-y-3">
      {tasks.map((q) => (
        <div
          key={q.id}
          onClick={() => onSelectQuest(q)}
          className="card p-4 transition hover:shadow-lg cursor-pointer bg-white dark:bg-zinc-800"
        >
          <div className="font-medium text-sm">{q.title}</div>
          <div className="text-xs text-yellow-500 font-bold mt-2">XP: {q.xpReward}</div>
        </div>
      ))}
    </div>
  </div>
);

export default function KanbanPage() {
  const { tasks } = useProgress();
  const [selectedQuest, setSelectedQuest] = useState<Task | null>(null);

  const todoQuests = tasks.filter(q => q.status === 'TODO' || q.status === 'CHANGES_REQUESTED');
  const onReviewQuests = tasks.filter(q => q.status === 'REVIEW');
  const doneQuests = tasks.filter(q => q.status === 'DONE');

  return (
    <>
      <div>
        <h1 className="text-2xl font-semibold mb-2">Kanban Доска</h1>
        <p className="text-zinc-600 dark:text-zinc-300 mb-6">
          Управляйте вашими задачами в удобном формате.
        </p>
        <div className="flex gap-6">
          <KanbanColumn
            title={`To Do (${todoQuests.length})`}
            tasks={todoQuests}
            onSelectQuest={setSelectedQuest}
          />
          <KanbanColumn
            title={`On Review (${onReviewQuests.length})`}
            tasks={onReviewQuests}
            onSelectQuest={setSelectedQuest}
          />
          <KanbanColumn
            title={`Done (${doneQuests.length})`}
            tasks={doneQuests}
            onSelectQuest={setSelectedQuest}
          />
        </div>
      </div>
      {selectedQuest && (
        <QuestDetailModal quest={selectedQuest} onClose={() => setSelectedQuest(null)} />
      )}
    </>
  );
}
--- END FILE: apps/web/app/student/kanban/page.tsx ---

--- BEGIN FILE: apps/web/app/student/layout.tsx ---
"use client";
import { useAuth } from "@/shared/AuthContext";
import Sidebar from "@/shared/Sidebar";
import Navbar from "@/shared/Navbar";
import { useRouter } from "next/navigation";
import { useEffect } from "react";

export default function StudentLayout({ children }: { children: React.ReactNode }) {
  const { user, loading } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if (!loading && (!user || user.role !== "student")) {
      router.replace("/login");
    }
  }, [user, loading, router]);

  if (loading || !user) return <div className="min-h-screen bg-zinc-50 dark:bg-black flex items-center justify-center">Проверка доступа...</div>;

  return (
    <div className="min-h-screen bg-zinc-50 dark:bg-black">
      <div className="container py-6">
        <div className="grid grid-cols-1 sm:grid-cols-[16rem_1fr] gap-6">
          <Sidebar />
          <div className="flex flex-col min-w-0">
             <Navbar />
             <main className="card p-4 flex-1">{children}</main>
          </div>
        </div>
      </div>
    </div>
  );
}
--- END FILE: apps/web/app/student/layout.tsx ---

--- BEGIN FILE: apps/web/app/student/programs/ProgramDetailModal.tsx ---
 "use client";
import { useMemo } from "react";
import type { Program, QuestTemplate } from "../../../shared/CountryContext";
import { useCountry } from "../../../shared/CountryContext";
import { useProgress } from "../../../shared/ProgressContext";

type Props = {
  program: Program;
  onClose: () => void;
};

export default function ProgramDetailModal({ program, onClose }: Props) {
  const { documents, quests } = useCountry();
  const { tasks: myTasks } = useProgress();

  // 1. Получаем список документов
  const requiredDocs = useMemo(() => {
      const ids = program.required_document_ids || []; // Берем из entity
      return documents.filter((d: any) => ids.includes(d.id));
  }, [program, documents]);

  // 2. Получаем задачи, специфичные для этой программы
  // (В реальном приложении мы бы фильтровали мои задачи по programId, здесь симулируем это через шаблоны)
  const programTasks = useMemo(() => {
      return quests.filter((q: QuestTemplate) => q.universityId?.toString() === program.university_id);
  }, [quests, program]);

  return (
    <div
      className="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center p-4 z-50 animate-in fade-in duration-200"
      onClick={onClose}
    >
      <div 
        className="w-full max-w-2xl bg-white dark:bg-zinc-900 rounded-2xl shadow-2xl overflow-hidden flex flex-col max-h-[85vh] animate-in zoom-in-95 duration-300" 
        onClick={(e) => e.stopPropagation()}
      >
        {/* Header Image */}
        <div className="relative h-48 shrink-0 bg-zinc-800">
            {program.image_url ? (
                 // eslint-disable-next-line @next/next/no-img-element
                <img src={program.image_url} alt={program.title} className="w-full h-full object-cover opacity-80" />
            ) : (
                <div className="w-full h-full bg-gradient-to-r from-indigo-500 to-purple-600" />
            )}
            <div className="absolute inset-0 bg-gradient-to-t from-zinc-900 to-transparent" />
            
            <button onClick={onClose} className="absolute top-4 right-4 bg-black/30 hover:bg-black/50 text-white rounded-full w-8 h-8 flex items-center justify-center transition backdrop-blur-md">
                ✕
            </button>

            <div className="absolute bottom-5 left-6 right-6">
                 <span className="px-2 py-1 rounded bg-white/20 text-white text-xs backdrop-blur-md border border-white/10 mb-2 inline-block">
                    {program.category || "Образование"}
                </span>
                <h2 className="text-2xl font-bold text-white shadow-sm leading-tight">{program.title}</h2>
            </div>
        </div>

        {/* Scrollable Content */}
        <div className="flex-1 overflow-y-auto p-6 space-y-8">
            
            {/* Info Row */}
            <div className="flex flex-wrap gap-6 text-sm pb-6 border-b border-zinc-100 dark:border-zinc-800">
                <div className="flex flex-col">
                    <span className="text-zinc-500 text-xs uppercase tracking-wider font-bold mb-1">Дедлайн</span>
                    <span className="font-semibold text-zinc-800 dark:text-zinc-200">{program.deadline || "TBD"}</span>
                </div>
                {program.link && (
                    <div className="flex flex-col">
                         <span className="text-zinc-500 text-xs uppercase tracking-wider font-bold mb-1">Сайт</span>
                         <a href={program.link} target="_blank" className="text-blue-600 dark:text-blue-400 hover:underline font-medium">Перейти на сайт ↗</a>
                    </div>
                )}
            </div>

            {/* Requirements Section */}
            <div>
                <h3 className="text-lg font-bold mb-3 flex items-center gap-2 text-zinc-900 dark:text-white">
                    <span className="text-blue-500">📋</span> Документы для подачи
                </h3>
                {requiredDocs.length > 0 ? (
                    <ul className="grid grid-cols-1 sm:grid-cols-2 gap-2">
                        {requiredDocs.map((doc: any) => (
                            <li key={doc.id} className="flex items-start gap-2 p-3 bg-zinc-50 dark:bg-zinc-800/50 rounded-xl border border-zinc-100 dark:border-zinc-800 text-sm">
                                <div className="mt-0.5 text-blue-500">●</div>
                                <div>
                                    <div className="font-medium">{doc.title}</div>
                                    <div className="text-xs text-zinc-500">{doc.category}</div>
                                </div>
                            </li>
                        ))}
                    </ul>
                ) : (
                    <p className="text-sm text-zinc-500 italic">Специальных документов не требуется (только общие).</p>
                )}
            </div>

            {/* Program Tasks Section */}
            <div>
                 <h3 className="text-lg font-bold mb-3 flex items-center gap-2 text-zinc-900 dark:text-white">
                    <span className="text-yellow-500">⚡️</span> Специфические задачи
                </h3>
                <div className="bg-yellow-50 dark:bg-yellow-900/10 border border-yellow-100 dark:border-yellow-900/30 rounded-xl p-4">
                    <p className="text-xs text-yellow-700 dark:text-yellow-500 mb-3">
                        Эти задачи нужно выполнить специально для поступления на эту программу. Они появятся в вашем общем списке квестов.
                    </p>
                    {programTasks.length > 0 ? (
                        <ul className="space-y-2">
                            {programTasks.map((task: QuestTemplate) => (
                                <li key={task.id} className="flex justify-between items-center bg-white dark:bg-zinc-900 p-2 rounded-lg border border-zinc-200 dark:border-zinc-700 shadow-sm">
                                    <span className="text-sm font-medium">{task.title}</span>
                                    <span className="text-xs font-bold bg-yellow-100 dark:bg-yellow-900/40 text-yellow-700 px-2 py-1 rounded">+{task.xpReward} XP</span>
                                </li>
                            ))}
                        </ul>
                    ) : (
                        <p className="text-sm text-zinc-400">Нет специфических задач.</p>
                    )}
                </div>
            </div>

        </div>
        
        {/* Footer Actions */}
        <div className="p-4 border-t border-zinc-100 dark:border-zinc-800 bg-zinc-50 dark:bg-zinc-900/50 flex justify-end">
            <button onClick={onClose} className="px-4 py-2 rounded-lg bg-zinc-200 dark:bg-zinc-800 hover:bg-zinc-300 dark:hover:bg-zinc-700 text-zinc-800 dark:text-zinc-200 transition-colors">
                Закрыть
            </button>
            {/* Здесь можно добавить кнопку "Выбрать эту программу", если логика предполагает выбор пользователем */}
        </div>
      </div>
    </div>
  );
}
--- END FILE: apps/web/app/student/programs/ProgramDetailModal.tsx ---

--- BEGIN FILE: apps/web/app/student/programs/page.tsx ---
"use client";
import { useState, useMemo } from "react";
import { useCountry, type Program, type University } from "../../../shared/CountryContext";
import ProgramDetailModal from "./ProgramDetailModal";

export default function StudentProgramsPage() {
  const { universities, programs, selectedCountryId } = useCountry();
  const [selectedProgram, setSelectedProgram] = useState<Program | null>(null);

  // Группируем программы по университетам для текущей страны
  const universityGroups = useMemo(() => {
    const relevantUniversities = universities.filter((u: University) => u.countryId === selectedCountryId);
    
    return relevantUniversities.map((uni: University) => {
        // Фильтруем программы этого вуза
        const uniPrograms = programs.filter((p: Program) => 
            p.university_id === uni.id
        );
        return { university: uni, programs: uniPrograms };
    }).filter((group: { university: University; programs: Program[] }) => group.programs.length > 0); // Скрываем вузы без программ

  }, [universities, programs, selectedCountryId]) as { university: University; programs: Program[] }[];

  return (
    <div className="space-y-8">
      <div>
        <h1 className="text-2xl font-semibold mb-2">Каталог Программ</h1>
        <p className="text-zinc-600 dark:text-zinc-400">
          Выберите программу, чтобы увидеть требования, задачи и начать поступление.
        </p>
      </div>

      {universityGroups.length === 0 ? (
          <div className="text-center py-20 text-zinc-500">
              <div className="text-4xl mb-2">🌍</div>
              Программы для выбранной страны пока не добавлены.
          </div>
      ) : (
          universityGroups.map(({ university, programs }: { university: University; programs: Program[] }) => (
            <div key={university.id} className="animate-in fade-in slide-in-from-bottom-4 duration-500">
              <div className="flex items-center gap-3 mb-4 px-1">
                <span className="text-3xl filter drop-shadow-sm">{university.logo_url}</span>
                <h2 className="text-xl font-bold text-zinc-800 dark:text-zinc-100">{university.name}</h2>
              </div>
              
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-5">
                {programs.map((program: Program) => (
                  <button
                    key={program.id}
                    onClick={() => setSelectedProgram(program)}
                    className="group relative h-48 w-full rounded-2xl overflow-hidden text-left shadow-md hover:shadow-xl transition-all duration-300 transform hover:-translate-y-1 focus:outline-none focus:ring-2 focus:ring-blue-500"
                  >
                    {/* Background Image */}
                    <div className="absolute inset-0 bg-zinc-800">
                        {program.image_url ? (
                            // eslint-disable-next-line @next/next/no-img-element
                            <img 
                                src={program.image_url} 
                                alt={program.title} 
                                className="w-full h-full object-cover opacity-80 group-hover:scale-105 transition-transform duration-700" 
                            />
                        ) : (
                            <div className="w-full h-full bg-gradient-to-br from-blue-900 to-slate-900" />
                        )}
                        {/* Gradient Overlay for Text Readability */}
                        <div className="absolute inset-0 bg-gradient-to-t from-black/90 via-black/40 to-transparent" />
                    </div>

                    {/* Content */}
                    <div className="absolute bottom-0 left-0 right-0 p-5 z-10">
                        {program.category && (
                            <span className="inline-block px-2 py-0.5 mb-2 text-[10px] font-bold uppercase tracking-wider text-white bg-blue-600/80 backdrop-blur-md rounded-md">
                                {program.category}
                            </span>
                        )}
                        <h3 className="text-lg font-bold text-white leading-tight mb-1 group-hover:text-blue-200 transition-colors">
                            {program.title}
                        </h3>
                        <div className="flex items-center gap-2 text-xs text-zinc-300 font-medium">
                            <span>📅 Дедлайн: {program.deadline || "Не указан"}</span>
                        </div>
                    </div>
                  </button>
                ))}
              </div>
            </div>
          ))
      )}

      {selectedProgram && (
        <ProgramDetailModal 
            program={selectedProgram} 
            onClose={() => setSelectedProgram(null)} 
        />
      )}
    </div>
  );
}
--- END FILE: apps/web/app/student/programs/page.tsx ---

--- BEGIN FILE: apps/web/app/student/quests/QuestDetailModal.tsx ---
"use client";
import { useEffect, useRef, useState, useCallback } from "react";

const API_URL = process.env.NEXT_PUBLIC_API_URL ?? "http://localhost:4000/api";

import { useProgress, Task } from "@/shared/ProgressContext";

type Props = {
  quest: Task & {
    submission_type?: "none" | "text" | "link" | "file" | "credentials";
    comment?: string; // Добавляем поле комментария
    submission_label?: string; // For simple types
    submission_fields?: { key: string; label: string }[]; // For complex types
  };
  onClose: () => void;
};

export default function QuestDetailModal({ quest, onClose }: Props) {
  const { submitQuest } = useProgress();
  const [inputValue, setInputValue] = useState<any>("");
  const [isEditing, setIsEditing] = useState<boolean>(false);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [uploading, setUploading] = useState(false);
  const [dragActive, setDragActive] = useState(false);

  useEffect(() => {
    // Инициализация значения
    if (quest.submission) {
      setInputValue(quest.submission);
    }
  }, [quest]);

  const handleSubmit = async () => {
    await submitQuest(quest.id, inputValue);
    onClose();
  };

  const handleFileUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
      if (!e.target.files?.[0]) return;
      setUploading(true);
      const formData = new FormData();
      formData.append('file', e.target.files[0]);
      
      try {
          const token = localStorage.getItem("accessToken");
          const res = await fetch(`${API_URL}/files/upload`, {
              method: 'POST',
              headers: { Authorization: `Bearer ${token}` },
              body: formData
          });
          const data = await res.json();
          setInputValue(data.url);
      } catch (err) {
          alert("Ошибка загрузки файла");
      } finally {
          setUploading(false);
      }
  };

  // Drag and Drop handlers
  const handleDrag = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    if (e.type === "dragenter" || e.type === "dragover") {
      setDragActive(true);
    } else if (e.type === "dragleave") {
      setDragActive(false);
    }
  }, []);

  const handleDrop = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);
    if (e.dataTransfer.files && e.dataTransfer.files[0]) {
      // Вызываем тот же обработчик, что и для input
      handleFileUpload({ target: { files: e.dataTransfer.files } } as any);
    }
  }, []);

  return (
    <div
      className="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center p-4 z-50"
      onClick={onClose}
    >
      <div className="w-full max-w-2xl card p-6" onClick={(e) => e.stopPropagation()}>
        <div className="flex items-start justify-between">
          <h2 className="text-xl font-semibold mb-2">{quest.title}</h2>
          <button onClick={onClose}>&times;</button>
        </div>
        
        <div className="prose dark:prose-invert text-sm text-zinc-600 dark:text-zinc-300 mb-4">
            {quest.description}
        </div>

        {/* Блок комментария от куратора, если есть возврат */}
        {quest.status === 'CHANGES_REQUESTED' && (
          <div className="mb-4 p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-xl">
            <p className="text-xs font-bold text-red-600 dark:text-red-400 mb-1">⚠️ Требуются правки:</p>
            <p className="text-sm text-red-800 dark:text-red-200">{quest.comment || "Куратор не оставил комментария, но что-то не так."}</p>
          </div>
        )}

        {/* Динамический инпут */}
        <div className="mt-4">
          {quest.submission_type === 'file' ? (
            <div 
              className={`relative border-2 border-dashed rounded-xl p-6 text-center transition-colors ${
                dragActive 
                  ? "border-blue-500 bg-blue-50 dark:bg-blue-900/20" 
                  : "border-zinc-300 dark:border-zinc-700 hover:border-zinc-400"
              }`}
              onDragEnter={handleDrag}
              onDragLeave={handleDrag}
              onDragOver={handleDrag}
              onDrop={handleDrop}
            >
              <input 
                type="file" 
                ref={fileInputRef} 
                onChange={handleFileUpload} 
                className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
              />
              
              {uploading ? (
                <div className="text-zinc-500 animate-pulse">Загрузка файла...</div>
              ) : inputValue ? (
                <div className="flex flex-col items-center">
                   <div className="text-2xl mb-2">📄</div>
                   <p className="text-sm font-medium text-green-600 mb-1">Файл загружен</p>
                   <a href={inputValue} target="_blank" className="text-xs text-blue-500 hover:underline z-10 relative">Посмотреть</a>
                   <p className="text-xs text-zinc-400 mt-2">Нажмите или перетащите, чтобы заменить</p>
                </div>
              ) : (
                <div className="flex flex-col items-center text-zinc-500">
                  <div className="text-2xl mb-2">☁️</div>
                  <p className="text-sm">Перетащите файл сюда или нажмите для выбора</p>
                </div>
              )}
            </div>
          ) : (
            <textarea 
              className="w-full bg-zinc-50 dark:bg-zinc-800 p-3 rounded-xl border border-zinc-200 dark:border-zinc-700 focus:ring-2 focus:ring-blue-500 outline-none transition"
              placeholder="Введите ответ..."
              value={typeof inputValue === 'string' ? inputValue : JSON.stringify(inputValue)}
              onChange={e => setInputValue(e.target.value)}
              disabled={quest.status === 'DONE'}
            />
          )}
        </div>

        <div className="flex items-center gap-3 mt-4">
            <button
              onClick={handleSubmit}
              disabled={quest.status === 'DONE' || uploading}
              className="btn btn-primary"
            >
              {quest.status === 'DONE' ? 'Выполнено' : 'Отправить'}
            </button>
        </div>
      </div>
    </div>
  );
}
--- END FILE: apps/web/app/student/quests/QuestDetailModal.tsx ---

--- BEGIN FILE: apps/web/app/student/quests/page.tsx ---
"use client";
import { useProgress, Task } from "@/shared/ProgressContext";
import { useState } from "react";
import QuestDetailModal from "./QuestDetailModal";

export default function QuestsPage() {
  const { tasks } = useProgress();
  const [selectedQuest, setSelectedQuest] = useState<Task | null>(null);

  // Группировка по Stage
  const byStage = tasks.reduce<Record<string, Task[]>>((acc, q) => {
    acc[q.stage] = acc[q.stage] || [];
    acc[q.stage].push(q);
    return acc;
  }, {});

  return (
    <>
      <div>
        <h1 className="text-2xl font-semibold mb-2">Мои Квесты</h1>
        <p className="text-zinc-600 dark:text-zinc-300 mb-6">
          Список задач формируется на основе профиля страны.
        </p>
        <div className="space-y-6">
          {Object.entries(byStage).map(([stage, items]) => (
            <section key={stage}>
              <h2 className="text-lg font-semibold mb-3">{stage}</h2>
              <ul className="grid sm:grid-cols-2 gap-3">
                {items.map((q) => {
                  const isDone = q.status === 'DONE';
                  const isReview = q.status === 'REVIEW';

                  return (
                    <li
                      key={q.id}
                      className="card p-4 transition hover:shadow-lg cursor-pointer"
                      onClick={() => setSelectedQuest(q)}
                    >
 <div className="flex items-start justify-between gap-4">
  <div>
 <div className={`font-medium ${isDone ? 'line-through text-zinc-500' : ''}`}>{q.title}</div>
 <div className="text-xs text-yellow-500 font-bold mt-1">XP: {q.xpReward}</div>
  </div>
 {isDone ? <div className="text-2xl" title="Выполнено">✅</div> :
  isReview ? <div className="text-2xl" title="На проверке">⏳</div> :
  <button className="btn btn-primary text-xs">Детали</button>}
 </div>
                    </li>
                  ); 
                })}
              </ul>
            </section>
          ))}
        </div>
      </div>
      {selectedQuest && (
        <QuestDetailModal quest={selectedQuest} onClose={() => setSelectedQuest(null)} />
      )}
    </>
  );
}
--- END FILE: apps/web/app/student/quests/page.tsx ---

--- BEGIN FILE: apps/web/eslint.config.mjs ---
import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;
--- END FILE: apps/web/eslint.config.mjs ---

--- BEGIN FILE: apps/web/lib/utils.ts ---
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
    return twMerge(clsx(inputs))
}
--- END FILE: apps/web/lib/utils.ts ---

--- BEGIN FILE: apps/web/mock/countries.json ---
[
  {
    "id": "at",
    "name": "Австрия",
    "flag_icon": "🇦🇹",
    "required_document_ids": [101, 102, 201, 202, 203, 301, 302, 303, 401, 501, 502, 503, 504],
    "required_quest_ids": [1, 2, 10, 11, 12, 13, 20, 30]
  },
  {
    "id": "it",
    "name": "Италия",
    "flag_icon": "🇮🇹",
    "required_document_ids": [101, 102, 201, 202, 203, 301, 302, 303, 401, 402, 501, 502, 503, 504],
    "required_quest_ids": [1, 2, 10, 11, 12, 13, 20, 21, 30]
  }
]
--- END FILE: apps/web/mock/countries.json ---

--- BEGIN FILE: apps/web/mock/document_templates.json ---
[
  { "id": 101, "category": "Личные данные", "title": "Загранпаспорт (главный разворот)" },
  { "id": 102, "category": "Личные данные", "title": "Фотография (как на паспорт)" },

  { "id": 201, "category": "Образование: Школа (9 классов)", "title": "Оригинал аттестата с приложением" },
  { "id": 202, "category": "Образование: Школа (9 классов)", "title": "Апостиль на аттестат" },
  { "id": 203, "category": "Образование: Школа (9 классов)", "title": "Нотариально заверенный перевод аттестата с апостилем" },

  { "id": 301, "category": "Образование: Колледж", "title": "Оригинал диплома с приложением" },
  { "id": 302, "category": "Образование: Колледж", "title": "Апостиль на диплом" },
  { "id": 303, "category": "Образование: Колледж", "title": "Нотариально заверенный перевод диплома с апостилем" },

  { "id": 401, "category": "Язык и Экзамены", "title": "Сертификат IELTS Academic" },
  { "id": 402, "category": "Язык и Экзамены", "title": "Результаты экзамена TOLC-I" },

  { "id": 501, "category": "Творческие документы", "title": "Резюме (CV)" },
  { "id": 502, "category": "Творческие документы", "title": "Мотивационное письмо (общий шаблон)" },
  { "id": 503, "category": "Творческие документы", "title": "Рекомендательное письмо #1" },
  { "id": 504, "category": "Творческие документы", "title": "Рекомендательное письмо #2" }
]
--- END FILE: apps/web/mock/document_templates.json ---

--- BEGIN FILE: apps/web/mock/programs.json ---
[
  {
    "id": 1001,
    "title": "Бакалавр: Компьютерные науки",
    "university_id": "tu_wien",
    "deadline": "2026-02-15",
    "link": "https://www.tuwien.at/en/studies/admission/bachelors-programmes-with-selection-procedure-or-entrance-exam/computer-sciences/",
    "image_url": "https://www.educationcenter.cz/assets/images/ru/blog/vsyo-chto-nuzhno-znat-o-venskom-tehnicheskom-universitete-TU-Wien/vsyo-chto-nuzhno-znat-o-venskom-tehnicheskom-universitete-TU-Wien.jpg",
    "required_document_ids": [501, 502, 503]
  },
  {
    "id": 1002,
    "title": "Бакалавр: Архитектура",
    "university_id": "tu_wien",
    "deadline": "2026-03-01",
    "link": "https://www.tuwien.at/en/studies/studies/bachelors-programmes/architecture-033-243/",
    "image_url": "https://www.educationcenter.cz/assets/images/ru/blog/vsyo-chto-nuzhno-znat-o-venskom-tehnicheskom-universitete-TU-Wien/vsyo-chto-nuzhno-znat-o-venskom-tehnicheskom-universitete-TU-Wien.jpg",
    "required_document_ids": [501, 502, 504]
  },
  {
    "id": 2001,
    "title": "Bachelor: Genomics",
    "university_id": "unibo",
    "deadline": "2026-04-10",
    "link": "https://www.unibo.it/en/teaching/course-unit-catalogue/course-unit/2023/46231",
    "image_url": "https://static.tildacdn.pro/tild3530-6661-4735-b266-323538636333/9873e9ee7f00010176f0.jpg",
    "required_document_ids": [501, 502, 402]
  }
]
--- END FILE: apps/web/mock/programs.json ---

--- BEGIN FILE: apps/web/mock/quest_templates.json ---
[
  {
    "id": 1,
    "stage": "Подготовка",
    "title": "Создать специальную почту Gmail",
    "xp": 20,
    "description": "Создайте новый аккаунт Gmail специально для поступления. Используйте имя и фамилию как в загранпаспорте. Это поможет избежать путаницы и потери важных писем от университетов и визовых центров.",
    "deadline": "2025-11-10",
    "links_to_document_id": null,
    "submission_type": "credentials",
    "submission_fields": [
      { "key": "email", "label": "Логин (email)" },
      { "key": "password", "label": "Пароль" }
    ]
  },
  {
    "id": 2,
    "stage": "Подготовка",
    "title": "Создать папку в облаке и настроить резервные копии",
    "xp": 20,
    "description": "Ваш цифровой архив — залог спокойствия. План действий:\n\n1. **Выберите сервис:** Google Drive или Dropbox отлично подойдут.\n2. **Создайте главную папку:** Назовите ее, например, «Документы для поступления 2026».\n3. **Организуйте структуру:** Внутри создайте подпапки: «Паспорт», «Образование», «Сертификаты», «Фото» и т.д. Это сэкономит вам массу времени в будущем.",
    "deadline": "2025-10-30",
    "links_to_document_id": null,
    "submission_type": "link",
    "submission_label": "Ссылка на папку в облаке"
  },
  {
    "id": 10,
    "stage": "Личные документы",
    "title": "Сфотографировать и загрузить загранпаспорт",
    "xp": 30,
    "description": "Сделайте качественный цветной скан или фотографию главного разворота вашего загранпаспорта. Убедитесь, что все данные хорошо читаемы, нет бликов и пальцев в кадре.",
    "deadline": "2025-11-20",
    "links_to_document_id": 101,
    "submission_type": "file",
    "submission_label": "Файл загранпаспорта"
  },
  {
    "id": 11,
    "stage": "Личные документы",
    "title": "Сделать фото как на паспорт",
    "xp": 30,
    "description": "Сделайте цифровую фотографию паспортного формата (обычно 3.5x4.5 см) на светлом фоне. Она понадобится для анкет и студенческого билета.",
    "deadline": "2025-11-25",
    "links_to_document_id": 102,
    "submission_type": "file",
    "submission_label": "Файл с фотографией"
  },
  {
    "id": 12,
    "stage": "Личные документы",
    "title": "Собрать школьные документы с апостилем и переводом",
    "xp": 50,
    "description": "Это многоступенчатый квест, который требует последовательности. Вот ваш план действий:\n\n**1. Подготовка оригинала:** Убедитесь, что у вас на руках есть оригинал школьного аттестата и приложение с оценками.\n**2. Проставление Апостиля:** Обратитесь в региональный Департамент (или Министерство) Образования. Именно они уполномочены ставить апостиль на образовательные документы. Уточните их график приема и необходимые документы (обычно паспорт и заявление).\n**3. Нотариальный перевод:** После получения документа с апостилем, найдите присяжного или аккредитованного переводчика. Важно, чтобы перевод был выполнен профессионалом, а затем нотариально заверен. Переводится как сам документ, так и штамп апостиля.",
    "deadline": "2025-12-15",
    "links_to_document_id": 201,
    "submission_type": "file",
    "submission_label": "PDF-файл аттестата с апостилем и переводом"
  },
  {
    "id": 13,
    "stage": "Личные документы",
    "title": "Собрать документы колледжа с апостилем и переводом",
    "xp": 50,
    "description": "Процесс для диплома колледжа или техникума полностью повторяет квест со школьным аттестатом. План действий тот же:\n\n**1. Подготовка оригинала:** Возьмите оригинал диплома и приложение к нему.\n**2. Проставление Апостиля:** Найдите ваш региональный Департамент (Министерство) Образования. Они поставят апостиль на диплом, подтвердив его легальность для использования за границей.\n**3. Нотариальный перевод:** С готовым апостилем обратитесь к аккредитованному переводчику для выполнения нотариально заверенного перевода на язык целевой страны.",
    "deadline": "2025-12-15",
    "links_to_document_id": 301,
    "submission_type": "file",
    "submission_label": "PDF-файл диплома с апостилем и переводом"
  },
  {
    "id": 20,
    "stage": "Экзамены",
    "title": "Зарегистрироваться и сдать IELTS Academic",
    "xp": 80,
    "description": "Это важный экзамен, подтверждающий ваше владение английским языком. План действий:\n\n**1. Поиск центра:** Найдите официальный центр сдачи IELTS в вашем городе (например, на сайтах British Council или IDP).\n**2. Регистрация:** Выберите тип экзамена 'Academic' и зарегистрируйтесь на удобную для вас дату. Места могут заканчиваться, поэтому делайте это заранее.\n**3. Подготовка:** Используйте официальные материалы для подготовки, чтобы ознакомиться с форматом и типами заданий. Цельтесь в балл не ниже 6.5, если иное не указано университетом.",
    "deadline": "2026-01-30",
    "links_to_document_id": 401,
    "submission_type": "file",
    "submission_label": "Сертификат IELTS"
  },
  {
    "id": 21,
    "stage": "Экзамены",
    "title": "Зарегистрироваться и сдать экзамен TOLC-I",
    "xp": 100,
    "description": "TOLC-I — это ключ к инженерным и научным факультетам в Италии. Ваш план:\n\n**1. Регистрация на CISIA:** Зайдите на официальный сайт CISIA Online, создайте аккаунт и выберите тип теста 'TOLC-I'.\n**2. Выбор даты и формата:** Вы можете выбрать сдачу онлайн (TOLC@CASA) или в аккредитованном центре. Выберите удобный слот.\n**3. Изучение структуры:** Экзамен состоит из секций: Математика, Логика, Науки и Понимание текста. Ознакомьтесь с темами и примерами заданий на сайте CISIA, чтобы эффективно подготовиться.",
    "deadline": "2026-02-20",
    "links_to_document_id": 402,
    "submission_type": "file",
    "submission_label": "Результаты TOLC-I"
  },
  {
    "id": 30,
    "stage": "Творческие документы",
    "title": "Подготовить CV и мотивационное письмо",
    "xp": 60,
    "description": "Эти документы — ваше лицо перед приемной комиссией. Следуйте этому плану:\n\n**1. Резюме (CV):** Используйте стандартный европейский формат 'Europass'. Это онлайн-конструктор, который поможет вам правильно структурировать информацию: образование, опыт работы (если есть), навыки, языки.\n**2. Мотивационное письмо:** Напишите универсальный шаблон (около 500 слов), где вы рассказываете о себе, своих академических целях и почему вы выбрали эту специальность. Этот шаблон вы будете адаптировать под требования каждого конкретного университета.",
    "deadline": "2026-02-10",
    "links_to_document_id": 501,
    "submission_type": "file",
    "submission_label": "Файл с CV и письмом"
  }
]
--- END FILE: apps/web/mock/quest_templates.json ---

--- BEGIN FILE: apps/web/mock/student_progress.json ---
{
  "1": {
    "1": { "status": "done", "submission": { "email": "artem.g@example.com", "password": "..." } },
    "2": { "status": "review", "submission": "https://link-to-drive.com" },
    "10": { "status": "done", "submission": "passport_artem.pdf" },
    "11": { "status": "done", "submission": "photo_artem.jpg" },
    "21": { "status": "done", "submission": "tolc_results.pdf" }
  },
  "2": {
    "1": { "status": "done", "submission": { "email": "veronika.s@example.com", "password": "..." } },
    "10": { "status": "review", "submission": "passport_veronika.pdf" },
    "12": { "status": "done", "submission": "school_docs_veronika.pdf" }
  },
  "3": {
     "1": { "status": "review", "submission": { "email": "ivan.p@example.com", "password": "..." } }
  }
}
--- END FILE: apps/web/mock/student_progress.json ---

--- BEGIN FILE: apps/web/mock/students.json ---
[
  {
    "id": 1,
    "name": "Артём Ганеев",
    "email": "artem.g@example.com",
    "country_id": "it",
    "gpa": 4.04,
    "ielts_score": 6.0,
    "selected_program_ids": [1001, 2001]
  },
  {
    "id": 2,
    "name": "Вероника Смирнова",
    "email": "veronika.s@example.com",
    "country_id": "at",
    "gpa": 4.5,
    "ielts_score": 6.5,
    "selected_program_ids": [1001, 1002]
  },
  {
    "id": 3,
    "name": "Иван Петров",
    "email": "ivan.p@example.com",
    "country_id": "at",
    "gpa": 3.8,
    "ielts_score": 5.5,
    "selected_program_ids": [1002]
  }
]
--- END FILE: apps/web/mock/students.json ---

--- BEGIN FILE: apps/web/mock/universities.json ---
[
  {
    "id": "tu_wien",
    "name": "Венский технический университет (TU Wien)",
    "logo_url": "🎓",
    "program_ids": [1001, 1002]
  },
  {
    "id": "unibo",
    "name": "Болонский университет (Università di Bologna)",
    "logo_url": "🏛️",
    "program_ids": [2001]
  }
]
--- END FILE: apps/web/mock/universities.json ---

--- BEGIN FILE: apps/web/mock/university_profiles.json ---
[
  {
    "universityId": "tu_wien",
    "countryId": "at",
    "assignedQuests": [
      {
        "id": 1,
        "stage": "Подготовка",
        "title": "Создать специальную почту Gmail",
        "xp": 20,
        "description": "Создайте новый аккаунт Gmail специально для поступления. Используйте имя и фамилию как в загранпаспорте."
      },
      {
        "id": 10,
        "stage": "Личные документы",
        "title": "Сфотографировать и загрузить загранпаспорт",
        "xp": 30,
        "description": "Сделайте качественный цветной скан или фотографию главного разворота вашего загранпаспорта."
      }
    ]
  },
  {
    "universityId": "unibo",
    "countryId": "it",
    "assignedQuests": [
      {
        "id": 1,
        "stage": "Подготовка",
        "title": "Создать специальную почту Gmail",
        "xp": 20,
        "description": "Создайте новый аккаунт Gmail специально для поступления. Используйте имя и фамилию как в загранпаспорте."
      },
      {
        "id": 21,
        "stage": "Экзамены",
        "title": "Сдать экзамен TOLC-I (для Болоньи)",
        "xp": 120,
        "description": "TOLC-I — это ключ к инженерным и научным факультетам в Италии. Для Болонского университета требуется особый подход к подготовке."
      }
    ]
  }
]
--- END FILE: apps/web/mock/university_profiles.json ---

--- BEGIN FILE: apps/web/next-env.d.ts ---
/// <reference types="next" />
/// <reference types="next/image-types/global" />
import "./.next/dev/types/routes.d.ts";

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.
--- END FILE: apps/web/next-env.d.ts ---

--- BEGIN FILE: apps/web/next.config.ts ---
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
--- END FILE: apps/web/next.config.ts ---

--- BEGIN FILE: apps/web/package.json ---
{
  "name": "applicant-web",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev -H 0.0.0.0 --port 3000",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-slot": "^1.2.4",
    "clsx": "^2.1.1",
    "lucide-react": "^0.562.0",
    "next": "16.0.0",
    "react": "19.2.0",
    "react-dom": "19.2.0",
    "tailwind-merge": "^3.4.0",
    "zustand": "^5.0.0"
  },
  "devDependencies": {
    "@playwright/test": "^1.40.0",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "16.0.0",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}
--- END FILE: apps/web/package.json ---

--- BEGIN FILE: apps/web/playwright.config.ts ---
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './tests/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
  ],
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI,
  },
});
--- END FILE: apps/web/playwright.config.ts ---

--- BEGIN FILE: apps/web/postcss.config.mjs ---
const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

export default config;
--- END FILE: apps/web/postcss.config.mjs ---

--- BEGIN FILE: apps/web/shared/AuthContext.tsx ---
"use client";
import { useRouter } from "next/navigation";
import React, { createContext, useContext, useEffect, useState } from "react";

const API_URL = process.env.NEXT_PUBLIC_API_URL ?? "http://localhost:4000/api";

type User = {
  id: string;
  email: string;
  name: string;
  role: "student" | "curator" | "admin";
  countryId?: string;
  curatorId?: string; // <-- Добавили
};


type AuthContextType = {
  user: User | null;
  loading: boolean;
  login: (email: string, password: string) => Promise<void>;
  register: (data: any) => Promise<void>;
  logout: () => void;
};

const AuthCtx = createContext<AuthContextType | null>(null);

export const AuthProvider: React.FC<React.PropsWithChildren> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const router = useRouter();

  const fetchProfile = async (token: string) => {
      try {
          const res = await fetch(`${API_URL}/auth/me`, {
              headers: { Authorization: `Bearer ${token}` }
          });
          if (res.ok) {
              const profile = await res.json();
              setUser(profile);
          } else {
              logout();
          }
      } catch (e) {
          logout();
      } finally {
          setLoading(false);
      }
  };

  useEffect(() => {
      const token = localStorage.getItem("accessToken");
      if (token) {
          fetchProfile(token);
      } else {
          setLoading(false);
      }
  }, []);

  const login = async (email: string, password: string) => {
    const res = await fetch(`${API_URL}/auth/login`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email, password })
    });
    
    if (!res.ok) throw new Error("Invalid credentials");
    
    const data = await res.json();
    localStorage.setItem("accessToken", data.accessToken);
    await fetchProfile(data.accessToken);
    // Редирект теперь обрабатывается в useEffect на странице логина
  };

  const register = async (data: any) => {
      const res = await fetch(`${API_URL}/auth/register`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(data)
      });

      if (!res.ok) {
          const err = await res.json();
          throw new Error(err.message || "Register failed");
      }

      // Auto login
      const loginData = await res.json();
      localStorage.setItem("accessToken", loginData.accessToken);
      await fetchProfile(loginData.accessToken);
      // Редирект теперь обрабатывается в useEffect на странице логина
  };

  const logout = () => {
    localStorage.removeItem("accessToken");
    setUser(null);
    router.replace("/login");
  };

  const value = { user, loading, login, register, logout };

  return <AuthCtx.Provider value={value}>{children}</AuthCtx.Provider>;
};

export const useAuth = () => {
  const ctx = useContext(AuthCtx);
  if (!ctx) throw new Error("useAuth must be used within an AuthProvider");
  return ctx;
};
--- END FILE: apps/web/shared/AuthContext.tsx ---

--- BEGIN FILE: apps/web/shared/Avatar.tsx ---
import { useMemo } from "react";

type Props = {
  name: string;
  level: number;
  className?: string;
};

export default function Avatar({ name, level, className = "w-16 h-16" }: Props) {
  // Генерируем стабильные цвета на основе имени
  const colors = useMemo(() => {
    let hash = 0;
    for (let i = 0; i < name.length; i++) {
      hash = name.charCodeAt(i) + ((hash << 5) - hash);
    }
    const hue = Math.abs(hash % 360);
    return {
      bg: `hsl(${hue}, 70%, 85%)`,
      text: `hsl(${hue}, 80%, 30%)`,
      accent: `hsl(${(hue + 45) % 360}, 80%, 60%)`
    };
  }, [name]);

  return (
    <div className={`relative rounded-full flex items-center justify-center font-bold shadow-inner ${className}`} style={{ backgroundColor: colors.bg, color: colors.text }}>
      <div className="z-10 text-xl">
        {name[0]?.toUpperCase()}
      </div>
      
      {/* Декоративное кольцо уровня */}
      <svg className="absolute inset-0 w-full h-full -rotate-90" viewBox="0 0 36 36">
        <path
          className="text-white/40"
          d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"
          fill="none"
          stroke="currentColor"
          strokeWidth="3"
        />
        <path
          style={{ color: colors.accent }}
          strokeDasharray={`${Math.min(level * 10, 100)}, 100`}
          d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"
          fill="none"
          stroke="currentColor"
          strokeWidth="3"
        />
      </svg>
      
      {/* Бейдж уровня */}
      <div className="absolute -bottom-1 -right-1 bg-black text-white text-[10px] w-5 h-5 flex items-center justify-center rounded-full border-2 border-white dark:border-zinc-900">
        {level}
      </div>
    </div>
  );
}
--- END FILE: apps/web/shared/Avatar.tsx ---

--- BEGIN FILE: apps/web/shared/Calendar.tsx ---
"use client";
import { useState, useMemo } from "react";

export type CalendarEvent = {
  date: string; // YYYY-MM-DD
  title: string;
  type: 'quest' | 'program' | 'custom';
};

type Props = {
  events: CalendarEvent[];
};

export default function Calendar({ events }: Props) {
  const [currentDate, setCurrentDate] = useState(new Date("2025-10-24T12:00:00Z"));

  const handlePrevMonth = () => setCurrentDate(d => new Date(d.getFullYear(), d.getMonth() - 1, 1));
  const handleNextMonth = () => setCurrentDate(d => new Date(d.getFullYear(), d.getMonth() + 1, 1));

  const daysInMonth = useMemo(() => {
    const year = currentDate.getFullYear();
    const month = currentDate.getMonth();
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);

    const days = [];
    // Pad start with previous month's days
    for (let i = 0; i < firstDay.getDay(); i++) {
      days.push(null);
    }
    // Add current month's days
    for (let i = 1; i <= lastDay.getDate(); i++) {
      days.push(new Date(year, month, i));
    }
    return days;
  }, [currentDate]);

  const eventColors = {
    quest: 'bg-blue-500/20 text-blue-300 border-blue-500/50',
    program: 'bg-red-500/20 text-red-300 border-red-500/50',
    custom: 'bg-green-500/20 text-green-300 border-green-500/50',
  };

  return (
    <div className="bg-zinc-800/50 border border-zinc-700/50 rounded-2xl p-4">
      {/* Header */}
      <div className="flex items-center justify-between mb-4">
        <button onClick={handlePrevMonth} className="btn text-xl">‹</button>
        <h2 className="text-xl font-semibold">
          {currentDate.toLocaleString('ru-RU', { month: 'long', year: 'numeric' })}
        </h2>
        <button onClick={handleNextMonth} className="btn text-xl">›</button>
      </div>

      {/* Grid */}
      <div className="grid grid-cols-7 gap-1">
        {['Вс', 'Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб'].map(day => (
          <div key={day} className="text-center text-xs text-zinc-400 font-semibold py-2">{day}</div>
        ))}
        {daysInMonth.map((day, index) => (
          <div key={index} className="h-32 border border-zinc-700/50 bg-zinc-900/50 rounded-lg p-1.5 overflow-hidden">
            {day && (
              <>
                <span className="text-xs font-bold">{day.getDate()}</span>
                <div className="mt-1 space-y-1 overflow-y-auto max-h-24 pr-1">
                  {events
                    .filter(e => e.date === day.toISOString().split('T')[0])
                    .map((event, eventIndex) => (
                       <div
                         key={eventIndex}
                         className={`text-[10px] p-1 rounded border-l-2 ${eventColors[event.type]}`}
                         title={event.title}
                       >
                         {event.title}
                       </div>
                    ))
                  }
                </div>
              </>
            )}
          </div>
        ))}
      </div>
    </div>
  );
}
--- END FILE: apps/web/shared/Calendar.tsx ---

--- BEGIN FILE: apps/web/shared/CountryContext.tsx ---
"use client";
import React, { createContext, useContext, useEffect, useMemo, useState } from "react";
import questTemplates from "@/mock/quest_templates.json";
import docTemplates from "@/mock/document_templates.json";
import universityTemplates from "@/mock/universities.json";
import programTemplates from "@/mock/programs.json";
import { useAuth } from "./AuthContext";

const API_URL = process.env.NEXT_PUBLIC_API_URL ?? "http://localhost:4000/api";

export type CountryProfile = {
  id: string;
  name: string;
  flag_icon: string;
  required_document_ids: number[];
  required_quest_ids: number[];
};

export type QuestTemplate = {
  id: number;
  countryId?: number;
  universityId?: number;
  stage: string;
  title: string;
  xpReward: number; // Renamed from xp
  description: string;
  deadline: string;
  links_to_document_id: number | null;
};

export type DocumentTemplate = {
  id: number;
  category: string;
  title: string;
};

// --- НОВОЕ: Добавлены типы для университетов и программ ---
export type University = {
  id: string;
  name: string;
  logo_url: string;
  program_ids: number[];
  countryId: string;
};

export type Program = {
  id: number;
  title: string;
  category?: string; // <--- Добавлено поле
  university_id: string;
  deadline: string;
  link: string;
  image_url: string;
  required_document_ids: number[];
};

type Ctx = {
  countries: CountryProfile[];
  selectedCountryId: string;
  setSelectedCountryId: (id: string) => void;
  selectedCountry: CountryProfile | undefined;
  quests: QuestTemplate[];
  documents: DocumentTemplate[];
  universities: University[];
  programs: Program[];
  refreshData: () => Promise<void>;
};

const CountryCtx = createContext<Ctx | null>(null);

function readOverrides(): CountryProfile[] | null {
  if (typeof window === "undefined") return null;
  try {
    const raw = localStorage.getItem("countriesOverride");
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (Array.isArray(parsed)) return parsed as CountryProfile[];
    return null;
  } catch {
    return null;
  }
}

export const CountryProvider: React.FC<React.PropsWithChildren> = ({ children }) => {
  const { user } = useAuth();
  const [countries, setCountries] = useState<CountryProfile[]>([]);
  const [universities, setUniversities] = useState<University[]>([]);
  const [quests, setQuests] = useState<QuestTemplate[]>([]);
  const [selectedCountryId, setSelectedCountryIdState] = useState<string>("");

  const refreshData = async () => {
      const token = localStorage.getItem("accessToken");
      // Явно указываем тип, чтобы TS не ругался на несовместимость с HeadersInit
      const headers: Record<string, string> = {};
      if (token) {
          headers["Authorization"] = `Bearer ${token}`;
      }

      try {
        const [resC, resU, resQ] = await Promise.all([
            fetch(`${API_URL}/countries`, { headers }),
            fetch(`${API_URL}/admin/universities`, { headers }),
            fetch(`${API_URL}/admin/task-templates`, { headers })
        ]);

        if (resC.ok) {
             const cData = await resC.json();
             setCountries(cData.map((c: any) => ({
                 id: c.id, name: c.name, flag_icon: c.flagIcon,
                 required_document_ids: [], required_quest_ids: [] 
             })));
        }
        if (resU.ok) {
            const uData = await resU.json();
            setUniversities(uData.map((u: any) => ({
                id: u.id, name: u.name, logo_url: u.logoUrl || '🎓', program_ids: [], countryId: u.countryId
            })));
        }
        if (resQ.ok) {
            const qData = await resQ.json();
            setQuests(qData);
        }
      } catch (e) {
          console.error("Failed to load data", e);
      }
  };

  useEffect(() => {
      refreshData();
  }, [user]);

  useEffect(() => {
      if (countries.length > 0 && !selectedCountryId) {
          if (user?.countryId) {
              setSelectedCountryIdState(user.countryId);
          } else {
              setSelectedCountryIdState(countries[0].id);
          }
      }
  }, [countries, user]);

  const setSelectedCountryId = (id: string) => {
    setSelectedCountryIdState(id);
  };

  const selectedCountry = useMemo(
    () => countries.find((c) => c.id === selectedCountryId),
    [countries, selectedCountryId]
  );

  // Используем any для расширения типа контекста в рантайме, либо нужно обновить тип Ctx выше
  const value: any = {
    countries,
    selectedCountryId,
    setSelectedCountryId,
    selectedCountry,
    quests, // Теперь динамические квесты
    documents: docTemplates as DocumentTemplate[],
    universities, // Теперь динамические вузы
    programs: programTemplates as Program[],
    refreshData, // Экспортируем функцию обновления
  };

  return <CountryCtx.Provider value={value}>{children}</CountryCtx.Provider>;
};

export function useCountry() {
  const ctx = useContext(CountryCtx);
  if (!ctx) throw new Error("useCountry must be used within CountryProvider");
  return ctx;
}
--- END FILE: apps/web/shared/CountryContext.tsx ---

--- BEGIN FILE: apps/web/shared/CountrySwitcher.tsx ---
"use client";
import { useCountry } from "./CountryContext";

export default function CountrySwitcher() {
  const { countries, selectedCountryId, setSelectedCountryId } = useCountry();
  return (
    <div className="relative group">
       <select
        className="w-full appearance-none rounded-xl border border-transparent hover:border-zinc-200 dark:hover:border-zinc-700 px-3 py-1.5 bg-transparent text-sm font-medium cursor-pointer focus:outline-none focus:ring-2 focus:ring-blue-500/20 transition"
         value={selectedCountryId}
         onChange={(e) => setSelectedCountryId(e.target.value)}
         aria-label="Переключатель страны"
       >
         {countries.map((c) => (
           <option key={c.id} value={c.id}>
             {c.flag_icon} {c.name}
           </option>
         ))}
       </select>
      <div className="absolute right-2 top-1/2 -translate-y-1/2 pointer-events-none text-xs text-zinc-400">▼</div>
     </div>
   );

}
--- END FILE: apps/web/shared/CountrySwitcher.tsx ---

--- BEGIN FILE: apps/web/shared/DocumentUploadModal.tsx ---
"use client";

import React, { useState, useEffect, useRef } from 'react';
import * as Dialog from '@radix-ui/react-dialog';
import { X, Check, FileText, AlertCircle, Upload, ChevronRight, GraduationCap, User, ShieldCheck } from 'lucide-react';
import { cn } from '@/lib/utils';
// DOCUMENT_GUIDELINES import removed as we use backend data now
import { DocumentType } from './documentData'; // Keep type if needed, or remove if fully dynamic

type UploadStatus = 'idle' | 'uploading' | 'success' | 'error';

interface DocumentRequirement {
    id: number; // Template ID
    title: string;
    step_order: number;
    document_type: string;
    advice_text: string;
    validation_rules: string[];
    rejection_reasons: string[];
    studentDocument: {
        id: string;
        status: 'MISSING' | 'PENDING' | 'APPROVED' | 'REJECTED';
        minio_file_path?: string;
        manager_comment?: string;
    } | null;
    status: 'MISSING' | 'PENDING' | 'APPROVED' | 'REJECTED';
}

interface DocumentUploadModalProps {
    isOpen: boolean;
    onClose: () => void;
}

export function DocumentUploadModal({ isOpen, onClose }: DocumentUploadModalProps) {
    const [requirements, setRequirements] = useState<DocumentRequirement[]>([]);
    const [currentStepIndex, setCurrentStepIndex] = useState(0);
    const [isLoading, setIsLoading] = useState(false);
    const [uploading, setUploading] = useState(false);
    const fileInputRef = useRef<HTMLInputElement>(null);

    // Fetch requirements
    const fetchRequirements = async () => {
        try {
            setIsLoading(true);
            const res = await fetch('/api/documents/requirements', {
                headers: {
                    'Authorization': `Bearer ${localStorage.getItem('accessToken')}` // Assuming logic
                }
            });
            if (res.ok) {
                const data = await res.json();
                setRequirements(data);
            }
        } catch (error) {
            console.error("Failed to fetch requirements", error);
        } finally {
            setIsLoading(false);
        }
    };

    useEffect(() => {
        if (isOpen) {
            fetchRequirements();
        }
    }, [isOpen]);

    const activeRequirement = requirements[currentStepIndex];

    const handleFileSelect = async (e: React.ChangeEvent<HTMLInputElement>) => {
        if (e.target.files && e.target.files[0] && activeRequirement) {
            await handleUpload(e.target.files[0], activeRequirement.id);
        }
    };

    const handleUpload = async (file: File, templateId: number) => {
        setUploading(true);
        try {
            const formData = new FormData();
            formData.append('file', file);
            formData.append('template_id', templateId.toString());

            const res = await fetch('/api/documents/upload', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${localStorage.getItem('accessToken')}`
                },
                body: formData
            });

            if (res.ok) {
                // Refetch to update status
                await fetchRequirements();
            } else {
                console.error("Upload failed");
            }
        } catch (error) {
            console.error("Upload error", error);
        } finally {
            setUploading(false);
            if (fileInputRef.current) {
                fileInputRef.current.value = '';
            }
        }
    };

    const getIconForType = (type: string) => {
        switch (type) {
            case 'passport': return User;
            case 'education': return GraduationCap;
            case 'translation': return ShieldCheck;
            default: return FileText;
        }
    };

    if (!isOpen) return null;

    return (
        <Dialog.Root open={isOpen} onOpenChange={onClose}>
            <Dialog.Portal>
                <Dialog.Overlay className="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 animate-in fade-in" />
                <Dialog.Content className="fixed left-[50%] top-[50%] z-50 grid w-full max-w-4xl translate-x-[-50%] translate-y-[-50%] gap-4 border bg-white p-0 shadow-lg duration-200 animate-in fade-in-0 zoom-in-95 sm:rounded-xl md:w-full overflow-hidden">

                    <div className="flex flex-col md:flex-row h-[600px]">
                        {/* Left Side: Navigation & Form */}
                        <div className="flex-1 flex flex-col p-6 md:p-8 bg-gray-50/50">
                            <div className="flex items-center justify-between mb-8">
                                <Dialog.Title className="text-xl font-semibold tracking-tight">
                                    Загрузка документов
                                </Dialog.Title>
                                <Dialog.Close className="rounded-full p-2 hover:bg-gray-100 transition-colors">
                                    <X className="h-4 w-4" />
                                </Dialog.Close>
                            </div>

                            {isLoading ? (
                                <div className="flex-1 flex items-center justify-center">Loading...</div>
                            ) : (
                                <>
                                    {/* Stepper */}
                                    <div className="mb-8 overflow-x-auto">
                                        <nav aria-label="Progress">
                                            <ol role="list" className="flex items-center min-w-max">
                                                {requirements.map((req, index) => {
                                                    const isActive = index === currentStepIndex;
                                                    const isCompleted = req.status === 'APPROVED' || req.status === 'PENDING';
                                                    const Icon = getIconForType(req.document_type);

                                                    return (
                                                        <li key={req.id} className={cn("relative", index !== requirements.length - 1 ? "pr-8 sm:pr-20" : "")}>
                                                            {index !== requirements.length - 1 && (
                                                                <div className="absolute top-4 left-0 -right-8 sm:-right-20 h-0.5 bg-gray-200" aria-hidden="true">
                                                                    <div className={cn("h-full bg-blue-600 transition-all duration-300", index < currentStepIndex ? "w-full" : "w-0")} />
                                                                </div>
                                                            )}
                                                            <button
                                                                onClick={() => setCurrentStepIndex(index)}
                                                                className="group relative flex flex-col items-center group"
                                                            >
                                                                <span className={cn(
                                                                    "flex h-8 w-8 items-center justify-center rounded-full border-2 transition-colors z-10 bg-white",
                                                                    isActive ? "border-blue-600 bg-white" : isCompleted ? "border-blue-600 bg-blue-600" : "border-gray-300"
                                                                )}>
                                                                    {isCompleted ? (
                                                                        <Check className="h-5 w-5 text-white" />
                                                                    ) : (
                                                                        <Icon className={cn("h-4 w-4", isActive ? "text-blue-600" : "text-gray-500")} />
                                                                    )}
                                                                </span>
                                                                <span className={cn(
                                                                    "mt-2 text-xs font-medium transition-colors absolute top-8 whitespace-nowrap",
                                                                    isActive ? "text-blue-600" : "text-gray-500"
                                                                )}>
                                                                    {req.title}
                                                                </span>
                                                            </button>
                                                        </li>
                                                    );
                                                })}
                                            </ol>
                                        </nav>
                                    </div>

                                    {/* Upload Area */}
                                    <div
                                        onClick={() => fileInputRef.current?.click()}
                                        className={cn(
                                            "flex-1 flex flex-col items-center justify-center border-2 border-dashed border-gray-200 rounded-xl bg-white p-8 hover:border-blue-400 hover:bg-blue-50/30 transition-all cursor-pointer group",
                                            uploading && "opacity-50 pointer-events-none"
                                        )}
                                    >
                                        <input
                                            type="file"
                                            ref={fileInputRef}
                                            className="hidden"
                                            onChange={handleFileSelect}
                                            accept=".pdf,.jpg,.jpeg,.png"
                                        />

                                        {activeRequirement?.status === 'PENDING' ? (
                                            <div className="text-center">
                                                <div className="h-16 w-16 bg-yellow-50 rounded-full flex items-center justify-center mb-4 mx-auto">
                                                    <Check className="h-8 w-8 text-yellow-600" />
                                                </div>
                                                <h3 className="text-lg font-medium text-gray-900 mb-1">Файл отправлен</h3>
                                                <p className="text-sm text-gray-500 mb-4">Ожидает проверки менеджером</p>
                                                <p className="text-xs text-blue-600 underline">Загрузить другую версию?</p>
                                            </div>
                                        ) : activeRequirement?.status === 'APPROVED' ? (
                                            <div className="text-center">
                                                <div className="h-16 w-16 bg-green-50 rounded-full flex items-center justify-center mb-4 mx-auto">
                                                    <Check className="h-8 w-8 text-green-600" />
                                                </div>
                                                <h3 className="text-lg font-medium text-gray-900 mb-1">Документ принят</h3>
                                                <p className="text-sm text-gray-500">Все отлично!</p>
                                            </div>
                                        ) : (
                                            <>
                                                <div className="h-16 w-16 bg-blue-50 rounded-full flex items-center justify-center mb-4 group-hover:scale-110 transition-transform">
                                                    {uploading ? <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div> : <Upload className="h-8 w-8 text-blue-600" />}
                                                </div>
                                                <h3 className="text-lg font-medium text-gray-900 mb-1">
                                                    {uploading ? "Загрузка..." : "Перетащите файл сюда"}
                                                </h3>
                                                <p className="text-sm text-gray-500 text-center max-w-xs mb-4">
                                                    Поддерживаются PDF, JPG, PNG (макс. 10Мб)
                                                </p>
                                                <button className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors font-medium text-sm shadow-sm hover:shadow dark:bg-blue-600 dark:hover:bg-blue-700">
                                                    Выбрать файл
                                                </button>
                                            </>
                                        )}
                                    </div>

                                    <div className="mt-6 flex justify-between">
                                        <button
                                            onClick={() => setCurrentStepIndex(Math.max(0, currentStepIndex - 1))}
                                            disabled={currentStepIndex === 0}
                                            className="px-4 py-2 text-gray-600 hover:text-gray-900 disabled:opacity-50 text-sm font-medium"
                                        >
                                            Назад
                                        </button>
                                        <button
                                            onClick={() => setCurrentStepIndex(Math.min(requirements.length - 1, currentStepIndex + 1))}
                                            className="px-6 py-2 bg-gray-900 text-white rounded-lg hover:bg-gray-800 transition-colors text-sm font-medium flex items-center gap-2"
                                        >
                                            {currentStepIndex === requirements.length - 1 ? 'Завершить' : 'Далее'}
                                            {currentStepIndex !== requirements.length - 1 && <ChevronRight className="h-4 w-4" />}
                                        </button>
                                    </div>
                                </>
                            )}
                        </div>

                        {/* Right Side: Contextual Advice */}
                        <div className="w-full md:w-[350px] border-l bg-white p-6 md:p-8 flex flex-col overflow-y-auto">
                            {activeRequirement && (
                                <ContextualAdvice
                                    requirement={activeRequirement}
                                />
                            )}
                        </div>
                    </div>
                </Dialog.Content>
            </Dialog.Portal>
        </Dialog.Root>
    );
}

// ----------------------------------------------------------------------
// Subcomponent: Contextual Advice
// ----------------------------------------------------------------------

interface ContextualAdviceProps {
    requirement: DocumentRequirement;
}

function ContextualAdvice({ requirement }: ContextualAdviceProps) {
    const isRejected = requirement.status === 'REJECTED';
    const rejectedReason = requirement.studentDocument?.manager_comment;

    return (
        <div className="space-y-6 animate-in slide-in-from-right-4 duration-300">

            {/* Error Block - Shows only if rejected */}
            {isRejected && (
                <div className="bg-red-50 border border-red-200 rounded-lg p-4 mb-4">
                    <div className="flex items-start gap-3">
                        <AlertCircle className="h-5 w-5 text-red-600 shrink-0 mt-0.5" />
                        <div>
                            <h4 className="text-sm font-semibold text-red-900">Документ отклонен</h4>
                            <p className="text-sm text-red-700 mt-1">{rejectedReason || "Менеджер не указал причину."}</p>
                        </div>
                    </div>
                </div>
            )}

            {/* Header */}
            <div>
                <h2 className={cn("text-lg font-bold flex items-center gap-2", isRejected ? "text-red-600" : "text-gray-900")}>
                    <FileText className="h-5 w-5" />
                    {requirement.title}
                </h2>
                {isRejected && <p className="text-xs text-red-500 font-medium mt-1">Требуется исправление</p>}
            </div>

            {/* Hint/Instruction */}
            {requirement.advice_text && (
                <div className="bg-blue-50/50 rounded-lg p-4 border border-blue-100">
                    <h5 className="text-xs font-semibold text-blue-700 uppercase tracking-wider mb-2">Инструкция</h5>
                    <p className="text-sm text-gray-700 leading-relaxed">
                        {requirement.advice_text}
                    </p>
                </div>
            )}

            {/* Validation Checklist */}
            {requirement.validation_rules && requirement.validation_rules.length > 0 && (
                <div>
                    <h5 className="text-xs font-semibold text-gray-500 uppercase tracking-wider mb-3">Важно проверить</h5>
                    <ul className="space-y-3">
                        {requirement.validation_rules.map((item, i) => (
                            <li key={i} className="flex gap-3 text-sm text-gray-600">
                                <div className="h-5 w-5 rounded-full border border-gray-300 flex items-center justify-center shrink-0 mt-0.5 bg-gray-50">
                                    <span className="text-[10px] text-gray-400 font-mono">{i + 1}</span>
                                </div>
                                <span className="leading-snug">{item}</span>
                            </li>
                        ))}
                    </ul>
                </div>
            )}
        </div>
    );
}
--- END FILE: apps/web/shared/DocumentUploadModal.tsx ---

--- BEGIN FILE: apps/web/shared/Navbar.tsx ---
"use client";
import { useAuth } from "./AuthContext";
import Notifications from "./Notifications";
import CountrySwitcher from "./CountrySwitcher";
import UserMenu from "./UserMenu";

export default function Navbar() {
  const { user } = useAuth();

  return (
    <header className="mb-6 flex items-center justify-between bg-white/50 dark:bg-black/50 backdrop-blur-md sticky top-0 z-30 py-3 px-4 rounded-2xl border border-zinc-200/50 dark:border-zinc-800/50">
      {/* Левая часть: Контекст (только для студентов пока актуально) */}
      <div className="flex-1">
        {user?.role === "student" ? (
           <div className="max-w-[200px]">
               <CountrySwitcher />
           </div>
        ) : (
           <div className="text-sm font-semibold text-zinc-500 uppercase tracking-wider">
               Панель управления
           </div>
        )}
      </div>

      {/* Правая часть: Действия и Профиль */}
      <div className="flex items-center gap-4">
        <div className="h-6 w-px bg-zinc-200 dark:bg-zinc-800" />
        <Notifications />
        <div className="h-6 w-px bg-zinc-200 dark:bg-zinc-800" />
        <UserMenu />
      </div>
    </header>
  );
}
--- END FILE: apps/web/shared/Navbar.tsx ---

--- BEGIN FILE: apps/web/shared/Notifications.tsx ---
"use client";
import { useMemo, useState, useRef, useEffect } from "react";
import { useCountry } from "./CountryContext";
import { useProgress } from "./ProgressContext";

const BellIcon = () => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    className="h-6 w-6"
    fill="none"
    viewBox="0 0 24 24"
    stroke="currentColor"
    strokeWidth={2}
  >
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"
    />
  </svg>
);

export default function Notifications() {
  const [isOpen, setIsOpen] = useState(false);
  const { quests, selectedCountry } = useCountry();
  // ИСПРАВЛЕНО: Используем tasks вместо progress
  const { tasks } = useProgress();
  const ref = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (ref.current && !ref.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, [ref]);

  const notifications = useMemo(() => {
    const notifs: { id: string; type: "review" | "done" | "deadline"; message: string }[] = [];
    if (!selectedCountry) return [];

    const TODAY = new Date("2025-10-24T12:00:00Z"); // Заданная дата для расчета дедлайнов
    const DEADLINE_THRESHOLD_DAYS = 7;

    const requiredQuestIds = new Set(selectedCountry.required_quest_ids);
    const relevantQuests = quests.filter((q) => requiredQuestIds.has(q.id));

    for (const quest of relevantQuests) {
      // ИСПРАВЛЕНО: Находим задачу по названию (т.к. ID в БД отличаются от шаблонов)
      const task = tasks.find(t => t.title === quest.title);

      // Если задача еще не создана, пропускаем
      if (!task) continue;

      // ИСПРАВЛЕНО: Проверяем статусы в верхнем регистре (как они приходят с API)
      if (task.status === "REVIEW") {
        notifs.push({
          id: `s-review-${quest.id}`,
          type: "review",
          message: `Задача "${quest.title}" отправлена на проверку.`,
        });
      } else if (task.status === "DONE") {
        notifs.push({ id: `s-done-${quest.id}`, type: "done", message: `Задача "${quest.title}" одобрена! ✅` });
      }

      if (task.status !== "DONE") {
        const deadlineDate = new Date(quest.deadline);
        const diffTime = deadlineDate.getTime() - TODAY.getTime();
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

        if (diffDays >= 0 && diffDays <= DEADLINE_THRESHOLD_DAYS) {
          notifs.push({
            id: `d-${quest.id}`,
            type: "deadline",
            message: `Дедлайн для "${quest.title}" истекает ${quest.deadline}.`,
          });
        }
      }
    }
    return notifs;
  }, [selectedCountry, quests, tasks]); // ИСПРАВЛЕНО: зависимость от tasks

  const typeStyles = {
    review: "border-l-4 border-yellow-500",
    done: "border-l-4 border-green-500",
    deadline: "border-l-4 border-red-500",
  };

  return (
    <div className="relative" ref={ref}>
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="relative text-zinc-500 hover:text-zinc-800 dark:hover:text-zinc-200"
        aria-label={`Уведомления (${notifications.length})`}
      >
        <BellIcon />
        {notifications.length > 0 && (
          <span className="absolute -top-1 -right-1 flex h-4 w-4 items-center justify-center rounded-full bg-red-500 text-xs font-bold text-white">
            {notifications.length}
          </span>
        )}
      </button>
      {isOpen && (
        <div className="card absolute left-[30px] top-[-10px] mt-2 w-80 max-h-96 overflow-y-auto p-2 shadow-xl z-10">
          <div className="p-2 font-semibold text-sm">Уведомления</div>
          {notifications.length > 0 ? (
            <ul className="space-y-1">
              {notifications.map((n) => (
                <li key={n.id} className={`p-2 rounded-lg text-xs ${typeStyles[n.type]} bg-black/5 dark:bg-white/5`}>{n.message}</li>
              ))}
            </ul>
          ) : (<p className="p-4 text-center text-xs text-zinc-500">Нет новых уведомлений.</p>)}
        </div>
      )}
    </div>
  );
}
--- END FILE: apps/web/shared/Notifications.tsx ---

--- BEGIN FILE: apps/web/shared/ProgressContext.tsx ---
"use client";
import React, { createContext, useContext, useEffect, useState } from "react";
import { useAuth } from "./AuthContext";

const API_URL = process.env.NEXT_PUBLIC_API_URL ?? "http://localhost:4000/api";

export type TaskStatus = "TODO" | "REVIEW" | "CHANGES_REQUESTED" | "DONE";

export type Task = {
  id: number;
  stage: string;
  title: string;
  description: string;
  xpReward: number;
  status: TaskStatus;
  submission?: any;
  student?: { fullName: string }; // for curator view
};

type ProgressContextType = {
  tasks: Task[];
  reviewQueue: Task[];
  fetchTasks: () => Promise<void>;
  fetchReviewQueue: () => Promise<void>;
  submitQuest: (questId: number, submission: any) => Promise<void>;
  approveQuest: (questId: number) => Promise<void>;
  requestChanges: (questId: number, comment: string) => Promise<void>;
};

const ProgressCtx = createContext<ProgressContextType | null>(null);

export const ProgressProvider: React.FC<React.PropsWithChildren> = ({ children }) => {
  const { user } = useAuth();
  const [tasks, setTasks] = useState<Task[]>([]);
  const [reviewQueue, setReviewQueue] = useState<Task[]>([]);

  useEffect(() => {
    if (user?.role === 'student') {
        fetchTasks();
    }
  }, [user]);

  const fetchTasks = async () => {
      const token = localStorage.getItem("accessToken");
      if (!token) return;
      try {
          const res = await fetch(`${API_URL}/student/tasks`, {
              headers: { Authorization: `Bearer ${token}` }
          });
          if (res.ok) setTasks(await res.json());
      } catch (e) { console.error(e); }
  };

  const fetchReviewQueue = async () => {
      const token = localStorage.getItem("accessToken");
      if (!token) return;
      try {
          const res = await fetch(`${API_URL}/curator/review`, {
              headers: { Authorization: `Bearer ${token}` }
          });
          if (res.ok) setReviewQueue(await res.json());
      } catch (e) { console.error(e); }
  };

  const submitQuest = async (questId: number, submission: any) => {
    const token = localStorage.getItem("accessToken");
    await fetch(`${API_URL}/student/tasks/${questId}/submit`, {
        method: "POST",
        headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` },
        body: JSON.stringify({ submission })
    });
    await fetchTasks();
  };

  const approveQuest = async (questId: number) => {
    const token = localStorage.getItem("accessToken");
    await fetch(`${API_URL}/curator/tasks/${questId}/approve`, {
        method: "POST",
        headers: { Authorization: `Bearer ${token}` }
    });
    await fetchReviewQueue();
  };

  const requestChanges = async (questId: number, comment: string) => {
    const token = localStorage.getItem("accessToken");
    await fetch(`${API_URL}/curator/tasks/${questId}/request-changes`, {
        method: "POST",
        headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` },
        body: JSON.stringify({ comment })
    });
    await fetchReviewQueue();
  };

  const value: ProgressContextType = {
    tasks,
    reviewQueue,
    fetchTasks,
    fetchReviewQueue,
    submitQuest,
    approveQuest,
    requestChanges,
  };

  return <ProgressCtx.Provider value={value}>{children}</ProgressCtx.Provider>;
};

export const useProgress = () => {
  const ctx = useContext(ProgressCtx);
  if (!ctx) throw new Error("useProgress must be used within ProgressProvider");
  return ctx;
};
--- END FILE: apps/web/shared/ProgressContext.tsx ---

--- BEGIN FILE: apps/web/shared/Sidebar.tsx ---
"use client";
import { useState } from "react";
import Link from "next/link";
import { usePathname } from "next/navigation";
import { useAuth } from "./AuthContext";


const NavItem = ({ href, label }: { href: string; label: string }) => {
  const path = usePathname();
  const active = path === href;
  return (
    <Link
      href={href}
      className={`block px-4 py-2 rounded-xl transition ${
        active ? "bg-black text-white dark:bg-white dark:text-black" : "hover:bg-black/5 dark:hover:bg-white/10"
      }`}
    >
      {label}
    </Link>
  );
};

export default function Sidebar() {
  const { user } = useAuth();
  const [mobileOpen, setMobileOpen] = useState(false);


  return (
    <>
    {/* Mobile Toggle */}
    <button 
      className="sm:hidden fixed bottom-4 right-4 z-50 bg-black text-white p-3 rounded-full shadow-lg"
      onClick={() => setMobileOpen(!mobileOpen)}
    >
      {mobileOpen ? "✕" : "☰"}
    </button>

    <aside className={`
      fixed inset-y-0 left-0 z-40 w-64 bg-zinc-50 dark:bg-black p-4 transform transition-transform duration-200 ease-in-out sm:relative sm:translate-x-0 sm:w-64 flex flex-col h-screen sm:h-auto
       ${mobileOpen ? "translate-x-0 shadow-2xl" : "-translate-x-full"}
     `}>
      {/* Логотип / Название */}
      <div className="px-4 py-3 mb-4 flex items-center gap-3">
          <div className="w-8 h-8 bg-black dark:bg-white rounded-lg flex items-center justify-center text-white dark:text-black font-bold">A</div>
          <span className="font-bold text-lg tracking-tight">Abbit</span>
      </div>

      <div className="card p-2 space-y-1 flex-1">
        <nav className="space-y-1">

          {user?.role === "student" && (
            <>
              <NavItem href="/student/dashboard" label="Главная" />
              {/* --- НОВОЕ: Ссылка на Календарь для студента --- */}
              <NavItem href="/student/calendar" label="Календарь" />
              <NavItem href="/student/quests" label="Мои Квесты" />
              <NavItem href="/student/kanban" label="Kanban Доска" />
              {/* --- НОВОЕ: Добавлена ссылка на раздел "Мои Программы" --- */}
              <NavItem href="/student/programs" label="Мои Программы" />
              <NavItem href="/student/folder" label="Моя Папка" />
            </>
          )}
          {(user?.role === "curator" || user?.role === "admin") && (
            <>
              {/* --- ИЗМЕНЕНИЕ: Ссылка "Студенты" переименована в "Панель Студентов" --- */}
              <NavItem href="/curator/admin/moderators" label="Кураторы" />
              <NavItem href="/curator/students" label="Студенты" />
              <NavItem href="/curator/admin/countries" label="Страны и программы" />
              <NavItem href="/curator/programs-search" label="Поиск программ" />
            </>
          )}
        </nav>
      </div>

    </aside>
    
    {/* Overlay for mobile */}
    {mobileOpen && (
      <div className="fixed inset-0 z-30 bg-black/50 sm:hidden" onClick={() => setMobileOpen(false)} />
    )}
    </>
  );
}
--- END FILE: apps/web/shared/Sidebar.tsx ---

--- BEGIN FILE: apps/web/shared/UserMenu.tsx ---
"use client";
import { useState, useRef, useEffect } from "react";
import { useAuth } from "./AuthContext";
import Avatar from "./Avatar";
import Link from "next/link";

export default function UserMenu() {
  const { user, logout } = useAuth();
  const [isOpen, setIsOpen] = useState(false);
  const menuRef = useRef<HTMLDivElement>(null);

  // Закрытие при клике вне
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  if (!user) return null;

  return (
    <div className="relative" ref={menuRef}>
      <button 
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center gap-3 hover:bg-black/5 dark:hover:bg-white/10 p-1.5 pr-3 rounded-full transition"
      >
        <Avatar name={user.name} level={1} className="w-8 h-8 text-xs" />
        <div className="text-left hidden sm:block">
          <div className="text-sm font-semibold leading-none">{user.name}</div>
          <div className="text-[10px] text-zinc-500 uppercase tracking-wide">{user.role}</div>
        </div>
        <svg className={`w-4 h-4 text-zinc-400 transition-transform ${isOpen ? 'rotate-180' : ''}`} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" /></svg>
      </button>

      {isOpen && (
        <div className="absolute right-0 top-full mt-2 w-56 bg-white dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-800 rounded-xl shadow-xl py-2 z-50 animate-in fade-in zoom-in-95 duration-100">
            <div className="px-4 py-2 border-b border-zinc-100 dark:border-zinc-800 sm:hidden">
                <div className="font-semibold">{user.name}</div>
                <div className="text-xs text-zinc-500">{user.email}</div>
            </div>
            
            <div className="py-1">
                <Link 
                    href={user.role === 'student' ? `/student/${user.id}` : `/curator/admin/moderators`}
                    className="block px-4 py-2 text-sm text-zinc-700 dark:text-zinc-300 hover:bg-zinc-50 dark:hover:bg-zinc-800"
                    onClick={() => setIsOpen(false)}
                >
                    ⚙️ Настройки профиля
                </Link>
                {user.role === 'student' && (
                     <Link 
                        href="/student/folder"
                        className="block px-4 py-2 text-sm text-zinc-700 dark:text-zinc-300 hover:bg-zinc-50 dark:hover:bg-zinc-800"
                        onClick={() => setIsOpen(false)}
                    >
                        📂 Мои документы
                    </Link>
                )}
            </div>

            <div className="border-t border-zinc-100 dark:border-zinc-800 my-1" />
            
            <button 
                onClick={logout}
                className="w-full text-left px-4 py-2 text-sm text-red-600 hover:bg-red-50 dark:hover:bg-red-900/10 transition"
            >
                Выйти
            </button>
        </div>
      )}
    </div>
  );
}
--- END FILE: apps/web/shared/UserMenu.tsx ---

--- BEGIN FILE: apps/web/shared/documentData.ts ---
export const DOCUMENT_GUIDELINES = {
    apostille: {
        title: "Апостиль",
        advice: [
            { label: "Где получить", text: "ЦОН (Центр Обслуживания Населения) или Министерство образования." },
            { label: "Срок", text: "До 15 рабочих дней. Планируйте заранее!" },
            { label: "Важно", text: "Апостиль ставится на оригинал или нотариально заверенную копию (зависит от страны назначения)." }
        ],
        validation: [
            "Наличие штампа 'Apostille' (обычно на оборотной стороне или на отдельном листе, подшитом к документу).",
            "Читаемость печати и подписи должностного лица.",
            "Целостность скрепления документа (ленточка/нитка не должна быть надорвана)."
        ],
        hint: {
            instruction: "Оригинал диплома должен иметь штамп Апостиль (выдается Министерством образования). Срок: до 15 рабочих дней.",
            error: "Загружен скан без штампа на оборотной стороне."
        }
    },
    passport: {
        title: "Скан Паспорта",
        advice: [
            { label: "Что нужно", text: "Качественный цветной скан главного разворота (с фото)." },
            { label: "Требования", text: "Срок действия паспорта должен быть актуальным (минимум 6-18 месяцев запас после начала учебы)." }
        ],
        validation: [
            "Читаемость всех зон (MRZ, ФИО, номер).",
            "Отсутствие бликов на лице и тексте.",
            "Видимость всех 4-х углов разворота.",
            "Срок действия паспорта."
        ],
        hint: {
            instruction: "Загрузите цветной скан или фото главного разворота загранпаспорта. Убедитесь, что нет бликов и видны все углы.",
            error: "Скан обрезан или текст не читаем из-за бликов."
        }
    },
    school_certificate: {
        title: "Справка с места учебы",
        advice: [
            { label: "Где получить", text: "У секретаря в школе или в деканате/офисе регистратора (для студентов)." },
            { label: "Язык", text: "Если справка не на английском, может потребоваться перевод." }
        ],
        validation: [
            "Наличие даты выдачи (должна быть свежей, обычно < 3 месяцев).",
            "Наличие 'живой' печати учебного заведения.",
            "Наличие подписи ответственного лица."
        ],
        hint: {
            instruction: "Загрузите скан справки с работы/учебы с печатью и датой выдачи.",
            error: "Справка устарела или отсутствует печать."
        }
    },
    translation: {
        title: "Нотариальный перевод",
        advice: [
            { label: "Где получить", text: "Бюро переводов с нотариальным заверением." },
            { label: "Важно", text: "Перевод должен быть сшит с копией исходного документа." }
        ],
        validation: [
            "Наличие подписи переводчика.",
            "Наличие печати и подписи нотариуса.",
            "Соответствие данных в переводе оригиналу (ФИО, даты)."
        ],
        hint: {
            instruction: "Загрузите скан перевода, сшитого с копией документа, заверенный нотариусом.",
            error: "Нет заверения нотариуса или неполный документ."
        }
    }
} as const;

export type DocumentType = keyof typeof DOCUMENT_GUIDELINES;
--- END FILE: apps/web/shared/documentData.ts ---

--- BEGIN FILE: apps/web/tests/e2e/auth.spec.ts ---
import { test, expect } from '@playwright/test';

test.describe('Authentication Flow', () => {
  
  // Генерация случайного email для теста
  const randomEmail = `test_${Date.now()}@example.com`;

  test('should register a new student and redirect to dashboard', async ({ page }) => {
    await page.goto('/login');

    // Заполняем форму
    await page.fill('input[type="email"]', randomEmail);
    await page.fill('input[type="password"]', 'secret123');
    
    // Выбираем роль (по дефолту студент, но убедимся)
    await page.selectOption('select', 'student');

    // Нажимаем регистрацию
    await page.click('button:has-text("Регистрация")');

    // Ждем редиректа на дашборд
    await page.waitForURL('/student/dashboard');

    // Проверяем наличие приветствия или элементов дашборда
    await expect(page.getByText('Адаптивный Штаб')).toBeVisible();
    await expect(page.getByText('Студент')).toBeVisible(); // Имя из мока AuthContext при логине
  });

  test('should fail login with wrong password', async ({ page }) => {
    await page.goto('/login');

    await page.fill('input[type="email"]', randomEmail);
    await page.fill('input[type="password"]', 'wrong_pass');
    
    // Нажимаем вход
    await page.click('button:has-text("Войти")');

    // Ждем появления ошибки
    // (в текущей реализации AuthContext она просто логируется или выводится, добавим проверку UI если есть)
    // Для демо предполагаем, что страница не изменилась
    expect(page.url()).toContain('/login');
  });

  test('should fetch countries list on dashboard', async ({ page }) => {
    // Предполагаем, что мы уже залогинены (можно использовать глобальный setup)
    // Для простоты - быстрый логин через мок или повтор
    // В реальном BMad мы бы использовали фикстуру `authenticatedUser`
    
    // Этот тест требует, чтобы бэкенд был запущен и отдавал страны
  });
});
--- END FILE: apps/web/tests/e2e/auth.spec.ts ---

--- BEGIN FILE: apps/web/tsconfig.json ---
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts",
    "mock/**/*.json",
    ".next/dev/dev/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}
--- END FILE: apps/web/tsconfig.json ---

--- BEGIN FILE: docker-compose.override.yml ---
services:
  api:
    command: npm run start:dev
    volumes:
      - ./apps/api/src:/app/apps/api/src
      - ./apps/api/tsconfig.json:/app/apps/api/tsconfig.json

  web:
    command: npm run dev
    environment:
      - WATCHPACK_POLLING=true
    volumes:
      - ./apps/web:/app
      - /app/node_modules
      - /app/.next
--- END FILE: docker-compose.override.yml ---

--- BEGIN FILE: docker-compose.yml ---
services:
  abbit-db:
    image: postgres:15-alpine
    container_name: abbit-db
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: abbit
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  camunda:
    image: camunda/camunda-bpm-platform:run-latest
    container_name: camunda
    environment:
      - TZ=Europe/Vienna
    ports:
      - "8080:8080"

  minio:
    image: minio/minio
    container_name: abbit-minio
    command: server /data --console-address ":9001"
    ports:
      - "9000:9000"
      - "9001:9001"
    environment:
      MINIO_ROOT_USER: minioadmin
      MINIO_ROOT_PASSWORD: minioadmin
    volumes:
      - minio_data:/data

  api:
    build:
      context: .
      dockerfile: ./docker/api.Dockerfile
    container_name: applicant-api
    environment:
      - NODE_ENV=production
      - CAMUNDA_URL=http://camunda:8080/engine-rest
      - CAMUNDA_REG_PROCESS_KEY=student_registration
      - DATABASE_URL=postgresql://postgres:postgres@abbit-db:5432/abbit?schema=public
      - MINIO_ENDPOINT=minio
      - MINIO_PORT=9000
      - MINIO_ACCESS_KEY=minioadmin
      - MINIO_SECRET_KEY=minioadmin
      - MINIO_BUCKET=abbit-files
    depends_on:
      - camunda
      - abbit-db
      - minio
    ports:
      - "4000:4000"

  web:
    build:
      context: .
      dockerfile: ./docker/web.Dockerfile
    container_name: applicant-web
    environment:
      - NODE_ENV=production
      - NEXT_PUBLIC_API_URL=http://localhost:4000/api
    depends_on:
      - api
    ports:
      - "3000:3000"

volumes:
  postgres_data:
  minio_data:
--- END FILE: docker-compose.yml ---

--- BEGIN FILE: docs/architecture/database-schema.md ---
# Database Schema Design: Document Upload Module

**Status:** Draft
**Date:** 2026-01-01
**Author:** Winston (Systems Architect)

## Overview
This schema update introduces a structured document management system, decoupled from generic "Tasks". It supports the rigorous validation requirements defined in the PRD.

## ER Diagram (Conceptual)

```mermaid
erDiagram
    University ||--o{ RequiredDocumentList : defines
    RequiredDocumentList }o--|| DocumentDefinition : requires
    DocumentDefinition ||--|| RequirementAdvice : "has instructions"
    Student ||--o{ Document : uploads
    Document }o--|| DocumentDefinition : "is instance of"
```

## SQL Schema Definition (PostgreSQL)

### 1. Document Dictionaries

```sql
-- Master list of all possible document types (Passport, Diploma, etc.)
CREATE TABLE document_definitions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    code VARCHAR(50) UNIQUE NOT NULL, -- e.g., 'PASSPORT', 'DIPLOMA_APOSTILLE'
    name VARCHAR(255) NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT NOW()
);

-- User guidance text linked to definitions (1:1)
CREATE TABLE requirement_advice (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_definition_id UUID UNIQUE REFERENCES document_definitions(id) ON DELETE CASCADE,
    advice_text TEXT NOT NULL,       -- "Where to get it..."
    validation_checklist JSONB,      -- ["Check stamp", "Check corners"]
    ui_hint TEXT,                    -- Tooltip for upload modal
    typical_error_text TEXT,         -- "Rejection usually caused by..."
    updated_at TIMESTAMP DEFAULT NOW()
);
```

### 2. Requirements Mapping

```sql
-- Junction table defining what a University requires
CREATE TABLE required_document_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    university_id UUID REFERENCES universities(id) ON DELETE CASCADE,
    document_definition_id UUID REFERENCES document_definitions(id) ON DELETE CASCADE,
    is_mandatory BOOLEAN DEFAULT TRUE,
    UNIQUE(university_id, document_definition_id)
);
```

### 3. Student Documents

```sql
-- Actual files uploaded by students
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    student_id UUID REFERENCES students(id) ON DELETE CASCADE, -- Assuming 'students' table exists
    document_definition_id UUID REFERENCES document_definitions(id),
    
    file_url VARCHAR(512),
    status VARCHAR(20) DEFAULT 'PENDING' CHECK (status IN ('PENDING', 'ON_CHECK', 'NEEDS_FIX', 'ACCEPTED')),
    
    -- New fields requested
    rejection_reason TEXT,           -- Comment from curator if rejected
    metadata JSONB,                  -- Stores parsed info (e.g., Apostille number, Issue Date)
    
    uploaded_at TIMESTAMP,
    reviewed_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);
```

## TypeORM Entities Draft

### DocumentDefinition Entity
```typescript
@Entity('document_definitions')
export class DocumentDefinition {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ unique: true })
  code: string; // e.g. 'PASSPORT'

  @Column()
  name: string;

  @OneToOne(() => RequirementAdvice, advice => advice.definition)
  advice: RequirementAdvice;
}
```

### RequirementAdvice Entity
```typescript
@Entity('requirement_advice')
export class RequirementAdvice {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column('text')
  adviceText: string;

  @Column('jsonb')
  validationChecklist: string[];

  @Column('text')
  uiHint: string;

  @Column('text', { nullable: true })
  typicalErrorText: string;

  @OneToOne(() => DocumentDefinition, def => def.advice)
  @JoinColumn()
  definition: DocumentDefinition;
}
```

### Document Entity
```typescript
@Entity('documents')
export class Document {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @ManyToOne(() => Student)
  student: Student;

  @ManyToOne(() => DocumentDefinition)
  definition: DocumentDefinition;

  @Column({ nullable: true })
  fileUrl: string;

  @Column({
    type: 'enum',
    enum: ['PENDING', 'ON_CHECK', 'NEEDS_FIX', 'ACCEPTED'],
    default: 'PENDING'
  })
  status: string;

  @Column('text', { nullable: true })
  rejectionReason: string;

  @Column('jsonb', { nullable: true })
  metadata: Record<string, any>;
}
```

## Migration Plan

1.  Create `document_definitions` and populate with the 8 types from PRD.
2.  Create `requirement_advice` and populate content from `prd-document-upload.md`.
3.  Migrate existing file URLs from `tasks.submission` to `documents` table (if data exists).
4.  Update API to read/write to `documents` table for the file management module.
--- END FILE: docs/architecture/database-schema.md ---

--- BEGIN FILE: docs/epics-stories.md ---
# Abbit - Epics & User Stories

**Based on:** docs/prd.md
**Status:** Ready for Development

---

## Epic 1: SaaS Foundation & Identity
**Goal:** Establish a secure, multi-tenant environment where agencies manage their own users and data in isolation.

| ID | User Story | Acceptance Criteria |
|----|------------|---------------------|
| **US1.1** | As a **User**, I want to log in using my email and password so I can access the system. | - JWT issued upon success<br>- Error message for invalid creds<br>- Redirect to approp. dashboard |
| **US1.2** | As a **Tenant Admin**, I want to ensure my data is invisible to other companies. | - API enforces `companyId` filter on ALL queries<br>- Users cannot access resources of other tenants |
| **US1.3** | As a **System**, I want to handle roles (Student, Curator, Admin) so users see only what they need. | - Guards/Decorators in NestJS for Roles<br>- UI hides unauthorized menu items |

---

## Epic 2: The Student Quest (Gamified Journey)
**Goal:** Transform the student's admission process into an engaging, roadmap-driven experience.

| ID | User Story | Acceptance Criteria |
|----|------------|---------------------|
| **US2.1** | As a **Student**, I want to see a Task Matrix (Roadmap) so I know exactly what steps are required. | - List of tasks ordered by phase<br>- "Locked" vs "Unlocked" states tailored by Camunda |
| **US2.2** | As a **Student**, I want to use a Kanban Board to track my progress. | - Columns: Todo, Review, Done<br>- Drag and drop disabled (state managed by system flows) |
| **US2.3** | As a **Student**, I want to upload documents (PDF/Img) for a task so I can submit my work. | - File picker with type validation<br>- Upload progress bar<br>- Preview of uploaded file |
| **US2.4** | As a **Student**, I want to "Submit" a task for review so I can move to the next step. | - Button active only if file uploaded<br>- Task status changes to "Review" |
| **US2.5** | As a **Student**, I want to earn XP and see my Avatar level up so I feel rewarded. | - XP animation on "Task Approved"<br>- Progress bar to next level<br>- Avatar visual changes |
| **US2.6** | As a **Student**, I want to download all my approved docs as a ZIP so I have a backup. | - Single click download<br>- Contains only "Done" files |

---

## Epic 3: Curator Command Center
**Goal:** Enable curators to efficiently manage multiple students and review submissions quickly.

| ID | User Story | Acceptance Criteria |
|----|------------|---------------------|
| **US3.1** | As a **Curator**, I want to see a list of my assigned students with "Risk" indicators. | - Filterable table<br>- Progress % shown<br>- Red flag if deadline near/missed |
| **US3.2** | As a **Curator**, I want a global "Review Inbox" so I can see all pending work in one place. | - List of all tasks in "Review" status across my students |
| **US3.3** | As a **Curator**, I want to Approve a submission. | - Moves task to "Done"<br>- Triggers XP award<br>- Notifies student |
| **US3.4** | As a **Curator**, I want to Reject a submission with a comment. | - Mandatory text field for reason<br>- Moves task to "Todo"<br>- Student sees comment highlighted |

---

## Epic 4: Administration & Content
**Goal:** Allow admins to configure the admission logic and master data.

| ID | User Story | Acceptance Criteria |
|----|------------|---------------------|
| **US4.1** | As an **Admin**, I want to manage Universities and Countries. | - CRUD operations for reference data |
| **US4.2** | As an **Admin**, I want to create Task Templates linked to BPMN IDs. | - Editor to define Title, Desc, XP value, and Camunda Activity ID |
| **US4.3** | As an **Admin**, I want to onboard new Curators. | - Invite/Create account flow |

---

## Epic 5: System Integrations
**Goal:** Connect the web platform to external engines (process, storage, messaging).

| ID | User Story | Acceptance Criteria |
|----|------------|---------------------|
| **US5.1** | As a **System**, I want to sync task status with Camunda. | - Complete user task in Camunda when Curator approves<br>- Create new DB task when Camunda process reaches user task |
| **US5.2** | As a **Student**, I want to link my Telegram account. | - "Get Binding Code" button in Profile<br>- Send code to Bot to link `chat_id` |
| **US5.3** | As a **Parent**, I want to receive Telegram notifications about my child's progress. | - Notifications on: Submission, Approval, Rejection, Deadline |
| **US5.4** | As a **System**, I want to store files securely in MinIO. | - Uploads go to bucket `{companyId}/{studentId}/...`<br>- Access only via signed URLs |
--- END FILE: docs/epics-stories.md ---

--- BEGIN FILE: docs/external_database_setup.md ---
# External Database Configuration Guide

This guide explains how to connect the Abbit API to an external PostgreSQL database (e.g., AWS RDS, DigitalOcean Managed Database, Supabase, Neon).

## 1. Prerequisites
- A running PostgreSQL database (Version 15+ recommended).
- Connection details: Host, Port, Database Name, Username, Password.
- Allow-list IP configured (if your provider requires it) to allow access from your deployment server.

## 2. Configuration Steps

The application uses the `DATABASE_URL` environment variable to connect to the database.

1.  Open or create the `.env` file in `apps/api/`.
2.  Locate or add the `DATABASE_URL` variable.
3.  Set the value using the following connection string format:

```bash
DATABASE_URL="postgresql://[USER]:[PASSWORD]@[HOST]:[PORT]/[DATABASE]"
```

### Examples

**Standard Connection:**
```bash
DATABASE_URL="postgresql://admin:supersecret@db.example.com:5432/abbit_prod"
```

**With SSL (Required by many cloud providers):**
Append `?sslmode=require` (or `no-verify` if using self-signed certs) to the end of the URL.
```bash
DATABASE_URL="postgresql://admin:supersecret@db.example.com:5432/abbit_prod?sslmode=require"
```

**Supabase (Transaction Pooler):**
Supabase often provides a transaction pooler on port 6543.
```bash
DATABASE_URL="postgresql://postgres.projectid:password@aws-0-eu-central-1.pooler.supabase.com:6543/postgres?pgbouncer=true"
```

## 3. Migrating Data (Optional)

If you have existing data in your local Docker database and want to move it to the external cloud database, follow these steps.

### Step 3.1: Export Local Data
Run this command to create a backup file (`dump.sql`) from your running local container:

```bash
docker exec -t abbit-db pg_dump -U postgres -d abbit --clean --if-exists > dump.sql
```
*Note: `abbit-db` is the container name defined in docker-compose.yml.*

### Step 3.2: Import to External Database
Use `psql` to restore the backup to your new external database.

```bash
# General Syntax
psql "[Your External DATABASE_URL]" < dump.sql

# Example
psql "postgresql://admin:password@remote-db.com:5432/abbit_prod?sslmode=require" < dump.sql
```

## 4. Verification

1.  Update the `.env` file with your new `DATABASE_URL`.
2.  Restart the application:
    ```bash
    # If running with docker-compose
    docker-compose down
    docker-compose up -d api

    # If running locally with npm
    cd apps/api
    npm run start:dev
    ```
3.  Check the logs. You should see a successful TypeORM connection message and no errors regarding connection timeouts.

## 5. Troubleshooting

-   **Connection Refused**: Check your database firewall / security groups. Ensure your current IP is whitelisted.
-   **SSL Error**: Try adding `?sslmode=require` or `?sslmode=no-verify` to the connection string.
-   **Schema Sync**: The application is currently configured with `synchronize: true`. This will automatically create tables in your new empty database on the first run. **WARNING**: In production, it is recommended to disable this and use migrations.
--- END FILE: docs/external_database_setup.md ---

--- BEGIN FILE: docs/prd.md ---
# Abbit - Product Requirements Document

**Author:** BMad PM
**Date:** 2026-01-01
**Version:** 1.0
**Source Document:** docs/project-brief.md

---

## Executive Summary

Abbit is a comprehensive SaaS platform designed to gamify and streamline the university admission process for study abroad agencies. It replaces chaotic communication channels with a structured, centralized "Quest" system.

### What Makes This Special

**Gamified Bureaucracy ("RPG Life"):** The core differentiator is transforming the tedious admission process into an engaging RPG experience where students help their "Avatar" progress by completing real-world tasks (uploading docs, filling forms). This is powered by a robust **Camunda BPMN** engine and protected by strict **Multi-Tenant SaaS** isolation.

---

## Project Classification

**Technical Type:** SaaS B2B (Web Platform)
**Domain:** EdTech (Admissions)
**Complexity:** Medium/High

### Domain Context

As an EdTech platform handling student data, **Privacy** and **Clarity** are paramount. The system serves three distinct personas (Student, Curator, Parent) who need different views of the same data. The "Agency" model requires strict data isolation (Multi-tenancy).

---

## Success Criteria

### Measures of Success
1.  **Functional Adoption:** Agencies successfully onboard students who complete the full admission cycle via the platform.
2.  **Engagement:** Students actively interact with the Avatar/XP system, reducing "dropout" or procrastination.
3.  **Operational Efficiency:** Curators spend less time answering "what's next?" and more time on high-value guidance.

### Business Metrics (KPIs)
-   **Task Completion Rate:** % of tasks completed on schedule.
-   **Review Turnaround:** Average time from Submission -> Review Decision.
-   **Daily Active Users (DAU):** Student engagement monitoring.

---

## Product Scope

### MVP - Minimum Viable Product
1.  **Multi-Tenant Auth:** Secure login for Students, Curators, Admins with Company isolation.
2.  **Student Quest Dashboard:** Kanban board, Task Matrix, File Uploads, XP/Avatar display.
3.  **Curator Command Center:** Student list, Review Inbox, Approval/Rejection flow.
4.  **Admin Tools:** Management of University/Country data and Task Templates.
5.  **Notifications:** Telegram Bot integration for status updates.
6.  **Core Integrations:** MinIO (Storage), Camunda (Process Engine).

### Growth Features (Post-MVP)
-   Self-service registration for new Agencies/Parents.
-   Billing and Subscription management.
-   In-app real-time chat (replacing task comments).
-   Mobile Native App.

### Vision (Future)
-   AI-driven university recommendations.
-   Global marketplace for universities.

---

## Domain-Specific Requirements (EdTech/SaaS)

1.  **Data Isolation (Privacy):** Student data must never leak between Agencies (Tenants).
2.  **Auditability:** Every document submission and review decision must be logged (Process history).
3.  **Clarity:** Instructions must be unambiguous to reduce anxiety for teenage applicants.

---

## Functional Requirements

### User Management & Security
-   **FR1:** Users (Student, Curator, Admin) can log in via email and password using secure authentication.
-   **FR2:** System must enforce **Tenancy Isolation**, ensuring users only access data within their `companyId`.
-   **FR3:** System must enforce **Role-Based Access Control (RBAC)** for Student, Curator, and Admin flows.
-   **FR4:** Students can link their Telegram account via a "Binding Code" to receive notifications.

### Student Experience ("The Quest")
-   **FR5:** Students can view a **Task Matrix** (Roadmap) tailored to their Country/Program selection.
-   **FR6:** Students can view tasks on a **Kanban Board** categorized by status (Todo, Review, Done).
-   **FR7:** Students can view detailed instructions for a specific Task.
-   **FR8:** Students can **upload documents/files** to a customized "Submission" area for a task.
-   **FR9:** Students can **submit** a task for review once requirements are met.
-   **FR10:** Students receive **XP (Experience Points)** automatically upon task completion (Review Approval).
-   **FR11:** Students can view their **Avatar** and its current level/customization based on XP.
-   **FR12:** Students can download a "My Folder" archive of all approved documents.

### Curator Experience ("The Guide")
-   **FR13:** Curators can view a searchable/filterable list of **Students assigned to them**.
-   **FR14:** Curators can view a **Review Inbox** showing all pending task submissions.
-   **FR15:** Curators can **Approve** a submission, which unlocks the next process step for the student.
-   **FR16:** Curators can **Reject** a submission with a mandatory **Comment/Reason**, returning the task to "Todo".
-   **FR17:** Curators can view a student's progress bar and "Risk" indicators (e.g., missed deadlines).

### Admin & Content
-   **FR18:** Admins can manage global data: **Universities**, **Countries**, and **Programs**.
-   **FR19:** Admins can create and edit **Task Templates** (linking to BPMN steps).
-   **FR20:** Admins can manage Curator accounts and assign them to students.

### System Behaviors
-   **FR21:** System triggers **Telegram Notifications** to Student (and linked Parent) upon Review outcomes.
-   **FR22:** System integrates with **Camunda** to orchestrate task availability (e.g., Task B only opens after Task A is Done).
-   **FR23:** System stores all file uploads securely in **MinIO** with presigned URL access.
-   **FR24:** System validates file types and sizes during upload.

---

## Non-Functional Requirements

### User Experience (Aesthetics)
-   **NFR1:** The interface must feature a **Premium, "Wow" Design** with vibrant colors, glassmorphism, and dark mode support.
-   **NFR2:** Transitions and interactions (especially Avatar updates and Kanban moves) must be smooth and animated.

### Performance & Scalability
-   **NFR3:** Dashboard load time should be under **1.5 seconds** (p95).
-   **NFR4:** System must support horizontal scaling for the API and Consumers to handle peak admission seasons.

### Security
-   **NFR5:** All API requests must be validated with JWTs containing `userId` and `companyId`.
-   **NFR6:** File access must be strictly controlled via short-lived presigned URLs.

---

## Innovation & Novel Patterns
**Bureaucracy as a Game:** By treating document collection as a "Quest" with tangible rewards (XP, Avatar items), we flip the emotional context from "Stress" to "Achievement".
--- END FILE: docs/prd.md ---

--- BEGIN FILE: docs/project-brief.md ---
# Project Brief: Abbit (Student Admission System)

**Date:** 2026-01-01
**Author:** BMad Analyst
**Context:** MVP Development / SaaS Platform

---

## Executive Summary

**Abbit** is a comprehensive web platform designed to streamline and gamify the university admission process for students applying abroad. It replaces scattered communication channels (chats, spreadsheets) with a centralized system that offers clear roadmaps (Tasks/Quests), document management, and progress tracking.

The system is built as a multi-company SaaS platform, servicing education agencies. It empowers **Students** with a clear path and gamified motivation (XP, Avatars), provides **Curators** with efficient management tools, and offers **Parents** visibility via Telegram integration.

---

## Core Vision

### Problem Statement
Currently, the admission process is chaotic, characterized by:
*   **Disorganized Communication:** Information is scattered across various messengers, emails, and files.
*   **Lack of Transparency:** Students lack a clear understanding of their roadmap, progress, and upcoming deadlines.
*   **Management Overhead:** Curators struggle to track multiple students effectively without a unified dashboard.
*   **Low Engagement:** The routine process of document collection is tedious and demotivating for applicants.

### Proposed Solution
A **Gamified Task-Based Web Platform** that serves as a single source of truth:
*   **For Students:** An interacting "Quest" system where admission steps are tasks. Completing tasks earns XP and unlocks avatar customization.
*   **For Curators:** A dashboard to monitor student progress, review submissions (docs, links), and manage deadlines.
*   **Process Automation:** Integration with **Camunda BPMN** to orchestrate workflows (e.g., Registration, Onboarding).
*   **SaaS Architecture:** Built solely for scalability with multi-tenant support (Company isolation) from Day 1.

### Key Differentiators
1.  **Gamification:** Transforming bureaucracy into an RPG-like experience (XP for tasks, fully customizable Avatars).
2.  **Process-Driven:** Powered by a BPMN engine (Camunda) for flexible process logic managed via API.
3.  **Strict Isolation:** Multi-company architecture allowing multiple agencies to use the platform securely.
4.  **Telegram Integration:** "Binding code" system to link Telegram groups for notifications (Deadlines, Reviews) for Students and Parents.

---

## Target Users

### Primary Users
1.  **Student (The Player):**
    *   **Needs:** Clear instructions, visual progress, motivation, centralized document storage.
    *   **Workflow:** Log in -> Check Dashboard -> specific "Tasks" (Upload doc/Fill form) -> Wait for Review -> Earn XP.
2.  **Curator (The Guide):**
    *   **Needs:** Overview of all assigned students, quick review interface, deadline alerts.
    *   **Workflow:** Dashboard -> Review Inbox (Approve/Reject submissions) -> Communication via comments.

### Secondary Users
*   **Company Admin:** Manages curators, university databases, and task templates.
*   **Parent (Observer):** No direct login in MVP, but receives status updates and alerts via a linked Telegram group.

---

## Success Metrics

### MVP Success Criteria
*   **Functional Core:** Successful registration, task generation, submission, and review cycle.
*   **Engagement:** Students customizing avatars and actively tracking XP.
*   **Efficiency:** Reduction in "What do I do next?" questions to curators.
*   **Stability:** Robust handling of file uploads (MinIO) and BPMN process states.

### Key Performance Indicators (KPIs)
*   **Task Completion Rate:** % of tasks completed on time.
*   **Review Turnaround:** Time taken for a curator to review a submission.
*   **User Retention:** Daily Active Users (DAU) among active applicants.

---

## MVP Scope

### Core Features
1.  **Auth & Profiles:**
    *   Role-based access (Student, Curator, Admin).
    *   Multi-company isolation features.
2.  **Student Dashboard:**
    *   **Task Matrix:** Auto-generated tasks based on Country/Program selection.
    *   **Kanban Board:** Visual status of tasks (Todo, Review, Done).
    *   **My Folder:** Collected documents ready for download.
    *   **Gamification:** XP logic (1000 XP scale) and Avatar rendering.
3.  **Curator Dashboard:**
    *   Student list with progress bars and risk indicators.
    *   Global Review Inbox for quick task approval/rejection.
4.  **Admin Panel:**
    *   Management of Countries, Universities, and Programs.
    *   Task Template editor.
5.  **Notifications:**
    *   Telegram Bot integration for deadline warnings and status updates.

### Out of Scope for MVP
*   Self-registration for Parents/Companies (Manual creation only).
*   In-app chat (Use comments on tasks + Telegram).
*   Billing/Subscription management for Companies.
*   Complex individual timezone management (Default: Asia/Almaty).
*   Native Mobile App (Responsive Web App only).

---

## Technical Preferences

*   **Frontend:** Next.js (App Router), TypeScript, Tailwind CSS, Zustand.
*   **Backend:** NestJS (Modular Monolith), Prisma ORM.
*   **Database:** PostgreSQL.
*   **Process Engine:** Camunda (via REST).
*   **Storage:** MinIO (S3 compatible).
*   **Infrastructure:** Docker + Docker Compose.

---

## Timeline & Resources

*   **Total Duration:** 8 Weeks (estimated from TZ).
    *   **Weeks 1-2:** Analytics, Design (Figma), Core Backend setup.
    *   **Weeks 3-4:** Backend Core (Tasks, Students) & API.
    *   **Weeks 5-6:** Frontend Student Area.
    *   **Weeks 7-8:** Frontend Curator/Admin Area, Integration, Testing.

---
_Generated based on technical specification "tz.md"._
--- END FILE: docs/project-brief.md ---

--- BEGIN FILE: docs/requirements/document-workflow.md ---
# Архитектура Знаний: Документооборот (Document Workflow)

Этот файл является единым источником правды для требований к документам абитуриента (Docs First).
В системе BMAD этот файл определяет логику UI, валидации и подсказок для агентов и разработчиков.

## Формат описания документа

Для каждого типа документа определены три обязательных блока:
1.  **Совет (Advice):** Инструкция для студента — куда идти и что делать (ЦОН, Министерство, Бюро переводов).
2.  **Валидация (Validation):** Чек-лист для менеджера — что именно проверять (печать, QR, апостиль).
3.  **UI-Hint:** Текст подсказки для модального окна загрузки файла (инструкция и текст типичной ошибки).

---

## 1. Апостиль (Apostille)

### Совет (Advice)
Оригинал диплома/аттестата должен иметь штамп "Апостиль". Это подтверждение юридической силы документа за рубежом.
*   **Где получить:** ЦОН (Центр Обслуживания Населения) или Министерство образования.
*   **Срок:** До 15 рабочих дней. Планируйте заранее!
*   **Важно:** Апостиль ставится на оригинал или нотариально заверенную копию (зависит от страны назначения).

### Валидация (Validation)
Менеджер проверяет:
1.  [ ] Наличие штампа "Apostille" (обычно на оборотной стороне или на отдельном листе, подшитом к документу).
2.  [ ] Читаемость печати и подписи должностного лица.
3.  [ ] Целостность скрепления документа (ленточка/нитка не должна быть надорвана).

### UI-Hint
*   **Инструкция:** "Оригинал диплома должен иметь штамп Апостиль (выдается Министерством образования). Срок: до 15 рабочих дней."
*   **Ошибка:** "Загружен скан без штампа на оборотной стороне."

---

## 2. Скан Паспорта (Passport Scan)

### Совет (Advice)
Главный документ для зачисления и визы.
*   **Что нужно:** Качественный цветной скан главного разворота (с фото).
*   **Требования:** Срок действия паспорта должен быть актуальным (минимум 6-18 месяцев запас после начала учебы).

### Валидация (Validation)
Менеджер проверяет:
1.  [ ] Читаемость всех зон (MRZ, ФИО, номер).
2.  [ ] Отсутствие бликов на лице и тексте.
3.  [ ] Видимость всех 4-х углов разворота.
4.  [ ] Срок действия паспорта.

### UI-Hint
*   **Инструкция:** "Загрузите цветной скан или фото главного разворота загранпаспорта. Убедитесь, что нет бликов и видны все углы."
*   **Ошибка:** "Скан обрезан или текст не читаем из-за бликов."

---

## 3. Справка с места учебы (School Certificate)

### Совет (Advice)
Подтверждение того, что вы сейчас обучаетесь в школе/университете.
*   **Где получить:** У секретаря в школе или в деканате/офисе регистратора (для студентов).
*   **Язык:** Если справка не на английском, может потребоваться перевод.

### Валидация (Validation)
Менеджер проверяет:
1.  [ ] Наличие даты выдачи (должна быть свежей, обычно < 3 месяцев).
2.  [ ] Наличие "живой" печати учебного заведения.
3.  [ ] Наличие подписи ответственного лица.

### UI-Hint
*   **Инструкция:** "Загрузите скан справки с работы/учебы с печатью и датой выдачи."
*   **Ошибка:** "Справка устарела или отсутствует печать."

---

## 4. Нотариальный перевод (Notarized Translation)

### Совет (Advice)
Перевод документов (диплом, паспорт, справки) на язык обучения (обычно английский).
*   **Где получить:** Бюро переводов с нотариальным заверением.
*   **Важно:** Перевод должен быть сшит с копией исходного документа.

### Валидация (Validation)
Менеджер проверяет:
1.  [ ] Наличие подписи переводчика.
2.  [ ] Наличие печати и подписи нотариуса.
3.  [ ] Соответствие данных в переводе оригиналу (ФИО, даты).

### UI-Hint
*   **Инструкция:** "Загрузите скан перевода, сшитого с копией документа, заверенный нотариусом."
*   **Ошибка:** "Нет заверения нотариуса или неполный документ."
--- END FILE: docs/requirements/document-workflow.md ---

--- BEGIN FILE: docs/requirements/prd-document-upload.md ---
# PRD: Document Upload System & Requirements
**Version:** 1.0
**Date:** 2026-01-01
**Author:** Mary (Business Analyst)

## 1. System Overview
This Product Requirements Document (PRD) defines the specific requirements, validation logic, and user guidance for the document upload module within the Student Admission System. The goal is to minimize rejection rates by providing clear, "Advice"-driven interfaces and strict validation criteria.

---

## 2. Global Technical Requirements
These requirements apply to **all** document types unless specified otherwise.

*   **File Formats:** PDF (preferred for documents), JPEG/PNG (acceptable for photos/scans).
*   **Max File Size:** 10 MB per file.
*   **Filename:** Auto-normalized by system (e.g., `{student_id}_{doc_type}_{timestamp}.pdf`).
*   **Compression:** Automatic server-side compression if > 5MB (optional optimization).

---

## 3. Document Types & Specifications

### 3.1. Passport (International) / Паспорт
*   **Description:** The main identity document for visa and admission.
*   **Format:** PDF or JPEG (High Quality).
*   **Advice (Instruction):**
    1.  Go to the Public Service Center (PSC / ЦОН) or Migration Police.
    2.  Request an International Passport (distinct from ID card).
    3.  Scan the **main spread** (photo + signature page) in color.
    4.  Ensure validity is at least 6-12 months beyond the intended start of studies.
*   **Validation (Checklist):**
    *   [ ] Full spread visible (all 4 corners).
    *   [ ] No glare on the photo or text.
    *   [ ] MRZ code (bottom lines) fully legible.
    *   [ ] Signature present.
*   **Typical Errors:**
    *   Scanning only one page instead of the spread.
    *   Flash glare obscuring details.
    *   Expired or expiring soon.

### 3.2. Digital Photo / Фотография (3x4 or 3.5x4.5)
*   **Description:** Official photo for student ID and visa application forms.
*   **Format:** JPEG/PNG only (Original digital file, not a scan of a photo).
*   **Advice (Instruction):**
    1.  Visit a professional photo studio.
    2.  Ask for a digital version (emailed to you).
    3.  Background: White or Light Grey (neutral).
    4.  Expression: Neutral, looking directly at the camera.
*   **Validation (Checklist):**
    *   [ ] Aspect ratio correct (3:4 or 3.5:4.5).
    *   [ ] White uniform background.
    *   [ ] Face takes up 70-80% of the height.
    *   [ ] High resolution (> 600dpi equivalent).
*   **Typical Errors:**
    *   Selfie or cropped casual photo.
    *   Scan of a printed photo (visible grain/texture).
    *   Colored or busy background.

### 3.3. High School Diploma / Аттестат
*   **Description:** Certificate of Completed Secondary Education.
*   **Format:** PDF (Color Scan).
*   **Advice (Instruction):**
    1.  Obtain the original document from your school administration after graduation.
    2.  Scan the hard cover and the main title page.
    3.  Ensure the "Series" and "Number" are clearly visible.
*   **Validation (Checklist):**
    *   [ ] Official School Stamp visible.
    *   [ ] Director/Principal signature present.
    *   [ ] Document Series/Number legible.
    *   [ ] No physical damage/tears.
*   **Typical Errors:**
    *   Uploading a copy instead of the original.
    *   Missing the cover page (if required).
    *   Blurry text.

### 3.4. Transcript / Табель (Приложение к аттестату)
*   **Description:** The complete list of grades/subjects accompanying the Diploma.
*   **Format:** PDF (Multi-page scan).
*   **Advice (Instruction):**
    1.  Usually issued together with the Attestat.
    2.  If not yet graduated, request a "Preliminary Transcript" (Spravka) from the school office.
    3.  Scan all pages (including the grading scale explanation).
*   **Validation (Checklist):**
    *   [ ] All subjects and grades listed.
    *   [ ] Matches the Attestat number.
    *   [ ] School stamp on every page (if multi-page).
*   **Typical Errors:**
    *   Missing pages.
    *   Partially cropped grades.
    *   Submitted a widely different format (e.g., a diary text dump).

### 3.5. Apostille Certificate / Апостиль
*   **Description:** International legalization stamp confirming the document's validity.
*   **Format:** PDF (Scan of the Apostilled document or the separate Apostille page).
*   **Advice (Instruction):**
    1.  Take your original Diploma/Attestat to the Public Service Center (PSC/ЦОН).
    2.  Submit for "Apostille" (Ministry of Education service).
    3.  Wait 15-30 days (Standard processing time).
    4.  The stamp is usually placed on the back of the original or on a bound ribbon-tied sheet.
*   **Validation (Checklist):**
    *   [ ] Stamp title "Apostille (Convention de La Haye)".
    *   [ ] Bound securely to the original document (ribbon/seal integrity).
    *   [ ] Signature of the Ministry official.
*   **Typical Errors:**
    *   Apostille on a *Notarized Copy* instead of the *Original* (some countries reject copies).
    *   Scanning only the stamp without the document it validates.

### 3.6. Notarized Translations / Нотариальные Переводы
*   **Description:** Official translation of Diploma, Passport, etc., into English (or target language).
*   **Format:** PDF.
*   **Advice (Instruction):**
    1.  Go to a licensed Translation Bureau.
    2.  Request "Notarized Translation" (Perevod s zavereniem).
    3.  The translator signs, and the Notary certifies the signature.
    4.  Must be bound (sewn) to a copy of the original document.
*   **Validation (Checklist):**
    *   [ ] Notary's stamp and seal.
    *   [ ] Translator's signature.
    *   [ ] Stitching/Binding integrity shown in scan.
    *   [ ] Correct spelling of Names (Must match Passport exactly).
*   **Typical Errors:**
    *   Name spelling mismatch (e.g., "Alexey" vs "Aleksei").
    *   Plain translation without Notary seal.
    *   Translating the Apostille stamp incorrectly.

### 3.7. Language Certificate / Сертификат (IELTS/TOEFL)
*   **Description:** Proof of English proficiency.
*   **Format:** PDF (Digital Certificate or Scan).
*   **Advice (Instruction):**
    1.  Register for the exam at British Council or IDP.
    2.  Take the exam and wait 13 days for results.
    3.  Download the "e-TRF" (Test Report Form) or scan the paper certificate.
*   **Validation (Checklist):**
    *   [ ] "Academic" module (not General Training).
    *   [ ] Test Report Form Number visible (for online verification).
    *   [ ] Note score validity (usually 2 years).
    *   [ ] Scores match minimum requirements (e.g., Overall 6.0).
*   **Typical Errors:**
    *   Expired certificate (>2 years).
    *   "General Training" module submitter.
    *   Screenshot of website results instead of official TRF.

### 3.8. Bank Statement / Справка из Банка (Proof of Funds)
*   **Description:** Financial guarantee for Visa/University.
*   **Format:** PDF.
*   **Advice (Instruction):**
    1.  Open your Banking App or visit a branch.
    2.  Request a "Certificate of Balance" (English language).
    3.  If possible, include "Transaction History" for 3-6 months.
    4.  Ensure currency equivalent is shown (USD/EUR).
*   **Validation (Checklist):**
    *   [ ] Issued on Bank Letterhead.
    *   [ ] Wet stamp or QR code for digital verification.
    *   [ ] Date of issue fresh (< 1 month).
    *   [ ] Sufficient amount covering tuition + living expenses.
*   **Typical Errors:**
    *   Statement in local language only (no English).
    *   Old statement (> 3 months).
    *   "Deposit Agreement" instead of "Balance Certificate".

---

## 4. Status Workflow

The system tracks the lifecycle of each document through the following statuses:

1.  **Ожидает (Pending)**
    *   **Meaning:** Task created, no file uploaded yet.
    *   **User Action:** User needs to click "Upload" and select a file.
    *   **System Action:** Timer running (if deadline exists).

2.  **На проверке (Under Review)**
    *   **Meaning:** File uploaded by Student. Waiting for Curator action.
    *   **User Action:** Locked (cannot edit unless retracted).
    *   **Curator Action:** Review file against Validation Checklist. Approve or Reject.

3.  **Требует доработки (Needs Revision)**
    *   **Meaning:** Curator rejected the document.
    *   **User Action:** Read comment (e.g., "Glare on photo"), delete old file, upload new one.
    *   **System Action:** Notification sent to Student.

4.  **Принято (Accepted)**
    *   **Meaning:** Document passed all specific checks.
    *   **User Action:** View only (cannot delete).
    *   **System Action:** File locked, XP awarded, logic proceeds to next step.
--- END FILE: docs/requirements/prd-document-upload.md ---

--- BEGIN FILE: docs/stories/US1.1-login.md ---
# US1.1: User Login

**Epic:** SaaS Foundation & Identity
**Status:** Review

## Description
As a **User**, I want to log in using my email and password so I can access the system.

## Acceptance Criteria
- [ ] User can authenticate with valid email and password
- [ ] System issues a JWT upon successful login
- [ ] System displays an error message for invalid credentials
- [ ] User is redirected to the appropriate dashboard based on their role after login

## In Scope
- JWT generation and validation
- Basic email/password check against DB (User entity)
- Role guard payload in JWT
- Frontend Login Page with error handling
- Redirection logic

## Out of Scope
- Registration (handled in Admin onboarding or separate story)
- Forgot Password
- 2FA

## Tasks/Subtasks

### Backend (apps/api)
- [x] **Setup Auth Module**: Create `AuthModule`, `AuthService`, `AuthController`
- [x] **Implement User Entity**: Define `User` entity with email, password (hashed), role, companyId
- [x] **Implement Login Logic**: `validateUser` checks credentials; `login` returns JWT
- [x] **Configure JWT Strategy**: Setup Passport JWT strategy
- [x] **Add Role Guard**: Create `RolesGuard` and `@Roles` decorator (preparatory for US1.3 but needed for login redirection logic validation)

### Frontend (apps/web)
- [x] **Create Login Page**: `app/login/page.tsx` with Email/Password inputs
- [x] **Implement API Integration**: Service/Function to call `POST /auth/login`
- [x] **Handle Auth State**: Store JWT (in cookie/localStorage) and User info using Zustand
- [x] **Implement Redirection**: Logic to route to `/dashboard` (Student) or `/admin` (Admin) based on role

### Testing
- [x] **Backend Unit Tests**: coverage for `AuthService`
- [x] **E2E Test**: `POST /auth/login` valid and invalid cases

## Dev Agent Record

### Debug Log
- [ ] 

### Completion Notes
- [ ] 

## File List
- [ ] 

## Change Log
- [ ]
--- END FILE: docs/stories/US1.1-login.md ---

--- BEGIN FILE: docs/stories/US1.2-tenant-isolation.md ---
# US1.2: Tenant Isolation

**Epic:** SaaS Foundation & Identity
**Status:** Open

## Description
As a **Tenant Admin**, I want to ensure my data is invisible to other companies.

## Acceptance Criteria
- [ ] API enforces `companyId` filter on ALL database queries
- [ ] Users cannot access resources (students, tasks, files) belonging to other tenants
- [ ] Access attempts to cross-tenant resources return 403 Forbidden or 404 Not Found
--- END FILE: docs/stories/US1.2-tenant-isolation.md ---

--- BEGIN FILE: docs/stories/US1.3-role-management.md ---
# US1.3: Role Management

**Epic:** SaaS Foundation & Identity
**Status:** Open

## Description
As a **System**, I want to handle roles (Student, Curator, Admin) so users see only what they need.

## Acceptance Criteria
- [ ] Backend implements Guards/Decorators (e.g., in NestJS) to restrict endpoints by Role
- [ ] UI conditionally renders menu items and views based on the logged-in user's role
- [ ] Unauthorized access attempts to role-protected routes are blocked
--- END FILE: docs/stories/US1.3-role-management.md ---

--- BEGIN FILE: docs/stories/US2.1-task-matrix.md ---
# US2.1: Student Task Matrix (Roadmap)

**Epic:** The Student Quest (Gamified Journey)
**Status:** Open

## Description
As a **Student**, I want to see a Task Matrix (Roadmap) so I know exactly what steps are required.

## Acceptance Criteria
- [ ] Display a list/matrix of tasks ordered by phase
- [ ] Tasks show visually distinct states: "Locked", "Unlocked", "Done"
- [ ] Task availability is driven by the backend (Camunda state)
--- END FILE: docs/stories/US2.1-task-matrix.md ---

--- BEGIN FILE: docs/stories/US2.2-kanban-board.md ---
# US2.2: Student Kanban Board

**Epic:** The Student Quest (Gamified Journey)
**Status:** Open

## Description
As a **Student**, I want to use a Kanban Board to track my progress.

## Acceptance Criteria
- [ ] Kanban board displays columns: "Todo", "Review", "Done"
- [ ] Tasks appear in the correct column based on their status
- [ ] Drag and drop is DISABLED (state transitions are managed by specific actions, not dragging)
--- END FILE: docs/stories/US2.2-kanban-board.md ---

--- BEGIN FILE: docs/stories/US2.3-document-upload.md ---
# US2.3: Document Upload

**Epic:** The Student Quest (Gamified Journey)
**Status:** Open

## Description
As a **Student**, I want to upload documents (PDF/Img) for a task so I can submit my work.

## Acceptance Criteria
- [ ] User can select a file to upload for a specific task
- [ ] System validates file type (PDF, Images) and size
- [ ] Upload progress bar is displayed
- [ ] Uploaded file preview (or link) is shown after success
--- END FILE: docs/stories/US2.3-document-upload.md ---

--- BEGIN FILE: docs/stories/US2.4-submit-task.md ---
# US2.4: Submit Task

**Epic:** The Student Quest (Gamified Journey)
**Status:** Open

## Description
As a **Student**, I want to "Submit" a task for review so I can move to the next step.

## Acceptance Criteria
- [ ] "Submit" button is active ONLY if required files are uploaded
- [ ] Clicking Submit changes task status to "Review"
- [ ] Task becomes read-only for the student while in Review
--- END FILE: docs/stories/US2.4-submit-task.md ---

--- BEGIN FILE: docs/stories/US2.5-xp-avatar.md ---
# US2.5: XP & Avatar Rewards

**Epic:** The Student Quest (Gamified Journey)
**Status:** Open

## Description
As a **Student**, I want to earn XP and see my Avatar level up so I feel rewarded.

## Acceptance Criteria
- [ ] XP is awarded when a task is Approved
- [ ] UI shows XP gain animation
- [ ] Progress bar updates towards the next level
- [ ] Avatar visual changes or levels up based on total XP
--- END FILE: docs/stories/US2.5-xp-avatar.md ---

--- BEGIN FILE: docs/stories/US2.6-download-zip.md ---
# US2.6: Download All Documents

**Epic:** The Student Quest (Gamified Journey)
**Status:** Open

## Description
As a **Student**, I want to download all my approved docs as a ZIP so I have a backup.

## Acceptance Criteria
- [ ] "Download All" button available in profile or dashboard
- [ ] Generates a ZIP file containing all files from tasks with status "Done"
- [ ] Download starts effectively within reasonable time
--- END FILE: docs/stories/US2.6-download-zip.md ---

--- BEGIN FILE: docs/stories/US3.1-curator-student-list.md ---
# US3.1: Curator Student List & Risk Indicators

**Epic:** Curator Command Center
**Status:** Open

## Description
As a **Curator**, I want to see a list of my assigned students with "Risk" indicators.

## Acceptance Criteria
- [ ] List of assigned students is displayed
- [ ] Table is filterable/sortable
- [ ] Progress percentage is shown for each student
- [ ] "Red flag" or risk indicator appears if a deadline is approaching or missed
--- END FILE: docs/stories/US3.1-curator-student-list.md ---

--- BEGIN FILE: docs/stories/US3.2-review-inbox.md ---
# US3.2: Review Inbox

**Epic:** Curator Command Center
**Status:** Open

## Description
As a **Curator**, I want a global "Review Inbox" so I can see all pending work in one place.

## Acceptance Criteria
- [ ] Dashboard shows a "Review Inbox" section
- [ ] Aggregates all tasks in "Review" status across all assigned students
- [ ] Navigation allows clicking a task to view the submission details
--- END FILE: docs/stories/US3.2-review-inbox.md ---

--- BEGIN FILE: docs/stories/US3.3-approve-submission.md ---
# US3.3: Approve Submission

**Epic:** Curator Command Center
**Status:** Open

## Description
As a **Curator**, I want to Approve a submission.

## Acceptance Criteria
- [ ] Curator can view uploaded file/submission
- [ ] "Approve" action moves task status to "Done"
- [ ] System automatically triggers XP award to student
- [ ] Notification sent to student
--- END FILE: docs/stories/US3.3-approve-submission.md ---

--- BEGIN FILE: docs/stories/US3.4-reject-submission.md ---
# US3.4: Reject Submission

**Epic:** Curator Command Center
**Status:** Open

## Description
As a **Curator**, I want to Reject a submission with a comment.

## Acceptance Criteria
- [ ] "Reject" action is available
- [ ] Requiring a comment/reason is MANDATORY for rejection
- [ ] Task status moves back to "Todo"
- [ ] Student sees the rejection comment highlighted on the task
--- END FILE: docs/stories/US3.4-reject-submission.md ---

--- BEGIN FILE: docs/stories/US4.1-manage-uni-country.md ---
# US4.1: Manage Reference Data (Universities/Countries)

**Epic:** Administration & Content
**Status:** Open

## Description
As an **Admin**, I want to manage Universities and Countries.

## Acceptance Criteria
- [ ] Admin dashboard provides interface to list, create, edit, delete Countries
- [ ] Admin dashboard provides interface to list, create, edit, delete Universities
- [ ] Data validation ensures required fields are present
--- END FILE: docs/stories/US4.1-manage-uni-country.md ---

--- BEGIN FILE: docs/stories/US4.2-task-templates.md ---
# US4.2: Task Templates

**Epic:** Administration & Content
**Status:** Open

## Description
As an **Admin**, I want to create Task Templates linked to BPMN IDs.

## Acceptance Criteria
- [ ] Editor allows defining Task Title, Description, XP Value
- [ ] Editor allows linking the template to a specific Camunda Activity ID (BPMN Task ID)
- [ ] Attributes like "Document Required" (boolean) or "Deadline Offset" can be set
--- END FILE: docs/stories/US4.2-task-templates.md ---

--- BEGIN FILE: docs/stories/US4.3-onboard-curators.md ---
# US4.3: Onboard Curators

**Epic:** Administration & Content
**Status:** Open

## Description
As an **Admin**, I want to onboard new Curators.

## Acceptance Criteria
- [ ] Admin can invite a Curator via email OR create an account directly
- [ ] Curator account is assigned the correct Role
- [ ] Curator can log in after account creation
--- END FILE: docs/stories/US4.3-onboard-curators.md ---

--- BEGIN FILE: docs/stories/US5.1-camunda-sync.md ---
# US5.1: Camunda Synchronization

**Epic:** System Integrations
**Status:** Open

## Description
As a **System**, I want to sync task status with Camunda.

## Acceptance Criteria
- [ ] When a Curator approves a task in Abbit, the corresponding User Task in Camunda is completed
- [ ] When the Camunda process reaches a new User Task, a corresponding Task entity is created in the Abbit database
- [ ] Two-way synchronization ensures state consistency
--- END FILE: docs/stories/US5.1-camunda-sync.md ---

--- BEGIN FILE: docs/stories/US5.2-link-telegram.md ---
# US5.2: Link Telegram Account

**Epic:** System Integrations
**Status:** Open

## Description
As a **Student**, I want to link my Telegram account.

## Acceptance Criteria
- [ ] User can generate a unique "Binding Code" in their Profile
- [ ] User sends the code to the Abbit Telegram Bot
- [ ] Bot verifies code and updates user profile with `chat_id`
- [ ] Confirmation message sent to Telegram
--- END FILE: docs/stories/US5.2-link-telegram.md ---

--- BEGIN FILE: docs/stories/US5.3-parent-notifications.md ---
# US5.3: Parent Notifications

**Epic:** System Integrations
**Status:** Open

## Description
As a **Parent**, I want to receive Telegram notifications about my child's progress.

## Acceptance Criteria
- [ ] System sends notifications for key events: Submission, Approval, Rejection, Deadline Warning
- [ ] Notifications are sent to the linked Student's Telegram (or distinct Parent account if applicable)
- [ ] Notification content is clear and informative
--- END FILE: docs/stories/US5.3-parent-notifications.md ---

--- BEGIN FILE: docs/stories/US5.4-minio-storage.md ---
# US5.4: Secure File Storage (MinIO)

**Epic:** System Integrations
**Status:** Open

## Description
As a **System**, I want to store files securely in MinIO.

## Acceptance Criteria
- [ ] Files are uploaded to MinIO buckets structured by `{companyId}/{studentId}/...`
- [ ] Files are NOT accessible via public public URLs
- [ ] Access is granted only via generated presigned URLs with short expiration
--- END FILE: docs/stories/US5.4-minio-storage.md ---

--- BEGIN FILE: docs/stories/manager-review.md ---
# Manager Document Review Process (Admin UI)

**Status:** Draft
**Role:** Manager / Curator / Admin

## 1. Overview
This story defines the interface and workflow for a Manager to review documents uploaded by students. The goal is to provide a streamlined "Review Mode" where the manager can efficiently validate documents against specific rules and provide quick feedback (approval or rejection with reasons).

## 2. Student List (Dashboard)
The entry point is a list of students filtered by status.

*   **View:** Table or Card list of students.
*   **Filter Condition:** Status = "Requiring Verification" (or equivalent, e.g., "Review Pending").
*   **Columns/Info:**
    *   Student Name
    *   Course / University
    *   Document Name (e.g., "School Diploma")
    *   Submission Date
    *   **Action:** Click on the row/student to enter **Document Review Mode**.

## 3. Document Review Mode
Upon clicking a student/document, the interface shifts to a focused review dashboard designed for high-throughput validation.

### 3.1 Layout
The screen is split into two main panels:

#### **Left Panel: Document Viewer**
*   **Content:** Displays the file uploaded by the student.
*   **Source:** Fetched securely from MinIO.
*   **Capabilities:**
    *   **PDF:** Built-in PDF viewer with zoom/scroll.
    *   **Image:** Image viewer with zoom/pan capabilities.
    *   **Fallback:** "Download" button if the file type cannot be previewed in-browser.

#### **Right Panel: Validation Checklist**
*   **Source:** Driven by the `document_templates` table, specifically the `validation_rules` field for the current document type.
*   **UI Components:**
    *   A list of checkable items (e.g., "Stamp is visible", "Notary seal present", "Date is within valid range").
    *   These serve as a guide for the manager but may not necessarily require physical checking to proceed (depending on strictness preference, currently treated as a visual guide).

### 3.2 Actions
The footer or top-right of the Review Panel contains the decision actions:

*   **Approve Button (Green):**
    *   **Action:** Marks the document task as `DONE`.
    *   **Feedback:** Toast notification "Document Approved".
    *   **Navigation:** Automatically loads the next pending document (if available) or returns to the list.

*   **Reject Button (Red):**
    *   **Action:** Opens the **Rejection Dialog/Modal**.

## 4. Rejection Workflow
When "Reject" is clicked, the manager **MUST** provide a reason.

### 4.1 Rejection Dialog
*   **Dropdown:** "Reason for Rejection"
    *   **Source:** `rejection_reasons` table/enum.
    *   **Examples:** "Blurry Image", "Wrong Document", "Missing Stamp", "Expired", "Translation Required".
*   **Text Area:** "Comment for Student"
    *   **Behavior:** Auto-filled based on the selected dropdown reason (if a template exists) but editable.
    *   **Requirement:** Mandatory. The manager cannot reject without a comment/reason.

### 4.2 Outcome
*   **System Action:**
    *   Update Task Status to `TODO` (or `REJECTED`).
    *   Save the comment to the task/submission record.
*   **Student Notification:**
    *   The specific comment entered by the manager is sent to the Student.
    *   Appears in the Student's "Action Required" modal or feedback stream.

## 5. Data Sources
*   **Validation Rules:** `document_templates.validation_rules` (JSON/Array).
*   **Rejection Reasons:** `rejection_reasons` (Table/Enum).
*   **Document Files:** MinIO Object Storage.
--- END FILE: docs/stories/manager-review.md ---

--- BEGIN FILE: next-env.d.ts ---
/// <reference types="next" />
/// <reference types="next/image-types/global" />
import "./.next/dev/types/routes.d.ts";

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.
--- END FILE: next-env.d.ts ---

--- BEGIN FILE: package.json ---
{
  "name": "my-abiturient-monorepo",
  "private": true,
  "workspaces": [
    "apps/web",
    "apps/api"
  ],
  "scripts": {
    "dev:web": "npm --workspace apps/web run dev",
    "build:web": "npm --workspace apps/web run build",
    "dev:api": "npm --workspace apps/api run start:dev",
    "build:api": "npm --workspace apps/api run build"
  }
}
--- END FILE: package.json ---

--- BEGIN FILE: shared/AuthContext.tsx ---
"use client";
import { useRouter } from "next/navigation";
import React, { createContext, useContext, useEffect, useState } from "react";

type User = {
  name: string;
  role: "student" | "curator";
};

type AuthContextType = {
  user: User | null;
  loading: boolean;
  login: (role: "student" | "curator") => void;
  logout: () => void;
};

const AuthCtx = createContext<AuthContextType | null>(null);

export const AuthProvider: React.FC<React.PropsWithChildren> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const router = useRouter();

  useEffect(() => {
    try {
      const storedUser = localStorage.getItem("authUser");
      if (storedUser) {
        setUser(JSON.parse(storedUser));
      }
    } catch (e) {
      console.error("Failed to parse auth user from localStorage", e);
    } finally {
      setLoading(false);
    }
  }, []);

  const login = (role: "student" | "curator") => {
    const newUser: User = { name: role === "student" ? "Студент" : "Куратор", role };
    localStorage.setItem("authUser", JSON.stringify(newUser));
    setUser(newUser);
    router.replace(role === "student" ? "/student/dashboard" : "/curator/dashboard");
  };

  const logout = () => {
    localStorage.removeItem("authUser");
    setUser(null);
    router.replace("/login");
  };

  const value = { user, loading, login, logout };

  return <AuthCtx.Provider value={value}>{children}</AuthCtx.Provider>;
};

export const useAuth = () => {
  const ctx = useContext(AuthCtx);
  if (!ctx) throw new Error("useAuth must be used within an AuthProvider");
  return ctx;
};
--- END FILE: shared/AuthContext.tsx ---

--- BEGIN FILE: shared/ProgressContext.tsx ---
"use client";
import React, { createContext, useContext, useEffect, useState } from "react";

/* --- ИЗМЕНЕНИЕ: Добавлен статус для задач, требующих правок --- */
export type ProgressStatus = "review" | "done" | "changes_requested";
export type ProgressItem = {
  status: ProgressStatus;
  submission: any; // Allow storing strings or objects
  comment?: string; // Комментарий куратора
};
type ProgressState = Record<number, ProgressItem>;

type ProgressContextType = {
  progress: ProgressState;
  submitQuest: (questId: number, submission: any) => void;
  uncompleteQuest: (questId: number) => void;
  approveQuest: (questId: number) => void;
  requestChanges: (questId: number, comment: string) => void;
};

const ProgressCtx = createContext<ProgressContextType | null>(null);

// app/shared/ProgressContext.tsx

const STORAGE_KEY = "userProgress_submissions";
const MOCK_INITIAL_PROGRESS: ProgressState = {
  1: { status: "review", submission: { email: "student@gmail.com", password: "password123" } },
  11: { status: "review", submission: "photo_for_passport.jpg" }, // <--- ВОТ ИЗМЕНЕНИЕ
  10: { status: "done", submission: "passport_scan.pdf" },
  12: { status: "done", submission: "school_apostille.pdf" },
  13: { status: "done", submission: "college_docs.pdf" },
};

export const ProgressProvider: React.FC<React.PropsWithChildren> = ({ children }) => {
  const [progress, setProgress] = useState<ProgressState>({});

  useEffect(() => {
    try {
      const storedProgress = localStorage.getItem(STORAGE_KEY);
      if (storedProgress) {
        setProgress(JSON.parse(storedProgress));
      } else {
        // Если нет прогресса в хранилище, заполняем его мок-данными
        setProgress(MOCK_INITIAL_PROGRESS);
        localStorage.setItem(STORAGE_KEY, JSON.stringify(MOCK_INITIAL_PROGRESS));
      }
    } catch (e) {
      console.error("Failed to parse progress from localStorage", e);
    }
  }, []);

  const submitQuest = (questId: number, submission: any) => {
    // All submissions first go to "review" status
    // If resubmitting after changes were requested, clear the old comment
    setProgress((prev) => {
      const updatedProgress = {
        ...prev,
        // При повторной отправке задача снова уходит на проверку, комментарий очищается
        [questId]: { status: "review" as ProgressStatus, submission }
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(updatedProgress));
      return updatedProgress;
    });
  };

  const uncompleteQuest = (questId: number) => {
    setProgress((prev) => {
      const updatedProgress = { ...prev };
      delete updatedProgress[questId];
      localStorage.setItem(STORAGE_KEY, JSON.stringify(updatedProgress));
      return updatedProgress;
    });
  };

  const approveQuest = (questId: number) => {
    setProgress((prev) => {
      if (!prev[questId]) return prev; // Cannot approve something that doesn't exist
      const updatedProgress = { ...prev };
      updatedProgress[questId] = { ...updatedProgress[questId], status: "done" as ProgressStatus };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(updatedProgress));
      return updatedProgress;
    });
  };

  /* --- НОВОЕ: Функция для отправки задачи на доработку --- */
  const requestChanges = (questId: number, comment: string) => {
    setProgress((prev) => {
      if (!prev[questId]) return prev;
      const updatedProgress = { ...prev };
      updatedProgress[questId] = { ...updatedProgress[questId], status: "changes_requested" as ProgressStatus, comment };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(updatedProgress));
      return updatedProgress;
    });
  };

  const value = {
    progress,
    submitQuest,
    uncompleteQuest,
    approveQuest,
    requestChanges,
  };

  return <ProgressCtx.Provider value={value}>{children}</ProgressCtx.Provider>;
};

export const useProgress = () => {
  const ctx = useContext(ProgressCtx);
  if (!ctx) throw new Error("useProgress must be used within a ProgressProvider");
  return ctx;
};
--- END FILE: shared/ProgressContext.tsx ---

--- BEGIN FILE: tz.md ---
Техническое задание на разработку системы сопровождения абитуриентов «Abbit»
1. Общие сведения
1.1. Цель проекта
Создать веб-платформу для сопровождения абитуриентов по процессу поступления в зарубежные университеты в
формате Tasks (квестов) и чек-листов, с:
● личным кабинетом Студента,
● кабинетом Куратора,
● базовой админ-частью для настройки стран / университетов / программ / шаблонов задач,
● интеграцией с BPMN-движком Camunda (через REST API) для управления процессами (на старте —
регистрация и онбординг),
● заделом под полноценный SaaS-режим для нескольких агентств (Companies) с логической изоляцией
данных.
Система должна:
● убрать хаос из коммуникаций «куратор — студент» (разрозненные чаты, таблицы, файлы),
● дать студенту понятную дорожную карту, прогресс, дедлайны и игровую мотивацию (XP + аватар),
● дать куратору единую панель управления студентами и их задачами,
● позволить легко масштабировать продукт на несколько агентств (multi-company) без дублирования кода.
1.2. Тип системы и стек
Тип системы:
● Веб-приложение (SPA/MPA) на базе Next.js (App Router).
● Backend API на NestJS (Modular Monolith).
● Процессный движок — Camunda (через REST API /engine-rest).
● База данных — PostgreSQL.
● ORM — Prisma (с middleware для multi-company).
● Хранилище файлов — S3-совместимое (MinIO / S3).
1.3. Основные роли (бизнес-роли)
1. Company Admin (Администратор компании / агентства)
○ Управляет пользователями (кураторами), базовыми настройками,
странами/университетами/программами, шаблонами задач.
○ В будущем — управляет тарифами, квотами и биллингом.
Имеет расширенный (god mode) доступ к данным своей Company: может видеть всех студентов и их задачи,
редактировать настройки и выполнять операции экспорта/удаления в пределах своей компании.
2. Curator (Куратор)
○ Ведёт пул студентов.
○ Проверяет задачи (Tasks), оставляет комментарии, запрашивает доработки.
○ Следит за дедлайнами и рисками по всем студентам.
○ Привязывает Telegram-группы студентов через Binding Code.
3. Student (Студент / Игрок)
○ Проходит задачи (Tasks), загружает документы / ссылки / данные.
○ Следит за прогрессом, дедлайнами и «папкой документов».
○ Получает XP и кастомизирует аватар.
4. Parent (Родитель / Наблюдатель)
○ Получает уведомления в Telegram-группе.
○ Получает доступ к просмотру прогресса ребёнка (read-only режим) и уведомлениям в общей
Telegram-группе. В рамках MVP отдельный логин/кабинет для Parent не реализуется: родитель при
необходимости использует учётные данные студента.
1.4. Multi-company (multi-tenant логика)
Понятие Company (компания/агентство):
● Компания — отдельный клиент SaaS-платформы.
● Все сущности (Users, Students, Tasks и т.д.) принадлежат конкретной Company через companyId.
● Изоляция: данные одной Company невидимы для других.
Архитектура:
● Shared Database, Logical Isolation:
○ один инстанс Backend + один инстанс Frontend + одна БД,
○ все запросы к БД проходят через Prisma Middleware, принудительно добавляющее WHERE
companyId = currentCompanyId.
Определение текущей Company:
● для пользователей (Curator/Admin/Student) — по связке userId → companyId после логина;
● для внутренних сервисов — по заголовку X-Company-ID.
Создание новых записей Company и первичных Company Admin выполняется вручную через внутреннего SuperAdmin
(без публичной регистрации компании на фронтенде).
2. Функциональные требования
2.1. Авторизация и регистрация
2.1.1. Регистрация студента
Маршрут фронтенда: /login (секция «Быстрая регистрация»).
Форма регистрации:
● Поля:
○ email — обязательное, валидный email,
○ password — обязательное, минимум 8 символов,
○ passwordConfirm — совпадает с password,
○ опционально: fullName.
● Поле выбора роли на фронте не показывать — всегда создаётся роль student.
Фронтенд-валидация:
● формат email,
● длина пароля,
● совпадение паролей.
Backend: POST /auth/register
Логика:
1. 2. Проверить, что в рамках текущей Company нет пользователя с таким email.
Создать запись в таблице users:
○ email,
○ passwordHash (bcrypt/argon2),
○ role = 'STUDENT',
○ companyId.
3. Создать запись в students:
○ userId,
○ companyId,
○ fullName,
○ bindingCode (генерация вида "S-" + Random(4)),
○ xpTotal = 0, xpSpent = 0,
○ avatarConfig (JSON с дефолтным аватаром).
4. Стартовать процесс в Camunda с ключом student_registration:
○ переменные: email, userId, companyId, source = "web", registeredAt, countryId (если страна выбрана
при регистрации).
5. Сохранить camundaProcessInstanceId в students.
6. Вернуть accessToken + refreshToken.
После успешной регистрации:
● автоматический логин,
● редирект:
○ студент → /student/dashboard.
2.1.2. Авторизация
Маршрут: /login.
Форма:
● email + password.
Backend: POST /auth/login
● Проверка email + пароля.
● Определение роли (STUDENT, CURATOR, ADMIN) и companyId.
● Выдача JWT-токенов (access/refresh).
Редиректы фронтенда:
● role = STUDENT → /student/dashboard,
● role = CURATOR → /curator/dashboard,
● role = ADMIN → /curator/dashboard (общая панель + админ-пункты меню).
Защищённые маршруты:
● /student/** — доступ только STUDENT.
● /curator/** — доступ CURATOR и ADMIN.
● /admin/** (если будет выделено) — только ADMIN.
При отсутствии доступа:
● редирект на /login,
● сброс локальных токенов.
2.1.3. Управление пользователями компании
Только для Company Admin:
● Создание аккаунтов кураторов:
○ email, пароль, имя,
○ роль CURATOR,
○ привязка к companyId.
● Управление админами:
○ возможность создать ещё одного ADMIN в пределах Company.
● Деактивация пользователей (флаг isActive = false вместо физического удаления).
2.1.4. Создание и управление студентами (MVP)
В актуальной версии MVP студенты не регистрируются через публичную форму /auth/register. Учётные записи
студентов создаются Company Admin или Curator через админ-панель.
При создании студента администратор или куратор задаёт email и временный пароль. Эти данные фиксируются в
системе и передаются студенту по согласованному каналу (например, email). Студент входит в систему через форму
авторизации /auth/login, используя выданные данные.
Администратор может замораживать/размораживать учётную запись студента (через флаг isActive у связанного user).
Смену пароля студента могут инициировать и администратор, и куратор через интерфейс панели (пароль обновляется
для связанного пользователя).
Отдельная регистрация и отдельный кабинет Parent/родителя не реализуются: родитель при необходимости
использует учётные данные студента и получает уведомления в общей Telegram-группе.
Эндпоинт /auth/register может быть использован в будущем (например, для самостоятельной регистрации студентов),
но в рамках текущего MVP путь регистрации студента через публичную форму закрыт.
2.2. Личный кабинет студента
2.2.1. Главная страница студента — «Адаптивный штаб»
Маршрут: /student/dashboard.
Функционал:
● Приветствие + имя пользователя.
● Блок профиля:
○ Аватар (рендер по avatarConfig → SVG/картинка),
○ Имя,
○ Уровень (расчёт по общей сумме XP, простая лестница, например: level = floor(xpTotal / 200)),
○ xpTotal и xpSpent.
● Прогресс по выбранной стране:
○ выбор активной страны (через CountryContext или аналог),
○ отображение:
■ общее количество обязательных Tasks для страны,
■ количество закрытых (status = DONE),
■ прогресс в %,
■ прогресс-бар.
● Быстрые карточки-переходы:
○ «Мои задачи» → /student/tasks,
○ «Kanban-доска» → /student/kanban,
○ «Мои программы» → /student/programs,
○ «Моя папка» → /student/folder.
Источники данных:
● students (профиль и XP),
● tasks + task_progress (прогресс),
● countries, programs (страны/программы).
2.2.2. Модуль «Tasks» (ранее Quests)
Маршрут: /student/tasks
(в текущем прототипе может быть /student/quests — привести к новому неймингу).
Бизнес-логика Task Matrix:
● При назначении студенту страны и программ система генерирует набор Tasks:
○ Country Task Templates (базовые задачи страны),
○ University/Program Task Templates (задачи конкретных программ),
○ кастомные Tasks, созданные куратором вручную.
● Дедупликация:
○ если несколько программ требуют один и тот же документ/действие (паспорт, IELTS,
мотивационное письмо), создаётся одна Task для студента, связанная с несколькими
программами через таблицу связей (например, TaskProgramLink).
Архивированные Tasks становятся недоступны студенту для редактирования и не учитываются в текущем прогрессе и
календаре.
Если студенту меняют страну или набор университетов/программ, все Tasks, связанные с
университетами/программами, которые больше не привязаны к студенту, переводятся в состояние архива.
Смена страны/программ и архивация задач:
Куратор/модератор может вручную архивировать или разархивировать задачи через интерфейс трекера (при наличии
прав).
Структура Task (логически):
● id,
● companyId,
● studentId,
● stage (этап: PREPARATION, DOCS, VISA и т.п.),
● title,
● description (Markdown),
● xpReward (количество XP),
● deadline,
● isCritical (обязательная ли задача),
● linksToDocumentId (если Task закрывает конкретный документ),
● submissionType:
○ NONE — без вложений (только чекбокс),
○ TEXT — строка,
○ LINK — URL,
○ FILE — загрузка файла,
○ CREDENTIALS — набор полей (логин/пароль и т.п.),
● submissionLabel, submissionFields (для CREDENTIALS),
● status (на текущий момент — для упрощения: TODO, REVIEW, CHANGES_REQUESTED, DONE),
● isXpBlocked (true, если дедлайн просрочен и XP за Task не начисляется).
UI / функционал страницы /student/tasks:
● Группировка Tasks по stage (как сейчас в UI для квестов).
● Карточка Task:
○ заголовок,
○ XP,
○ статус:
■ TODO — обычный вид,
■ REVIEW — бейдж «На проверке»,
■ CHANGES_REQUESTED — бейдж «Нужна доработка»,
■ DONE — зелёная отметка,
○ визуальное выделение просроченных Tasks (deadline < сегодня и не DONE).
● Детальная карточка Task (модальное окно TaskDetailModal, аналог QuestDetailModal):
○ описание (Markdown),
○ XP,
○ дедлайн,
○ текущий статус,
○ комментарий куратора (если есть, особенно в статусе CHANGES_REQUESTED),
○ блок отправки результата (в зависимости от submissionType):
■ TEXT → текстовое поле,
■ LINK → поле с валидацией URL,
■ FILE → загрузка PDF/файла,
■ CREDENTIALS → динамическая форма по submissionFields.
Для FILE:
● допуск: только application/pdf (для MVP),
● максимальный размер: 5 МБ,
● при превышении:
○ отображать понятное сообщение,
○ подсказка со ссылкой на сервис сжатия (как уже реализовано в UI).
После отправки:
● создаётся/обновляется запись в task_progress:
○ status = REVIEW,
○ submission (строка/JSON/ключ файла в S3),
○ updatedBy = studentId,
● карточка Task переводится в статус REVIEW.
DONE → CHANGES_REQUESTED — куратор/модератор может вернуть ранее принятую задачу, если позже
обнаружена ошибка.
CHANGES_REQUESTED → REVIEW — студент повторно отправляет задачу на проверку.
REVIEW → CHANGES_REQUESTED — куратор/модератор запрашивает доработку.
REVIEW → DONE — куратор/модератор одобряет задачу.
TODO → REVIEW — студент отправляет задачу на проверку.
Разрешённые переходы статусов:
Ограничения:
● DONE — студент не может редактировать/повторно отправлять (кнопки disabled).
● CHANGES_REQUESTED — студент видит комментарий куратора и может отправить заново (статус → REVIEW).
2.2.3. Kanban-доска студента
Маршрут: /student/kanban.
Колонки:
● To Do
● On Review
○ статус TODO или CHANGES_REQUESTED;
○ статус REVIEW;
● Done
○ статус DONE.
Функционал:
● Карточки Tasks по колонкам.
● В заголовках колонок — счётчики (количество задач).
● По клику — открыть TaskDetailModal.
● Drag-n-drop для перетаскивания:
○ MVP: можно оставить только визуальный drag без изменения статуса (истина — статус меняет
только отправка/ревью),
○ в дальнейшем — при переносе в другую колонку отправлять PUT-запрос на обновление статуса (с
правилами).
Источник данных:
● tasks + task_progress для текущего студента.
2.2.4. Календарь студента
Маршрут: /student/calendar.
Источники событий:
● дедлайны Tasks (обязательных для текущей страны/программ),
Отдельные даты экзаменов (например, IELTS) не создаются как отдельные события календаря — при необходимости
они оформляются как Tasks с соответствующим дедлайном.
● дедлайны программ (programs.deadline).
Событие:
● дата,
● тип (TASK / PROGRAM),
● заголовок,
● ссылка на Task/Program.
UI:
● общий компонент Calendar,
● возможность выделять дни с несколькими событиями.
2.2.5. Модуль «Мои программы»
Маршрут: /student/programs.
Функционал:
● Группировка по университетам.
● Для каждого университета:
○ логотип,
○ название,
○ список программ, выбранных студентом.
● Карточка программы:
○ название,
○ дедлайн,
○ статус готовности (по связям с документами/Tasks),
○ по клику — ProgramDetailModal.
ProgramDetailModal:
● название,
● университет,
● дедлайн,
● список требуемых документов (required_document_ids),
● статус по каждому документу (собран/нет),
● ссылку на официальный сайт программы.
2.2.6. Модуль «Моя папка» (готовые документы)
Маршрут: /student/folder.
Бизнес-логика:
● Для активной страны:
○ берём required_document_ids из countries,
○ для каждого документа ищем Tasks со статусом DONE и linksToDocumentId = document.id.
● Документ считается собранным, если есть хотя бы один DONE Task, привязанный к нему.
Функционал:
● Отображение списка документов:
○ категория,
○ название,
○ статус (собрано/не собрано),
○ при собранном — отметить как «Проверен куратором».
● Кнопка «Скачать архивом»:
○ MVP: заглушка (alert),
○ целевое состояние:
■ сбор всех файлов из связанных Tasks,
■ создание zip-архива,
■ выдача ссылки на скачивание (через временный токен).
2.2.7. Геймификация (RPG System) и аватар
XP-экономика:
● Цель: 1000 XP = «полная готовность» студента по его текущему маршруту (страна + выбранные программы).
● Для каждого студента общий пул XP фиксирован и равен 1000.
○ При генерации задач для студента считается общее количество активных Tasks N; xpReward для
одной задачи = 1000 / N (с округлением до целого).
○ XP глобален по студенту и не привязан к конкретной стране: все выполненные задачи суммируются
в xpTotal.
Начисление XP:
● XP начисляется только при переходе Task в статус DONE.
● При просрочке:
○ если Task отправлен в REVIEW после deadline → флаг isXpBlocked = true,
○ XP за Task не начисляется даже при DONE.
Аватар студента:
● avatarConfig (JSON: конфиг аватара с слоями hat/top/bottom/glasses и др.),
○ шапка/головной убор (hat),
○ верх (top) и низ (bottom — штаны/шорты),
○ очки (glasses) и дополнительные аксессуары.
○ аксессуары и т.п.
● Генерация:
○ на сервере (Node) генерируется SVG/PNG на основе avatarConfig,
○ фронтенд показывает аватар как изображение.
Магазин:
● Маршрут (на будущее): /student/avatar или /student/shop.
● Покупка кастомизаций за XP (xpSpent увеличивается, xpTotal не уменьшается — или отдельное поле
xpBalance).
2.3. Личный кабинет куратора
2.3.1. Панель студентов
Маршрут: /curator/dashboard или /curator/students.
Функционал:
● Список студентов текущей Company.
● Для каждого:
○ имя,
○ страна (флаг + название),
○ прогресс:
■ количество завершённых Tasks / общее количество обязательных,
■ прогресс-бар,
○ индикаторы:
■ «На проверке: X задач»,
■ «Риск по дедлайнам» (например, если есть критические Tasks с дедлайном < N дней),
○ статус Telegram-связи:
■ TG_CONNECTED, TG_NOT_CONNECTED.
Фильтры/сортировки:
● по стране,
● по прогрессу,
● по количеству задач в REVIEW,
● по наличию Telegram-группы.
Клик по студенту → переход в досье студента.
2.3.2. Досье студента
Маршрут: /curator/student/[studentId].
Секции:
1. Шапка:
○ имя студента,
○ страна,
○ прогресс,
○ статус Telegram-связи (иконка),
○ bindingCode (если группа не привязана).
2. Task Tracker (Трекер задач):
○ список Tasks по стадии/статусу,
○ в каждой строке:
■ название,
возможный внутренний «soft deadline» для проверки (виден только куратору, не студенту),
■ статус,
■ дедлайн (с подсветкой просрочки),
■ краткое содержимое submission (если есть).
3. Просмотр и ревью Tasks:
○ для Tasks со статусом REVIEW:
■ просмотр submission:
■ текст,
■ ссылка,
■ или ссылка на скачивание файла,
■ поле comment (комментарий куратора),
■ кнопки:
■ «Одобрить»:
■ статус → DONE,
■ начисление XP (если isXpBlocked = false),
■ «Отправить на доработку»:
■ обязательный комментарий,
■ статус → CHANGES_REQUESTED.
4. Академический профиль:
○ email,
○ GPA,
○ IELTS (если заполнены).
5. Выбранные программы:
○ список программ,
○ статус готовности по каждой (по документам/Tasks).
2.3.3. Глобальный инбокс ревью
Маршрут: /curator/review.
Функционал:
● Список всех Tasks в статусе REVIEW (по всем студентам текущей Company).
● Для каждой записи:
○ название Task,
○ студент (ФИО),
○ страна,
○ дедлайн,
○ краткий вид submission,
○ быстрые кнопки Одобрить / На доработку.
Цель: куратор может работать в режиме «входящая корзина», не заходя в каждого студента.
2.4. Админ-панель
2.4.1. Уровень Company (multi-company настройки)
Фаза 2+, но заложить в модель:
● Таблица companies:
○ название,
○ бренд-конфиг (logoUrl, цвета),
○ лимиты (максимальное количество студентов и т.п.).
Company Admin может:
● редактировать название/брендинг,
● просматривать сводную статистику по своей Company.
2.4.2. Конфигуратор стран / университетов / Tasks
Маршрут: /curator/admin/countries.
Функционал (как сейчас, но с backend):
● Колонка «Страны»:
○ список стран (countries), привязанных к текущей Company (или глобальный справочник).
● Колонка «Университеты»:
○ список университетов (universities) выбранной страны.
● Колонка «Редактор задач» (теперь TaskEditor):
○ список Tasks (шаблонов) для данного профиля (university_profiles.assignedTasks),
○ операции:
■ добавить Task,
■ удалить,
■ отредактировать (title, stage, description, xpReward, deadline, submissionType).
Модалка TaskEditModal (раньше QuestEditModal):
● поля:
○ stage,
○ title,
○ description (MD),
○ xpReward,
○ deadline (относительный или абсолютный),
○ submissionType,
○ submissionFields (для CREDENTIALS),
○ флаг isCritical.
Кнопка «Сохранить все изменения»:
● отправка изменений в backend:
○ обновление university_profiles,
○ создание/обновление соответствующих task_templates.
2.4.3. Управление студентами
Маршрут: /curator/students (кнопки в шапке).
Функционал:
● «+ Добавить студента» — AddStudentModal:
○ Шаг 1: имя, email, страна.
○ Шаг 2: выбор университетов/программ.
○ Шаг 3: выбор/подтверждение набора Tasks (на основе матрицы + кастомные).
○ Шаг 4: подтверждение.
● При нажатии «Создать»:
○ создаётся user с ролью STUDENT,
○ создаётся student,
○ генерируются Tasks для него.
● Импорт студентов:
○ MVP: заглушка (кнопка + модальное сообщение),
○ целевое состояние:
■ загрузка CSV/Excel,
■ маппинг колонок,
■ пакетное создание студентов/Tasks.
2.5. Интеграция с Telegram
2.5.1. Binding Flow (привязка группы)
Схема:
1. Куратор создаёт групповую беседу в Telegram.
2. Добавляет туда:
○ Студента,
○ Родителей (по желанию),
○ себя,
○ бота @AbbitBot.
3. В досье студента в веб-интерфейсе куратор видит:
○ Binding Code вида S-4921.
4. Куратор пишет в группу:
/link S-4921
5. Backend по webhook от Telegram:
○ находит студента по bindingCode,
○ сохраняет telegramGroupId в students,
○ помечает статус связки TG_CONNECTED.
6. Бот отвечает в группу:
○ «✅ Группа успешно подключена к профилю [Имя студента]. Ожидайте уведомлений.»
Для одного студента в MVP поддерживается не более одной привязанной Telegram-группы (одно значение
telegramGroupId). Повторная привязка второй группы в рамках MVP не реализуется.
Отключение уведомлений для конкретного студента (per-student notification settings) в MVP не поддерживается.
2.5.2. Сценарии уведомлений (MVP)
● Deadline Warning (cron, 1 раз в день утром):
○ если до дедлайна критического Task осталось N дней (настройка, например, 2 дня),
○ сообщение в группу:
■ «⚠ Внимание! До сдачи задачи „[Название]“ осталось 2 дня.»
● Submission Review:
○ при CHANGES_REQUESTED:
■ «❌ Куратор вернул задачу „[Название]“ на доработку. Комментарий: [comment].»
○ при DONE:
Напоминания куратору о задачах в статусе REVIEW:
если задача находится в статусе REVIEW более 48 часов (без учёта выходных) с момента отправки студентом, куратор
получает напоминание о необходимости проверки.
Логика игнорирования выходных: задача, отправленная в пятницу, впервые попадает в зону напоминаний не ранее
вторника (точная реализация может быть уточнена на этапе разработки).
■ «🎉 Задача „[Название]“ принята! Прогресс: [XX]% (+[XP] XP).»
2.6. Интеграция с Camunda (BPMN)
2.6.1. Текущее состояние
Уже есть:
● CamundaService в NestJS,
● методы:
○ getProcessDefinitions(),
○ startProcessByKey(key, variables).
AuthService.register стартует процесс student_registration.
2.6.2. Требования ТЗ
Процесс student_registration:
● Входные переменные:
○ email,
○ userId,
○ companyId,
○ source,
○ registeredAt,
○ countryId (если выбрана).
● Основные шаги:
○ автоматическая проверка (simple service task),
○ user-task для куратора: квалификация лида,
○ ветка:
■ approved → студент активен,
■ rejected → студент помечается как отклонённый (флаг isRejected).
● При старте процесса:
○ camundaProcessInstanceId сохраняется в students.
В дальнейшем (этап 2+):
● Возможность:
○ получать от Camunda callbacks (по webhook’у или по polling’у),
○ обновлять статус студентов/Tasks в зависимости от этапа процесса.
3. Нефункциональные требования
3.1. Архитектура и стек
Frontend:
● Next.js (App Router),
● TypeScript,
● Tailwind CSS,
● Zustand/Context для локального состояния (Auth, Country, UI),
● layout’ы:
○ /student/layout.tsx,
○ /curator/layout.tsx.
Backend:
● NestJS (apps/api),
● Модули:
○ AuthModule,
○ CamundaModule,
○ CompanyModule,
○ UsersModule,
○ StudentsModule,
○ TasksModule,
○ DocumentsModule,
○ TelegramModule (по мере готовности).
БД:
● PostgreSQL 15+,
● ORM Prisma.
Инфраструктура:
● Docker + docker-compose (web, api, db, camunda, minio),
● развёртывание: VPS / PaaS.
3.2. Производительность
● Нагрузка MVP:
○ до 200 активных студентов,
○ 10–20 кураторов.
● Время отклика API (95-й перцентиль) < 500 мс для типовых операций.
● Оптимизации:
○ индексы по основным полям (companyId, userId, studentId, status, countryId),
○ пагинация списков (студенты, Tasks),
○ кэширование справочников (страны/университеты/программы) на frontend.
3.3. Безопасность
● Аутентификация:
○ JWT access/refresh,
○ обновление токенов по refresh.
● Пароли:
○ хэширование (bcrypt/argon2),
○ пароль никогда не хранится в открытом виде.
● Данные CREDENTIALS-Tasks:
○ хранить в зашифрованном виде (отдельный encryption-слой),
○ быть доступны студенту, его куратору и администратору компании через защищённый UI (с учётом
ролей и companyId).
Все обращения к данным CREDENTIALS-Tasks логируются (идентификатор пользователя, роль, время доступа, тип
операции).
● Файлы:
○ хранение в S3/MinIO,
○ скачивание только через backend (подписанные ссылки или прокси-метод),
○ проверка прав доступа (роль + companyId).
● Multi-company:
○ строгое применение companyId во всех запросах,
○ unit-тесты/интеграционные тесты на изоляцию.
3.4. Логирование и мониторинг
● Логирование backend:
○ все обращения к Camunda,
○ старт/завершение процессов,
○ изменения статусов Tasks,
○ логин/логаут пользователей,
○ ошибки (HTTP 4xx/5xx).
● Подготовка к интеграции с Sentry / Prometheus (опционально).
3.7. Часовые пояса и дедлайны
Базовый часовой пояс системы для расчёта дедлайнов — Asia/Almaty (Алматы, Казахстан).
Дедлайн задач в базе хранится как дата (без времени) и считается наступившим в 00:00 этого дня по времени Алматы.
В дальнейшем возможен переход к индивидуальным таймзонам студентов, однако в рамках MVP все дедлайны
интерпретируются в таймзоне Алматы.
3.6. Локализация
У каждого студента в профиле хранится поле language (например, «ru», «en», «kz»), задаваемое
модератором/куратором при создании или редактировании студента.
Выбранный язык влияет на язык интерфейса личного кабинета студента и на язык уведомлений (по мере их
реализации).
Backend и модель данных должны быть готовы к добавлению новых языков без изменений схемы БД (используется
строковый код языка).
3.5. Хранение данных, удаление и экспорт
Срок хранения данных одного студента в системе — не более двух лет после завершения работы с ним (критерий
завершения уточняется на этапе внедрения).
Право полного удаления (стирания/анонимизации) данных студента имеет только Company Admin.
Экспорт данных:
Company Admin может экспортировать данные всех студентов своей компании (например, в CSV/Excel).
Curator, к которому привязан студент, может экспортировать данные отдельного студента (профиль, задачи, статусы,
ключевые даты и комментарии).
Экспорт чувствительных данных (включая поля CREDENTIALS) может быть вынесен в отдельный режим или исключён
из общих выгрузок по решению владельца продукта.
4. Модель данных (укрупнённо)
Формат: укрупнённая схема, без всех индексов и ограничений.
4.1. Company и пользователи
companies
● id (uuid, PK),
● name,
● config (JSON: логотип, цвета),
isArchived (bool),
● createdAt, updatedAt.
users
● id (uuid),
● companyId (FK → companies.id),
● email (уникален в рамках companyId),
● passwordHash,
● role (ADMIN, CURATOR, STUDENT),
● isActive (bool),
● createdAt, updatedAt.
4.2. Студенты и профиль
students
● id (uuid),
● companyId,
● userId (FK → users.id),
● fullName,
● countryId (FK → countries.id),
● gpa (nullable),
● ieltsScore (nullable),
● selectedProgramIds (JSONB или отдельная таблица student_programs),
language (string, код языка интерфейса студента),
● Telegram:
○ bindingCode (уникальный код S-XXXX),
○ telegramGroupId (bigint, nullable),
● RPG:
○ xpTotal (int, default 0),
○ xpSpent (int, default 0),
○ avatarConfig (JSON),
● camundaProcessInstanceId (string, nullable),
● createdAt, updatedAt.
4.3. Страны, университеты, программы, документы
countries
● id,
● companyId (если справочник кастомный, либо null для глобальных),
● name,
● flagIcon,
● requiredDocumentIds (JSONB).
universities
● id,
● companyId,
● countryId,
● name,
● logoUrl,
● createdAt, updatedAt.
programs
● id,
● companyId,
● universityId,
● title,
● deadline,
● link,
● imageUrl,
● requiredDocumentIds (JSONB).
document_templates
● id,
● companyId,
● category,
● title.
4.4. Task templates и Tasks студента
task_templates
● id,
● companyId,
● stage,
● title,
● description,
● xpReward,
● defaultDeadlineOffset (например, +30 дней от даты события),
● linksToDocumentId (FK → document_templates.id, nullable),
● submissionType,
● submissionLabel,
● submissionFields (JSON для CREDENTIALS),
● isCritical,
● createdAt, updatedAt.
university_profiles
● id,
● companyId,
● countryId,
● universityId,
● assignedTaskTemplateIds (JSONB или связь university_profile_tasks).
tasks (конкретные Tasks студенту)
● id (int, autoincrement или uuid),
● companyId,
● studentId,
● taskTemplateId (nullable, если Task кастомный),
● stage,
● title,
● description,
● deadline (конкретная дата),
● xpReward,
● isCritical,
● linksToDocumentId,
● submissionType,
● submissionLabel,
● submissionFields,
● status (TODO, REVIEW, CHANGES_REQUESTED, DONE),
● isCustom (bool),
● isXpBlocked (bool),
● createdAt, updatedAt.
task_progress (можно хранить отдельно, но для MVP статус и submission можно держать в tasks; ниже более гибкий
вариант)
● id,
● companyId,
● taskId (FK → tasks.id),
● studentId,
● status,
● submission (JSON/строка/ключ файла),
● comment (последний комментарий куратора),
● updatedBy (userId — студент/куратор),
● createdAt, updatedAt.
5. API
Основные эндпоинты (без детальной спецификации типов запросов/ответов):
5.1. Auth
● POST /auth/register — регистрация студента + старт Camunda процесса.
● POST /auth/login — авторизация.
● POST /auth/refresh — обновление токенов.
5.2. Student
● GET /student/profile — профиль студента (XP, аватар, страна).
● GET /student/tasks — список Tasks (с фильтрами по статусу/стадии).
● GET /student/tasks/:id — детализация Task.
● POST /student/tasks/:id/submit — отправка результата (TEXT/LINK/FILE/CREDENTIALS).
● GET /student/calendar — события календаря.
● GET /student/programs — список программ студента.
● GET /student/folder — собранные документы.
5.3. Curator
● GET /curator/students — список студентов с прогрессом.
● GET /curator/students/:id — досье.
● GET /curator/review — глобальный список Tasks в REVIEW.
● POST /curator/tasks/:taskId/approve — одобрение (статус → DONE, начисление XP).
● POST /curator/tasks/:taskId/request-changes — запрос доработки (статус → CHANGES_REQUESTED,
комментарий).
5.4. Admin / Company
● GET /admin/countries, POST /admin/countries — управление странами.
● GET /admin/universities, POST /admin/universities.
● GET /admin/programs, POST /admin/programs.
● GET /admin/university-profiles/:id — профили университетов (assignedTaskTemplates).
● POST /admin/university-profiles/:id — сохранение изменений.
5.5. Camunda / системное
● GET /camunda/process-definitions — список процесса (для диагностики).
● POST /camunda/process/:key/start — старт процесса (внутренний сервисный метод).
6. Этапы реализации (8 недель)
Общие роли
Продукт (Product) — с самого начала (формулировка фич, приоритизация).
Дизайнер — активно в начале (UX/UI), затем в доработках.
Backend-разработчик — стартует параллельно с дизайнером.
Frontend-разработчик — подключается после утверждения базового дизайна и API-контрактов.
Недели 1–2. Аналитика, дизайн, базовый backend
1. Уточнение бизнес-требований и приоритета фич MVP.
2. Проработка UX-флоу:
a. онбординг студента,
b. доска задач,
c. панель куратора,
d. админ-панель.
3. Дизайн базового UI (Figma):
a. Student Dashboard,
b. Curator Dashboard,
c. Task Detail,
d. Admin Countries/Universities.
4. Backend:
a. настройка NestJS проекта и PostgreSQL,
b. реализация Company, Users, Auth (регистрация, логин, JWT),
c. интеграция с CamundaService (тестовый student_registration).
5. Недели 3–4. Backend ядро: Tasks и Students
6. Реализация моделей:
a. students,
b. countries, universities, programs, document_templates,
c. task_templates, tasks, task_progress.
Логика Task Matrix (генерация Tasks для студента).
7. 8. API:
a. /student/tasks, /student/tasks/:id/submit,
9. b. /curator/students, /curator/students/:id,
c. /curator/review,
d. /admin/university-profiles.
Начальное подключение TelegramModule (минимум: обработка /link и привязка telegramGroupId).
10. Недели 5–6. Frontend: Student Area
11. Верстка и логика:
a. /student/dashboard,
b. /student/tasks + TaskDetailModal,
c. /student/kanban,
d. /student/programs,
e. /student/folder,
f. /student/calendar.
12. Интеграция с реальным API (удаление моков/localStorage).
13. Отрисовка аватара и XP.
14. Недели 7–8. Frontend: Curator/Admin + полировка
15. Верстка и логика:
a. /curator/dashboard / /curator/students,
b. /curator/student/[id],
c. /curator/review,
d. /curator/admin/countries.
16. Подключение ревью-флоу:
a. approve / request-changes.
17. Доработка Telegram-уведомлений (минимальный сценарий дедлайнов и статусов).
18. Тестирование:
a. unit-тесты ключевых сервисов,
b. end-to-end сценарии «студент + куратор»,
c. проверка multi-company изоляции на тестовых данных.
--- END FILE: tz.md ---
